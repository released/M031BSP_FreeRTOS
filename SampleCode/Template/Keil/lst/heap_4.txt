; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\heap_4.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\heap_4.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -I..\..\..\ThirdParty\FreeRTOS\Source\include -I..\..\..\ThirdParty\FreeRTOS\Demo\Common\include -I..\..\..\ThirdParty\FreeRTOS\Source\portable\RVDS\ARM_CM0 -I..\..\..\ThirdParty\FreeRTOS -I..\..\Template -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\heap_4.crf ..\..\..\ThirdParty\FreeRTOS\Source\portable\MemMang\heap_4.c]
                          THUMB

                          AREA ||i.prvHeapInit||, CODE, READONLY, ALIGN=2

                  prvHeapInit PROC
;;;328    
;;;329    static void prvHeapInit( void )
000000  2105              MOVS     r1,#5
;;;330    {
;;;331    BlockLink_t *pxFirstFreeBlock;
;;;332    uint8_t *pucAlignedHeap;
;;;333    size_t uxAddress;
;;;334    size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
;;;335    
;;;336    	/* Ensure the heap starts on a correctly aligned boundary. */
;;;337    	uxAddress = ( size_t ) ucHeap;
000002  480e              LDR      r0,|L1.60|
000004  02c9              LSLS     r1,r1,#11             ;334
;;;338    
;;;339    	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
000006  0742              LSLS     r2,r0,#29
000008  d005              BEQ      |L1.22|
00000a  1dc0              ADDS     r0,r0,#7              ;330
;;;340    	{
;;;341    		uxAddress += ( portBYTE_ALIGNMENT - 1 );
;;;342    		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
00000c  08c0              LSRS     r0,r0,#3
;;;343    		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
00000e  4a0b              LDR      r2,|L1.60|
000010  00c0              LSLS     r0,r0,#3              ;342
000012  1a82              SUBS     r2,r0,r2
000014  1a89              SUBS     r1,r1,r2
                  |L1.22|
;;;344    	}
;;;345    
;;;346    	pucAlignedHeap = ( uint8_t * ) uxAddress;
;;;347    
;;;348    	/* xStart is used to hold a pointer to the first item in the list of free
;;;349    	blocks.  The void cast is used to prevent compiler warnings. */
;;;350    	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
000016  4b0a              LDR      r3,|L1.64|
;;;351    	xStart.xBlockSize = ( size_t ) 0;
000018  2200              MOVS     r2,#0
;;;352    
;;;353    	/* pxEnd is used to mark the end of the list of free blocks and is inserted
;;;354    	at the end of the heap space. */
;;;355    	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
00001a  1841              ADDS     r1,r0,r1
00001c  c305              STM      r3!,{r0,r2}           ;351
00001e  3908              SUBS     r1,r1,#8
;;;356    	uxAddress -= xHeapStructSize;
;;;357    	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
000020  08c9              LSRS     r1,r1,#3
000022  00c9              LSLS     r1,r1,#3
;;;358    	pxEnd = ( void * ) uxAddress;
000024  3b18              SUBS     r3,r3,#0x18
;;;359    	pxEnd->xBlockSize = 0;
000026  6019              STR      r1,[r3,#0]  ; pxEnd
;;;360    	pxEnd->pxNextFreeBlock = NULL;
000028  604a              STR      r2,[r1,#4]
;;;361    
;;;362    	/* To start with there is a single free block that is sized to take up the
;;;363    	entire heap space, minus the space taken by pxEnd. */
;;;364    	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
;;;365    	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
00002a  600a              STR      r2,[r1,#0]
00002c  1a0a              SUBS     r2,r1,r0
00002e  c006              STM      r0!,{r1,r2}
;;;366    	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
;;;367    
;;;368    	/* Only one block exists - and it covers the entire usable heap space. */
;;;369    	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
;;;370    	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
000030  609a              STR      r2,[r3,#8]  ; xMinimumEverFreeBytesRemaining
;;;371    
;;;372    	/* Work out the position of the top bit in a size_t variable. */
;;;373    	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
000032  2001              MOVS     r0,#1
000034  07c0              LSLS     r0,r0,#31
000036  605a              STR      r2,[r3,#4]  ; xFreeBytesRemaining
000038  60d8              STR      r0,[r3,#0xc]  ; xBlockAllocatedBit
;;;374    }
00003a  4770              BX       lr
;;;375    /*-----------------------------------------------------------*/
                          ENDP

                  |L1.60|
                          DCD      ||.bss||
                  |L1.64|
                          DCD      ||.data||+0x10

                          AREA ||i.prvInsertBlockIntoFreeList||, CODE, READONLY, ALIGN=2

                  prvInsertBlockIntoFreeList PROC
;;;376    
;;;377    static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
000000  b530              PUSH     {r4,r5,lr}
;;;378    {
;;;379    BlockLink_t *pxIterator;
;;;380    uint8_t *puc;
;;;381    
;;;382    	/* Iterate through the list until a block is found that has a higher address
;;;383    	than the block being inserted. */
;;;384    	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
000002  4911              LDR      r1,|L2.72|
000004  e000              B        |L2.8|
                  |L2.6|
000006  4611              MOV      r1,r2                 ;378
                  |L2.8|
000008  680a              LDR      r2,[r1,#0]
00000a  4282              CMP      r2,r0
00000c  d3fb              BCC      |L2.6|
;;;385    	{
;;;386    		/* Nothing to do here, just iterate to the right position. */
;;;387    	}
;;;388    
;;;389    	/* Do the block being inserted, and the block it is being inserted after
;;;390    	make a contiguous block of memory? */
;;;391    	puc = ( uint8_t * ) pxIterator;
;;;392    	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
00000e  684b              LDR      r3,[r1,#4]
000010  185c              ADDS     r4,r3,r1
000012  4284              CMP      r4,r0
000014  d103              BNE      |L2.30|
;;;393    	{
;;;394    		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
000016  6840              LDR      r0,[r0,#4]
000018  1818              ADDS     r0,r3,r0
;;;395    		pxBlockToInsert = pxIterator;
00001a  6048              STR      r0,[r1,#4]
00001c  4608              MOV      r0,r1
                  |L2.30|
;;;396    	}
;;;397    	else
;;;398    	{
;;;399    		mtCOVERAGE_TEST_MARKER();
;;;400    	}
;;;401    
;;;402    	/* Do the block being inserted, and the block it is being inserted before
;;;403    	make a contiguous block of memory? */
;;;404    	puc = ( uint8_t * ) pxBlockToInsert;
;;;405    	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
00001e  6843              LDR      r3,[r0,#4]
000020  181c              ADDS     r4,r3,r0
000022  4294              CMP      r4,r2
000024  d109              BNE      |L2.58|
;;;406    	{
;;;407    		if( pxIterator->pxNextFreeBlock != pxEnd )
000026  4c08              LDR      r4,|L2.72|
000028  3c10              SUBS     r4,r4,#0x10
00002a  6824              LDR      r4,[r4,#0]  ; pxEnd
00002c  42a2              CMP      r2,r4
00002e  d009              BEQ      |L2.68|
;;;408    		{
;;;409    			/* Form one big block from the two blocks. */
;;;410    			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
000030  6852              LDR      r2,[r2,#4]
000032  189a              ADDS     r2,r3,r2
;;;411    			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
000034  6042              STR      r2,[r0,#4]
000036  680a              LDR      r2,[r1,#0]
000038  6812              LDR      r2,[r2,#0]
                  |L2.58|
;;;412    		}
;;;413    		else
;;;414    		{
;;;415    			pxBlockToInsert->pxNextFreeBlock = pxEnd;
;;;416    		}
;;;417    	}
;;;418    	else
;;;419    	{
;;;420    		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
00003a  6002              STR      r2,[r0,#0]
                  |L2.60|
;;;421    	}
;;;422    
;;;423    	/* If the block being inserted plugged a gab, so was merged with the block
;;;424    	before and the block after, then it's pxNextFreeBlock pointer will have
;;;425    	already been set, and should not be set here as that would make it point
;;;426    	to itself. */
;;;427    	if( pxIterator != pxBlockToInsert )
00003c  4281              CMP      r1,r0
00003e  d000              BEQ      |L2.66|
;;;428    	{
;;;429    		pxIterator->pxNextFreeBlock = pxBlockToInsert;
000040  6008              STR      r0,[r1,#0]
                  |L2.66|
;;;430    	}
;;;431    	else
;;;432    	{
;;;433    		mtCOVERAGE_TEST_MARKER();
;;;434    	}
;;;435    }
000042  bd30              POP      {r4,r5,pc}
                  |L2.68|
000044  6004              STR      r4,[r0,#0]            ;415
000046  e7f9              B        |L2.60|
;;;436    
                          ENDP

                  |L2.72|
                          DCD      ||.data||+0x10

                          AREA ||i.pvPortMalloc||, CODE, READONLY, ALIGN=2

                  pvPortMalloc PROC
;;;112    
;;;113    void *pvPortMalloc( size_t xWantedSize )
000000  b5f8              PUSH     {r3-r7,lr}
;;;114    {
000002  4605              MOV      r5,r0
;;;115    BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
;;;116    void *pvReturn = NULL;
000004  2600              MOVS     r6,#0
;;;117    
;;;118    	vTaskSuspendAll();
000006  f7fffffe          BL       vTaskSuspendAll
;;;119    	{
;;;120    		/* If this is the first call to malloc then the heap will require
;;;121    		initialisation to setup the list of free blocks. */
;;;122    		if( pxEnd == NULL )
00000a  4f2a              LDR      r7,|L3.180|
00000c  6838              LDR      r0,[r7,#0]  ; pxEnd
00000e  2800              CMP      r0,#0
000010  d101              BNE      |L3.22|
;;;123    		{
;;;124    			prvHeapInit();
000012  f7fffffe          BL       prvHeapInit
                  |L3.22|
;;;125    		}
;;;126    		else
;;;127    		{
;;;128    			mtCOVERAGE_TEST_MARKER();
;;;129    		}
;;;130    
;;;131    		/* Check the requested block size is not so large that the top bit is
;;;132    		set.  The top bit of the block size member of the BlockLink_t structure
;;;133    		is used to determine who owns the block - the application or the
;;;134    		kernel, so it must be free. */
;;;135    		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
000016  68f8              LDR      r0,[r7,#0xc]  ; xBlockAllocatedBit
000018  4205              TST      r5,r0
00001a  d13f              BNE      |L3.156|
;;;136    		{
;;;137    			/* The wanted size is increased so it can contain a BlockLink_t
;;;138    			structure in addition to the requested amount of bytes. */
;;;139    			if( xWantedSize > 0 )
00001c  2d00              CMP      r5,#0
00001e  d03d              BEQ      |L3.156|
000020  3508              ADDS     r5,r5,#8
;;;140    			{
;;;141    				xWantedSize += xHeapStructSize;
;;;142    
;;;143    				/* Ensure that blocks are always aligned to the required number
;;;144    				of bytes. */
;;;145    				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
000022  0768              LSLS     r0,r5,#29
000024  d008              BEQ      |L3.56|
;;;146    				{
;;;147    					/* Byte alignment required. */
;;;148    					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
000026  0768              LSLS     r0,r5,#29
000028  0f40              LSRS     r0,r0,#29
00002a  2108              MOVS     r1,#8
00002c  1a08              SUBS     r0,r1,r0
00002e  1945              ADDS     r5,r0,r5
;;;149    					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
000030  0768              LSLS     r0,r5,#29
000032  d001              BEQ      |L3.56|
000034  b672              CPSID    i
                  |L3.54|
000036  e7fe              B        |L3.54|
                  |L3.56|
;;;150    				}
;;;151    				else
;;;152    				{
;;;153    					mtCOVERAGE_TEST_MARKER();
;;;154    				}
;;;155    			}
;;;156    			else
;;;157    			{
;;;158    				mtCOVERAGE_TEST_MARKER();
;;;159    			}
;;;160    
;;;161    			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
000038  2d00              CMP      r5,#0
00003a  d02f              BEQ      |L3.156|
00003c  6878              LDR      r0,[r7,#4]  ; xFreeBytesRemaining
00003e  4285              CMP      r5,r0
000040  d82c              BHI      |L3.156|
;;;162    			{
;;;163    				/* Traverse the list from the start	(lowest address) block until
;;;164    				one	of adequate size is found. */
;;;165    				pxPreviousBlock = &xStart;
000042  491c              LDR      r1,|L3.180|
000044  3110              ADDS     r1,r1,#0x10
;;;166    				pxBlock = xStart.pxNextFreeBlock;
000046  4608              MOV      r0,r1
;;;167    				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
000048  6804              LDR      r4,[r0,#0]  ; xStart
00004a  e001              B        |L3.80|
                  |L3.76|
;;;168    				{
;;;169    					pxPreviousBlock = pxBlock;
00004c  4621              MOV      r1,r4
;;;170    					pxBlock = pxBlock->pxNextFreeBlock;
00004e  4604              MOV      r4,r0
                  |L3.80|
000050  6860              LDR      r0,[r4,#4]            ;167
000052  42a8              CMP      r0,r5                 ;167
000054  d202              BCS      |L3.92|
000056  6820              LDR      r0,[r4,#0]            ;167
000058  2800              CMP      r0,#0                 ;167
00005a  d1f7              BNE      |L3.76|
                  |L3.92|
;;;171    				}
;;;172    
;;;173    				/* If the end marker was reached then a block of adequate size
;;;174    				was	not found. */
;;;175    				if( pxBlock != pxEnd )
00005c  6838              LDR      r0,[r7,#0]  ; pxEnd
00005e  4284              CMP      r4,r0
000060  d01c              BEQ      |L3.156|
;;;176    				{
;;;177    					/* Return the memory space pointed to - jumping over the
;;;178    					BlockLink_t structure at its start. */
;;;179    					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
;;;180    
;;;181    					/* This block is being returned for use so must be taken out
;;;182    					of the list of free blocks. */
;;;183    					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
000062  680e              LDR      r6,[r1,#0]
000064  6820              LDR      r0,[r4,#0]
;;;184    
;;;185    					/* If the block is larger than required it can be split into
;;;186    					two. */
;;;187    					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
000066  6008              STR      r0,[r1,#0]
000068  6860              LDR      r0,[r4,#4]
00006a  3608              ADDS     r6,r6,#8
00006c  1b41              SUBS     r1,r0,r5
00006e  2910              CMP      r1,#0x10
000070  d908              BLS      |L3.132|
;;;188    					{
;;;189    						/* This block is to be split into two.  Create a new
;;;190    						block following the number of bytes requested. The void
;;;191    						cast is used to prevent byte alignment warnings from the
;;;192    						compiler. */
;;;193    						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
000072  1960              ADDS     r0,r4,r5
;;;194    						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
000074  0742              LSLS     r2,r0,#29
000076  d001              BEQ      |L3.124|
000078  b672              CPSID    i
                  |L3.122|
00007a  e7fe              B        |L3.122|
                  |L3.124|
;;;195    
;;;196    						/* Calculate the sizes of two blocks split from the
;;;197    						single block. */
;;;198    						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
;;;199    						pxBlock->xBlockSize = xWantedSize;
00007c  6041              STR      r1,[r0,#4]
;;;200    
;;;201    						/* Insert the new block into the list of free blocks. */
;;;202    						prvInsertBlockIntoFreeList( pxNewBlockLink );
00007e  6065              STR      r5,[r4,#4]
000080  f7fffffe          BL       prvInsertBlockIntoFreeList
                  |L3.132|
;;;203    					}
;;;204    					else
;;;205    					{
;;;206    						mtCOVERAGE_TEST_MARKER();
;;;207    					}
;;;208    
;;;209    					xFreeBytesRemaining -= pxBlock->xBlockSize;
000084  6861              LDR      r1,[r4,#4]
000086  6878              LDR      r0,[r7,#4]  ; xFreeBytesRemaining
000088  1a40              SUBS     r0,r0,r1
;;;210    
;;;211    					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
00008a  6078              STR      r0,[r7,#4]  ; xFreeBytesRemaining
00008c  68ba              LDR      r2,[r7,#8]  ; xMinimumEverFreeBytesRemaining
00008e  4290              CMP      r0,r2
000090  d200              BCS      |L3.148|
;;;212    					{
;;;213    						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
000092  60b8              STR      r0,[r7,#8]  ; xMinimumEverFreeBytesRemaining
                  |L3.148|
;;;214    					}
;;;215    					else
;;;216    					{
;;;217    						mtCOVERAGE_TEST_MARKER();
;;;218    					}
;;;219    
;;;220    					/* The block is being returned - it is allocated and owned
;;;221    					by the application and has no "next" block. */
;;;222    					pxBlock->xBlockSize |= xBlockAllocatedBit;
000094  68f8              LDR      r0,[r7,#0xc]  ; xBlockAllocatedBit
000096  4301              ORRS     r1,r1,r0
;;;223    					pxBlock->pxNextFreeBlock = NULL;
000098  2000              MOVS     r0,#0
00009a  c403              STM      r4!,{r0,r1}
                  |L3.156|
;;;224    				}
;;;225    				else
;;;226    				{
;;;227    					mtCOVERAGE_TEST_MARKER();
;;;228    				}
;;;229    			}
;;;230    			else
;;;231    			{
;;;232    				mtCOVERAGE_TEST_MARKER();
;;;233    			}
;;;234    		}
;;;235    		else
;;;236    		{
;;;237    			mtCOVERAGE_TEST_MARKER();
;;;238    		}
;;;239    
;;;240    		traceMALLOC( pvReturn, xWantedSize );
;;;241    	}
;;;242    	( void ) xTaskResumeAll();
00009c  f7fffffe          BL       xTaskResumeAll
;;;243    
;;;244    	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
;;;245    	{
;;;246    		if( pvReturn == NULL )
0000a0  2e00              CMP      r6,#0
0000a2  d101              BNE      |L3.168|
;;;247    		{
;;;248    			extern void vApplicationMallocFailedHook( void );
;;;249    			vApplicationMallocFailedHook();
0000a4  f7fffffe          BL       vApplicationMallocFailedHook
                  |L3.168|
;;;250    		}
;;;251    		else
;;;252    		{
;;;253    			mtCOVERAGE_TEST_MARKER();
;;;254    		}
;;;255    	}
;;;256    	#endif
;;;257    
;;;258    	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
0000a8  0770              LSLS     r0,r6,#29
0000aa  d001              BEQ      |L3.176|
0000ac  b672              CPSID    i
                  |L3.174|
0000ae  e7fe              B        |L3.174|
                  |L3.176|
;;;259    	return pvReturn;
0000b0  4630              MOV      r0,r6
;;;260    }
0000b2  bdf8              POP      {r3-r7,pc}
;;;261    /*-----------------------------------------------------------*/
                          ENDP

                  |L3.180|
                          DCD      ||.data||

                          AREA ||i.vPortFree||, CODE, READONLY, ALIGN=2

                  vPortFree PROC
;;;262    
;;;263    void vPortFree( void *pv )
000000  b570              PUSH     {r4-r6,lr}
;;;264    {
;;;265    uint8_t *puc = ( uint8_t * ) pv;
;;;266    BlockLink_t *pxLink;
;;;267    
;;;268    	if( pv != NULL )
000002  2800              CMP      r0,#0
000004  d01a              BEQ      |L4.60|
000006  4604              MOV      r4,r0                 ;264
;;;269    	{
;;;270    		/* The memory being freed will have an BlockLink_t structure immediately
;;;271    		before it. */
;;;272    		puc -= xHeapStructSize;
;;;273    
;;;274    		/* This casting is to keep the compiler from issuing warnings. */
;;;275    		pxLink = ( void * ) puc;
;;;276    
;;;277    		/* Check the block is actually allocated. */
;;;278    		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
000008  4d0d              LDR      r5,|L4.64|
00000a  3c08              SUBS     r4,r4,#8              ;264
00000c  6860              LDR      r0,[r4,#4]
00000e  68e9              LDR      r1,[r5,#0xc]  ; xBlockAllocatedBit
000010  4208              TST      r0,r1
000012  d101              BNE      |L4.24|
000014  b672              CPSID    i
                  |L4.22|
000016  e7fe              B        |L4.22|
                  |L4.24|
;;;279    		configASSERT( pxLink->pxNextFreeBlock == NULL );
000018  6822              LDR      r2,[r4,#0]
00001a  2a00              CMP      r2,#0
00001c  d001              BEQ      |L4.34|
00001e  b672              CPSID    i
                  |L4.32|
000020  e7fe              B        |L4.32|
                  |L4.34|
;;;280    
;;;281    		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
;;;282    		{
;;;283    			if( pxLink->pxNextFreeBlock == NULL )
;;;284    			{
;;;285    				/* The block is being returned to the heap - it is no longer
;;;286    				allocated. */
;;;287    				pxLink->xBlockSize &= ~xBlockAllocatedBit;
000022  4388              BICS     r0,r0,r1
;;;288    
;;;289    				vTaskSuspendAll();
000024  6060              STR      r0,[r4,#4]
000026  f7fffffe          BL       vTaskSuspendAll
;;;290    				{
;;;291    					/* Add this block to the list of free blocks. */
;;;292    					xFreeBytesRemaining += pxLink->xBlockSize;
00002a  6860              LDR      r0,[r4,#4]
00002c  6869              LDR      r1,[r5,#4]  ; xFreeBytesRemaining
00002e  1840              ADDS     r0,r0,r1
;;;293    					traceFREE( pv, pxLink->xBlockSize );
;;;294    					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
000030  6068              STR      r0,[r5,#4]  ; xFreeBytesRemaining
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       prvInsertBlockIntoFreeList
;;;295    				}
;;;296    				( void ) xTaskResumeAll();
000038  f7fffffe          BL       xTaskResumeAll
                  |L4.60|
;;;297    			}
;;;298    			else
;;;299    			{
;;;300    				mtCOVERAGE_TEST_MARKER();
;;;301    			}
;;;302    		}
;;;303    		else
;;;304    		{
;;;305    			mtCOVERAGE_TEST_MARKER();
;;;306    		}
;;;307    	}
;;;308    }
00003c  bd70              POP      {r4-r6,pc}
;;;309    /*-----------------------------------------------------------*/
                          ENDP

00003e  0000              DCW      0x0000
                  |L4.64|
                          DCD      ||.data||

                          AREA ||i.vPortInitialiseBlocks||, CODE, READONLY, ALIGN=1

                  vPortInitialiseBlocks PROC
;;;322    
;;;323    void vPortInitialiseBlocks( void )
000000  4770              BX       lr
;;;324    {
;;;325    	/* This just exists to keep the linker quiet. */
;;;326    }
;;;327    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xPortGetFreeHeapSize||, CODE, READONLY, ALIGN=2

                  xPortGetFreeHeapSize PROC
;;;310    
;;;311    size_t xPortGetFreeHeapSize( void )
000000  4801              LDR      r0,|L6.8|
;;;312    {
;;;313    	return xFreeBytesRemaining;
000002  6840              LDR      r0,[r0,#4]  ; xFreeBytesRemaining
;;;314    }
000004  4770              BX       lr
;;;315    /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L6.8|
                          DCD      ||.data||

                          AREA ||i.xPortGetMinimumEverFreeHeapSize||, CODE, READONLY, ALIGN=2

                  xPortGetMinimumEverFreeHeapSize PROC
;;;316    
;;;317    size_t xPortGetMinimumEverFreeHeapSize( void )
000000  4801              LDR      r0,|L7.8|
;;;318    {
;;;319    	return xMinimumEverFreeBytesRemaining;
000002  6880              LDR      r0,[r0,#8]  ; xMinimumEverFreeBytesRemaining
;;;320    }
000004  4770              BX       lr
;;;321    /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ucHeap
                          %        10240

                          AREA ||.data||, DATA, ALIGN=2

                  pxEnd
                          DCD      0x00000000
                  xFreeBytesRemaining
                          DCD      0x00000000
                  xMinimumEverFreeBytesRemaining
                          DCD      0x00000000
                  xBlockAllocatedBit
                          DCD      0x00000000
                  xStart
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\ThirdParty\\FreeRTOS\\Source\\portable\\MemMang\\heap_4.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_heap_4_c_94e30ff9____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___8_heap_4_c_94e30ff9____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_heap_4_c_94e30ff9____REVSH|
#line 402
|__asm___8_heap_4_c_94e30ff9____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
