; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\port.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\port.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -I..\..\..\ThirdParty\FreeRTOS\Source\include -I..\..\..\ThirdParty\FreeRTOS\Demo\Common\include -I..\..\..\ThirdParty\FreeRTOS\Source\portable\RVDS\ARM_CM0 -I..\..\..\ThirdParty\FreeRTOS -I..\..\Template -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\port.crf ..\..\..\ThirdParty\FreeRTOS\Source\portable\RVDS\ARM_CM0\port.c]
                          THUMB

                          AREA ||i.SVC_Handler||, CODE, READONLY, ALIGN=1

                  SVC_Handler PROC
;;;118    
;;;119    void vPortSVCHandler( void )
000000  4770              BX       lr
;;;120    {
;;;121    	/* This function is no longer used, but retained for backward
;;;122    	compatibility. */
;;;123    }
;;;124    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=2

                  SysTick_Handler PROC
;;;279    
;;;280    void xPortSysTickHandler( void )
000000  b510              PUSH     {r4,lr}
;;;281    {
;;;282    uint32_t ulPreviousMask;
;;;283    
;;;284    	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
000002  f7fffffe          BL       ulSetInterruptMaskFromISR
000006  4604              MOV      r4,r0
;;;285    	{
;;;286    		/* Increment the RTOS tick. */
;;;287    		if( xTaskIncrementTick() != pdFALSE )
000008  f7fffffe          BL       xTaskIncrementTick
00000c  2800              CMP      r0,#0
00000e  d003              BEQ      |L2.24|
;;;288    		{
;;;289    			/* Pend a context switch. */
;;;290    			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
000010  2001              MOVS     r0,#1
000012  4903              LDR      r1,|L2.32|
000014  0700              LSLS     r0,r0,#28
000016  6048              STR      r0,[r1,#4]
                  |L2.24|
;;;291    		}
;;;292    	}
;;;293    	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       vClearInterruptMaskFromISR
;;;294    }
00001e  bd10              POP      {r4,pc}
;;;295    /*-----------------------------------------------------------*/
                          ENDP

                  |L2.32|
                          DCD      0xe000ed00

                          AREA ||i.prvTaskExitError||, CODE, READONLY, ALIGN=2

                  prvTaskExitError PROC
;;;104    
;;;105    static void prvTaskExitError( void )
000000  4803              LDR      r0,|L3.16|
;;;106    {
;;;107    	/* A function that implements a task must not exit or attempt to return to
;;;108    	its caller as there is nothing to return to.  If a task wants to exit it
;;;109    	should instead call vTaskDelete( NULL ).
;;;110    
;;;111    	Artificially force an assert() to be triggered if configASSERT() is
;;;112    	defined, then stop here so application writers can catch the error. */
;;;113    	configASSERT( uxCriticalNesting == ~0UL );
000002  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
000004  1c40              ADDS     r0,r0,#1
;;;114    	portDISABLE_INTERRUPTS();
000006  b672              CPSID    i
000008  d000              BEQ      |L3.12|
                  |L3.10|
00000a  e7fe              B        |L3.10|
                  |L3.12|
;;;115    	for( ;; );
00000c  e7fe              B        |L3.12|
;;;116    }
;;;117    /*-----------------------------------------------------------*/
                          ENDP

00000e  0000              DCW      0x0000
                  |L3.16|
                          DCD      ||.data||

                          AREA ||i.pxPortInitialiseStack||, CODE, READONLY, ALIGN=2

                  pxPortInitialiseStack PROC
;;;86      */
;;;87     StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
000000  b510              PUSH     {r4,lr}
;;;88     {
;;;89     	/* Simulate the stack frame as it would be created by a context switch
;;;90     	interrupt. */
;;;91     	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
;;;92     	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
000002  2401              MOVS     r4,#1
000004  1f03              SUBS     r3,r0,#4              ;91
000006  0624              LSLS     r4,r4,#24
;;;93     	pxTopOfStack--;
;;;94     	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
;;;95     	pxTopOfStack--;
;;;96     	*pxTopOfStack = ( StackType_t ) prvTaskExitError;	/* LR */
;;;97     	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
;;;98     	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
;;;99     	pxTopOfStack -= 8; /* R11..R4. */
;;;100    
;;;101    	return pxTopOfStack;
000008  601c              STR      r4,[r3,#0]
00000a  1f1b              SUBS     r3,r3,#4
00000c  6019              STR      r1,[r3,#0]
00000e  1f19              SUBS     r1,r3,#4
000010  4b02              LDR      r3,|L4.28|
000012  600b              STR      r3,[r1,#0]
000014  3914              SUBS     r1,r1,#0x14
000016  3840              SUBS     r0,r0,#0x40           ;98
000018  600a              STR      r2,[r1,#0]            ;98
;;;102    }
00001a  bd10              POP      {r4,pc}
;;;103    /*-----------------------------------------------------------*/
                          ENDP

                  |L4.28|
                          DCD      prvTaskExitError

                          AREA ||i.vPortEndScheduler||, CODE, READONLY, ALIGN=2

                  vPortEndScheduler PROC
;;;178    
;;;179    void vPortEndScheduler( void )
000000  4804              LDR      r0,|L5.20|
;;;180    {
;;;181    	/* Not implemented in ports where there is nothing to return to.
;;;182    	Artificially force an assert. */
;;;183    	configASSERT( uxCriticalNesting == 1000UL );
000002  217d              MOVS     r1,#0x7d
000004  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
000006  00c9              LSLS     r1,r1,#3
000008  4288              CMP      r0,r1
00000a  d001              BEQ      |L5.16|
00000c  b672              CPSID    i
                  |L5.14|
00000e  e7fe              B        |L5.14|
                  |L5.16|
;;;184    }
000010  4770              BX       lr
;;;185    /*-----------------------------------------------------------*/
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      ||.data||

                          AREA ||i.vPortEnterCritical||, CODE, READONLY, ALIGN=2

                  vPortEnterCritical PROC
;;;198    
;;;199    void vPortEnterCritical( void )
000000  b672              CPSID    i
;;;200    {
;;;201        portDISABLE_INTERRUPTS();
;;;202        uxCriticalNesting++;
000002  4804              LDR      r0,|L6.20|
000004  6801              LDR      r1,[r0,#0]  ; uxCriticalNesting
000006  1c49              ADDS     r1,r1,#1
;;;203    	__dsb( portSY_FULL_READ_WRITE );
000008  6001              STR      r1,[r0,#0]  ; uxCriticalNesting
00000a  f3bf8f4f          DSB      
;;;204    	__isb( portSY_FULL_READ_WRITE );
00000e  f3bf8f6f          ISB      
;;;205    }
000012  4770              BX       lr
;;;206    /*-----------------------------------------------------------*/
                          ENDP

                  |L6.20|
                          DCD      ||.data||

                          AREA ||i.vPortExitCritical||, CODE, READONLY, ALIGN=2

                  vPortExitCritical PROC
;;;207    
;;;208    void vPortExitCritical( void )
000000  4905              LDR      r1,|L7.24|
;;;209    {
;;;210    	configASSERT( uxCriticalNesting );
000002  6808              LDR      r0,[r1,#0]  ; uxCriticalNesting
000004  2800              CMP      r0,#0
000006  d004              BEQ      |L7.18|
000008  1e40              SUBS     r0,r0,#1              ;209
;;;211        uxCriticalNesting--;
;;;212        if( uxCriticalNesting == 0 )
00000a  6008              STR      r0,[r1,#0]  ; uxCriticalNesting
00000c  d100              BNE      |L7.16|
;;;213        {
;;;214            portENABLE_INTERRUPTS();
00000e  b662              CPSIE    i
                  |L7.16|
;;;215        }
;;;216    }
000010  4770              BX       lr
                  |L7.18|
000012  b672              CPSID    i                     ;210
                  |L7.20|
000014  e7fe              B        |L7.20|
;;;217    /*-----------------------------------------------------------*/
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      ||.data||

                          AREA ||i.vPortYield||, CODE, READONLY, ALIGN=2

                  vPortYield PROC
;;;186    
;;;187    void vPortYield( void )
000000  2001              MOVS     r0,#1
;;;188    {
;;;189    	/* Set a PendSV to request a context switch. */
;;;190    	*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
000002  4904              LDR      r1,|L8.20|
000004  0700              LSLS     r0,r0,#28
000006  6048              STR      r0,[r1,#4]
;;;191    
;;;192    	/* Barriers are normally not required but do ensure the code is completely
;;;193    	within the specified behaviour for the architecture. */
;;;194    	__dsb( portSY_FULL_READ_WRITE );
000008  f3bf8f4f          DSB      
;;;195    	__isb( portSY_FULL_READ_WRITE );
00000c  f3bf8f6f          ISB      
;;;196    }
000010  4770              BX       lr
;;;197    /*-----------------------------------------------------------*/
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0xe000ed00

                          AREA ||i.xPortStartScheduler||, CODE, READONLY, ALIGN=2

                  xPortStartScheduler PROC
;;;157     */
;;;158    BaseType_t xPortStartScheduler( void )
000000  b570              PUSH     {r4-r6,lr}
;;;159    {
;;;160    	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
;;;161    	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
000002  480f              LDR      r0,|L9.64|
000004  6a01              LDR      r1,[r0,#0x20]
000006  22ff              MOVS     r2,#0xff
000008  0412              LSLS     r2,r2,#16
00000a  4311              ORRS     r1,r1,r2
00000c  6201              STR      r1,[r0,#0x20]
;;;162    	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
00000e  6a01              LDR      r1,[r0,#0x20]
000010  0212              LSLS     r2,r2,#8
000012  4311              ORRS     r1,r1,r2
000014  6201              STR      r1,[r0,#0x20]
000016  4c0b              LDR      r4,|L9.68|
000018  2500              MOVS     r5,#0
00001a  6125              STR      r5,[r4,#0x10]
00001c  61a5              STR      r5,[r4,#0x18]
00001e  480a              LDR      r0,|L9.72|
000020  217d              MOVS     r1,#0x7d
000022  00c9              LSLS     r1,r1,#3
000024  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000026  f7fffffe          BL       __aeabi_uidivmod
00002a  1e40              SUBS     r0,r0,#1
00002c  6160              STR      r0,[r4,#0x14]
00002e  2007              MOVS     r0,#7
000030  6120              STR      r0,[r4,#0x10]
;;;163    
;;;164    	/* Start the timer that generates the tick ISR.  Interrupts are disabled
;;;165    	here already. */
;;;166    	prvSetupTimerInterrupt();
;;;167    
;;;168    	/* Initialise the critical nesting count ready for the first task. */
;;;169    	uxCriticalNesting = 0;
000032  4806              LDR      r0,|L9.76|
;;;170    
;;;171    	/* Start the first task. */
;;;172    	prvPortStartFirstTask();
000034  6005              STR      r5,[r0,#0]  ; uxCriticalNesting
000036  f7fffffe          BL       __asm___6_port_c_39a90d8d__prvPortStartFirstTask
;;;173    
;;;174    	/* Should not get here! */
;;;175    	return 0;
00003a  2000              MOVS     r0,#0
;;;176    }
00003c  bd70              POP      {r4-r6,pc}
;;;177    /*-----------------------------------------------------------*/
                          ENDP

00003e  0000              DCW      0x0000
                  |L9.64|
                          DCD      0xe000ed00
                  |L9.68|
                          DCD      0xe000e000
                  |L9.72|
                          DCD      SystemCoreClock
                  |L9.76|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  uxCriticalNesting
                          DCD      0xaaaaaaaa

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\ThirdParty\\FreeRTOS\\Source\\portable\\RVDS\\ARM_CM0\\port.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_port_c_39a90d8d____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_port_c_39a90d8d____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_port_c_39a90d8d____REVSH|
#line 402
|__asm___6_port_c_39a90d8d____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___6_port_c_39a90d8d__prvPortStartFirstTask|
#line 126 "..\\..\\..\\ThirdParty\\FreeRTOS\\Source\\portable\\RVDS\\ARM_CM0\\port.c"
|__asm___6_port_c_39a90d8d__prvPortStartFirstTask| PROC
#line 127

 extern pxCurrentTCB

 PRESERVE8

#line 134
 

 ldr r3, =pxCurrentTCB  
 ldr r1, [r3]
 ldr r0, [r1]  
 adds r0, #32  
 msr psp, r0  
 movs r0, #2  
 msr CONTROL, r0
 isb
 pop {r0-r5}  
 mov lr, r5  
 pop {r3}  
 pop {r2}  
 cpsie i  
 bx r3  

 ALIGN
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |ulSetInterruptMaskFromISR|
#line 219
|ulSetInterruptMaskFromISR| PROC
#line 220

 mrs r0, PRIMASK
 cpsid i
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |vClearInterruptMaskFromISR|
#line 227
|vClearInterruptMaskFromISR| PROC
#line 228

 msr PRIMASK, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |PendSV_Handler|
#line 234
|PendSV_Handler| PROC
#line 235

 extern vTaskSwitchContext
 extern pxCurrentTCB

 PRESERVE8

 mrs r0, psp

 ldr r3, =pxCurrentTCB  
 ldr r2, [r3]

 subs r0, #32  
 str r0, [r2]  
 stmia r0!, {r4-r7}  
 mov r4, r8  
 mov r5, r9
 mov r6, r10
 mov r7, r11
 stmia r0!, {r4-r7}

 push {r3, r14}
 cpsid i
 bl vTaskSwitchContext
 cpsie i
 pop {r2, r3}  

 ldr r1, [r2]
 ldr r0, [r1]  
 adds r0, #16  
 ldmia r0!, {r4-r7}  
 mov r8, r4
 mov r9, r5
 mov r10, r6
 mov r11, r7

 msr psp, r0  

 subs r0, #32  
 ldmia r0!, {r4-r7}  

 bx r3
 ALIGN
	ENDP

;*** End   embedded assembler ***
