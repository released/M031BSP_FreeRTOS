; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\queue.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\queue.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -I..\..\..\ThirdParty\FreeRTOS\Source\include -I..\..\..\ThirdParty\FreeRTOS\Demo\Common\include -I..\..\..\ThirdParty\FreeRTOS\Source\portable\RVDS\ARM_CM0 -I..\..\..\ThirdParty\FreeRTOS -I..\..\Template -I..\CPU -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\queue.crf ..\..\..\ThirdParty\FreeRTOS\Source\queue.c]
                          THUMB

                          AREA ||i.pcQueueGetName||, CODE, READONLY, ALIGN=2

                  pcQueueGetName PROC
;;;2672   
;;;2673   	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  b510              PUSH     {r4,lr}
;;;2674   	{
;;;2675   	UBaseType_t ux;
;;;2676   	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000002  2300              MOVS     r3,#0
;;;2677   
;;;2678   		/* Note there is nothing here to protect against another task adding or
;;;2679   		removing entries from the registry while it is being searched. */
;;;2680   		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
;;;2681   		{
;;;2682   			if( xQueueRegistry[ ux ].xHandle == xQueue )
000004  4a07              LDR      r2,|L1.36|
000006  4619              MOV      r1,r3                 ;2680
                  |L1.8|
000008  00cc              LSLS     r4,r1,#3
00000a  18a4              ADDS     r4,r4,r2
00000c  6864              LDR      r4,[r4,#4]
00000e  4284              CMP      r4,r0
000010  d102              BNE      |L1.24|
;;;2683   			{
;;;2684   				pcReturn = xQueueRegistry[ ux ].pcQueueName;
000012  00c8              LSLS     r0,r1,#3
000014  5813              LDR      r3,[r2,r0]
;;;2685   				break;
000016  e002              B        |L1.30|
                  |L1.24|
000018  1c49              ADDS     r1,r1,#1
00001a  2908              CMP      r1,#8                 ;2680
00001c  d3f4              BCC      |L1.8|
                  |L1.30|
;;;2686   			}
;;;2687   			else
;;;2688   			{
;;;2689   				mtCOVERAGE_TEST_MARKER();
;;;2690   			}
;;;2691   		}
;;;2692   
;;;2693   		return pcReturn;
00001e  4618              MOV      r0,r3
;;;2694   	} /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
000020  bd10              POP      {r4,pc}
;;;2695   
                          ENDP

000022  0000              DCW      0x0000
                  |L1.36|
                          DCD      ||.bss||

                          AREA ||i.prvCopyDataFromQueue||, CODE, READONLY, ALIGN=1

                  prvCopyDataFromQueue PROC
;;;2148   
;;;2149   static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
000000  b510              PUSH     {r4,lr}
;;;2150   {
;;;2151   	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
000002  6c02              LDR      r2,[r0,#0x40]
000004  460c              MOV      r4,r1                 ;2150
000006  2a00              CMP      r2,#0
000008  d00c              BEQ      |L2.36|
;;;2152   	{
;;;2153   		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
00000a  68c1              LDR      r1,[r0,#0xc]
00000c  188b              ADDS     r3,r1,r2
;;;2154   		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
00000e  60c3              STR      r3,[r0,#0xc]
000010  6881              LDR      r1,[r0,#8]
000012  428b              CMP      r3,r1
000014  d201              BCS      |L2.26|
;;;2155   		{
;;;2156   			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
;;;2157   		}
;;;2158   		else
;;;2159   		{
;;;2160   			mtCOVERAGE_TEST_MARKER();
;;;2161   		}
;;;2162   		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
000016  4619              MOV      r1,r3
000018  e001              B        |L2.30|
                  |L2.26|
00001a  6801              LDR      r1,[r0,#0]            ;2156
00001c  60c1              STR      r1,[r0,#0xc]          ;2156
                  |L2.30|
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       __aeabi_memcpy
                  |L2.36|
;;;2163   	}
;;;2164   }
000024  bd10              POP      {r4,pc}
;;;2165   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvCopyDataToQueue||, CODE, READONLY, ALIGN=1

                  prvCopyDataToQueue PROC
;;;2069   
;;;2070   static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
000000  b5f8              PUSH     {r3-r7,lr}
;;;2071   {
;;;2072   BaseType_t xReturn = pdFALSE;
;;;2073   UBaseType_t uxMessagesWaiting;
;;;2074   
;;;2075   	/* This function is called from a critical section. */
;;;2076   
;;;2077   	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
000002  6b85              LDR      r5,[r0,#0x38]
000004  4617              MOV      r7,r2                 ;2071
000006  4604              MOV      r4,r0                 ;2071
000008  2600              MOVS     r6,#0                 ;2072
;;;2078   
;;;2079   	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
00000a  6c02              LDR      r2,[r0,#0x40]
00000c  2a00              CMP      r2,#0
00000e  d011              BEQ      |L3.52|
;;;2080   	{
;;;2081   		#if ( configUSE_MUTEXES == 1 )
;;;2082   		{
;;;2083   			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;2084   			{
;;;2085   				/* The mutex is no longer being held. */
;;;2086   				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
;;;2087   				pxQueue->u.xSemaphore.xMutexHolder = NULL;
;;;2088   			}
;;;2089   			else
;;;2090   			{
;;;2091   				mtCOVERAGE_TEST_MARKER();
;;;2092   			}
;;;2093   		}
;;;2094   		#endif /* configUSE_MUTEXES */
;;;2095   	}
;;;2096   	else if( xPosition == queueSEND_TO_BACK )
000010  2f00              CMP      r7,#0
000012  d019              BEQ      |L3.72|
;;;2097   	{
;;;2098   		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
;;;2099   		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
;;;2100   		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
;;;2101   		{
;;;2102   			pxQueue->pcWriteTo = pxQueue->pcHead;
;;;2103   		}
;;;2104   		else
;;;2105   		{
;;;2106   			mtCOVERAGE_TEST_MARKER();
;;;2107   		}
;;;2108   	}
;;;2109   	else
;;;2110   	{
;;;2111   		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
000014  68e0              LDR      r0,[r4,#0xc]
000016  f7fffffe          BL       __aeabi_memcpy
;;;2112   		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
00001a  68e1              LDR      r1,[r4,#0xc]
00001c  6c20              LDR      r0,[r4,#0x40]
00001e  1a09              SUBS     r1,r1,r0
;;;2113   		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
000020  60e1              STR      r1,[r4,#0xc]
000022  6822              LDR      r2,[r4,#0]
000024  4291              CMP      r1,r2
000026  d202              BCS      |L3.46|
;;;2114   		{
;;;2115   			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
000028  68a1              LDR      r1,[r4,#8]
00002a  1a08              SUBS     r0,r1,r0
00002c  60e0              STR      r0,[r4,#0xc]
                  |L3.46|
;;;2116   		}
;;;2117   		else
;;;2118   		{
;;;2119   			mtCOVERAGE_TEST_MARKER();
;;;2120   		}
;;;2121   
;;;2122   		if( xPosition == queueOVERWRITE )
00002e  2f02              CMP      r7,#2
000030  d017              BEQ      |L3.98|
000032  e019              B        |L3.104|
                  |L3.52|
000034  6820              LDR      r0,[r4,#0]            ;2083
000036  2800              CMP      r0,#0                 ;2083
000038  d116              BNE      |L3.104|
00003a  68a0              LDR      r0,[r4,#8]            ;2086
00003c  f7fffffe          BL       xTaskPriorityDisinherit
000040  4606              MOV      r6,r0                 ;2086
000042  2000              MOVS     r0,#0                 ;2087
000044  60a0              STR      r0,[r4,#8]            ;2087
000046  e00f              B        |L3.104|
                  |L3.72|
000048  6860              LDR      r0,[r4,#4]            ;2098
00004a  f7fffffe          BL       __aeabi_memcpy
00004e  6c21              LDR      r1,[r4,#0x40]         ;2099
000050  6860              LDR      r0,[r4,#4]            ;2099
000052  1840              ADDS     r0,r0,r1              ;2099
000054  6060              STR      r0,[r4,#4]            ;2100
000056  68a1              LDR      r1,[r4,#8]            ;2100
000058  4288              CMP      r0,r1                 ;2100
00005a  d305              BCC      |L3.104|
00005c  6820              LDR      r0,[r4,#0]            ;2102
00005e  6060              STR      r0,[r4,#4]            ;2102
000060  e002              B        |L3.104|
                  |L3.98|
;;;2123   		{
;;;2124   			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
000062  2d00              CMP      r5,#0
000064  d000              BEQ      |L3.104|
000066  1e6d              SUBS     r5,r5,#1
                  |L3.104|
000068  1c6d              ADDS     r5,r5,#1
;;;2125   			{
;;;2126   				/* An item is not being added but overwritten, so subtract
;;;2127   				one from the recorded number of items in the queue so when
;;;2128   				one is added again below the number of recorded items remains
;;;2129   				correct. */
;;;2130   				--uxMessagesWaiting;
;;;2131   			}
;;;2132   			else
;;;2133   			{
;;;2134   				mtCOVERAGE_TEST_MARKER();
;;;2135   			}
;;;2136   		}
;;;2137   		else
;;;2138   		{
;;;2139   			mtCOVERAGE_TEST_MARKER();
;;;2140   		}
;;;2141   	}
;;;2142   
;;;2143   	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
00006a  63a5              STR      r5,[r4,#0x38]
;;;2144   
;;;2145   	return xReturn;
00006c  4630              MOV      r0,r6
;;;2146   }
00006e  bdf8              POP      {r3-r7,pc}
;;;2147   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvIsQueueEmpty||, CODE, READONLY, ALIGN=1

                  prvIsQueueEmpty PROC
;;;2286   
;;;2287   static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
000000  b510              PUSH     {r4,lr}
;;;2288   {
000002  4604              MOV      r4,r0
;;;2289   BaseType_t xReturn;
;;;2290   
;;;2291   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;2292   	{
;;;2293   		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
000008  6ba0              LDR      r0,[r4,#0x38]
00000a  2800              CMP      r0,#0
00000c  d004              BEQ      |L4.24|
;;;2294   		{
;;;2295   			xReturn = pdTRUE;
;;;2296   		}
;;;2297   		else
;;;2298   		{
;;;2299   			xReturn = pdFALSE;
00000e  2400              MOVS     r4,#0
                  |L4.16|
;;;2300   		}
;;;2301   	}
;;;2302   	taskEXIT_CRITICAL();
000010  f7fffffe          BL       vPortExitCritical
;;;2303   
;;;2304   	return xReturn;
000014  4620              MOV      r0,r4
;;;2305   }
000016  bd10              POP      {r4,pc}
                  |L4.24|
000018  2401              MOVS     r4,#1                 ;2295
00001a  e7f9              B        |L4.16|
;;;2306   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvUnlockQueue||, CODE, READONLY, ALIGN=1

                  prvUnlockQueue PROC
;;;2166   
;;;2167   static void prvUnlockQueue( Queue_t * const pxQueue )
000000  b5f8              PUSH     {r3-r7,lr}
;;;2168   {
000002  4604              MOV      r4,r0
;;;2169   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
;;;2170   
;;;2171   	/* The lock counts contains the number of extra data items placed or
;;;2172   	removed from the queue while the queue was locked.  When a queue is
;;;2173   	locked items can be added or removed, but the event lists cannot be
;;;2174   	updated. */
;;;2175   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;2176   	{
;;;2177   		int8_t cTxLock = pxQueue->cTxLock;
000008  4626              MOV      r6,r4
00000a  3640              ADDS     r6,r6,#0x40
00000c  2505              MOVS     r5,#5
00000e  5775              LDRSB    r5,[r6,r5]
;;;2178   
;;;2179   		/* See if data was added to the queue while it was locked. */
;;;2180   		while( cTxLock > queueLOCKED_UNMODIFIED )
;;;2181   		{
;;;2182   			/* Data was posted while the queue was locked.  Are any tasks
;;;2183   			blocked waiting for data to become available? */
;;;2184   			#if ( configUSE_QUEUE_SETS == 1 )
;;;2185   			{
;;;2186   				if( pxQueue->pxQueueSetContainer != NULL )
;;;2187   				{
;;;2188   					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
;;;2189   					{
;;;2190   						/* The queue is a member of a queue set, and posting to
;;;2191   						the queue set caused a higher priority task to unblock.
;;;2192   						A context switch is required. */
;;;2193   						vTaskMissedYield();
;;;2194   					}
;;;2195   					else
;;;2196   					{
;;;2197   						mtCOVERAGE_TEST_MARKER();
;;;2198   					}
;;;2199   				}
;;;2200   				else
;;;2201   				{
;;;2202   					/* Tasks that are removed from the event list will get
;;;2203   					added to the pending ready list as the scheduler is still
;;;2204   					suspended. */
;;;2205   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;2206   					{
;;;2207   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;2208   						{
;;;2209   							/* The task waiting has a higher priority so record that a
;;;2210   							context	switch is required. */
;;;2211   							vTaskMissedYield();
;;;2212   						}
;;;2213   						else
;;;2214   						{
;;;2215   							mtCOVERAGE_TEST_MARKER();
;;;2216   						}
;;;2217   					}
;;;2218   					else
;;;2219   					{
;;;2220   						break;
;;;2221   					}
;;;2222   				}
;;;2223   			}
;;;2224   			#else /* configUSE_QUEUE_SETS */
;;;2225   			{
;;;2226   				/* Tasks that are removed from the event list will get added to
;;;2227   				the pending ready list as the scheduler is still suspended. */
;;;2228   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;2229   				{
;;;2230   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000010  4627              MOV      r7,r4
000012  3724              ADDS     r7,r7,#0x24
000014  e00b              B        |L5.46|
                  |L5.22|
000016  6a60              LDR      r0,[r4,#0x24]         ;2228
000018  2800              CMP      r0,#0                 ;2228
00001a  d00a              BEQ      |L5.50|
00001c  4638              MOV      r0,r7                 ;2228
00001e  f7fffffe          BL       xTaskRemoveFromEventList
000022  2800              CMP      r0,#0
000024  d001              BEQ      |L5.42|
;;;2231   					{
;;;2232   						/* The task waiting has a higher priority so record that
;;;2233   						a context switch is required. */
;;;2234   						vTaskMissedYield();
000026  f7fffffe          BL       vTaskMissedYield
                  |L5.42|
00002a  1e6d              SUBS     r5,r5,#1
;;;2235   					}
;;;2236   					else
;;;2237   					{
;;;2238   						mtCOVERAGE_TEST_MARKER();
;;;2239   					}
;;;2240   				}
;;;2241   				else
;;;2242   				{
;;;2243   					break;
;;;2244   				}
;;;2245   			}
;;;2246   			#endif /* configUSE_QUEUE_SETS */
;;;2247   
;;;2248   			--cTxLock;
00002c  b26d              SXTB     r5,r5
                  |L5.46|
00002e  2d00              CMP      r5,#0                 ;2180
000030  dcf1              BGT      |L5.22|
                  |L5.50|
;;;2249   		}
;;;2250   
;;;2251   		pxQueue->cTxLock = queueUNLOCKED;
000032  2700              MOVS     r7,#0
000034  43ff              MVNS     r7,r7
000036  7177              STRB     r7,[r6,#5]
;;;2252   	}
;;;2253   	taskEXIT_CRITICAL();
000038  f7fffffe          BL       vPortExitCritical
;;;2254   
;;;2255   	/* Do the same for the Rx lock. */
;;;2256   	taskENTER_CRITICAL();
00003c  f7fffffe          BL       vPortEnterCritical
;;;2257   	{
;;;2258   		int8_t cRxLock = pxQueue->cRxLock;
000040  2504              MOVS     r5,#4
000042  5775              LDRSB    r5,[r6,r5]
;;;2259   
;;;2260   		while( cRxLock > queueLOCKED_UNMODIFIED )
;;;2261   		{
;;;2262   			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;2263   			{
;;;2264   				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000044  4620              MOV      r0,r4
000046  3010              ADDS     r0,r0,#0x10
000048  9000              STR      r0,[sp,#0]            ;2260
00004a  e00b              B        |L5.100|
                  |L5.76|
00004c  6920              LDR      r0,[r4,#0x10]         ;2262
00004e  2800              CMP      r0,#0                 ;2262
000050  d00a              BEQ      |L5.104|
000052  9800              LDR      r0,[sp,#0]
000054  f7fffffe          BL       xTaskRemoveFromEventList
000058  2800              CMP      r0,#0
00005a  d001              BEQ      |L5.96|
;;;2265   				{
;;;2266   					vTaskMissedYield();
00005c  f7fffffe          BL       vTaskMissedYield
                  |L5.96|
000060  1e6d              SUBS     r5,r5,#1
;;;2267   				}
;;;2268   				else
;;;2269   				{
;;;2270   					mtCOVERAGE_TEST_MARKER();
;;;2271   				}
;;;2272   
;;;2273   				--cRxLock;
000062  b26d              SXTB     r5,r5
                  |L5.100|
000064  2d00              CMP      r5,#0                 ;2260
000066  dcf1              BGT      |L5.76|
                  |L5.104|
;;;2274   			}
;;;2275   			else
;;;2276   			{
;;;2277   				break;
;;;2278   			}
;;;2279   		}
;;;2280   
;;;2281   		pxQueue->cRxLock = queueUNLOCKED;
000068  7137              STRB     r7,[r6,#4]
;;;2282   	}
;;;2283   	taskEXIT_CRITICAL();
00006a  f7fffffe          BL       vPortExitCritical
;;;2284   }
00006e  bdf8              POP      {r3-r7,pc}
;;;2285   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.ucQueueGetQueueType||, CODE, READONLY, ALIGN=1

                  ucQueueGetQueueType PROC
;;;2034   
;;;2035   	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
000000  3040              ADDS     r0,r0,#0x40
;;;2036   	{
;;;2037   		return ( ( Queue_t * ) xQueue )->ucQueueType;
000002  7b00              LDRB     r0,[r0,#0xc]
;;;2038   	}
000004  4770              BX       lr
;;;2039   
                          ENDP


                          AREA ||i.uxQueueGetQueueNumber||, CODE, READONLY, ALIGN=1

                  uxQueueGetQueueNumber PROC
;;;2014   
;;;2015   	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
000000  6c80              LDR      r0,[r0,#0x48]
;;;2016   	{
;;;2017   		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
;;;2018   	}
000002  4770              BX       lr
;;;2019   
                          ENDP


                          AREA ||i.uxQueueMessagesWaiting||, CODE, READONLY, ALIGN=1

                  uxQueueMessagesWaiting PROC
;;;1925   
;;;1926   UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
000000  b510              PUSH     {r4,lr}
;;;1927   {
000002  0004              MOVS     r4,r0
000004  d006              BEQ      |L8.20|
;;;1928   UBaseType_t uxReturn;
;;;1929   
;;;1930   	configASSERT( xQueue );
;;;1931   
;;;1932   	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;1933   	{
;;;1934   		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
00000a  6ba4              LDR      r4,[r4,#0x38]
;;;1935   	}
;;;1936   	taskEXIT_CRITICAL();
00000c  f7fffffe          BL       vPortExitCritical
;;;1937   
;;;1938   	return uxReturn;
000010  4620              MOV      r0,r4
;;;1939   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000012  bd10              POP      {r4,pc}
                  |L8.20|
000014  b672              CPSID    i                     ;1930
                  |L8.22|
000016  e7fe              B        |L8.22|
;;;1940   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxQueueMessagesWaitingFromISR||, CODE, READONLY, ALIGN=1

                  uxQueueMessagesWaitingFromISR PROC
;;;1958   
;;;1959   UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
000000  2800              CMP      r0,#0
;;;1960   {
000002  d001              BEQ      |L9.8|
;;;1961   UBaseType_t uxReturn;
;;;1962   Queue_t * const pxQueue = xQueue;
;;;1963   
;;;1964   	configASSERT( pxQueue );
;;;1965   	uxReturn = pxQueue->uxMessagesWaiting;
000004  6b80              LDR      r0,[r0,#0x38]
;;;1966   
;;;1967   	return uxReturn;
;;;1968   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000006  4770              BX       lr
                  |L9.8|
000008  b672              CPSID    i                     ;1964
                  |L9.10|
00000a  e7fe              B        |L9.10|
;;;1969   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxQueueSpacesAvailable||, CODE, READONLY, ALIGN=1

                  uxQueueSpacesAvailable PROC
;;;1941   
;;;1942   UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
000000  b510              PUSH     {r4,lr}
;;;1943   {
000002  0004              MOVS     r4,r0
000004  d008              BEQ      |L10.24|
;;;1944   UBaseType_t uxReturn;
;;;1945   Queue_t * const pxQueue = xQueue;
;;;1946   
;;;1947   	configASSERT( pxQueue );
;;;1948   
;;;1949   	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;1950   	{
;;;1951   		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
00000a  6ba1              LDR      r1,[r4,#0x38]
00000c  6be0              LDR      r0,[r4,#0x3c]
00000e  1a44              SUBS     r4,r0,r1
;;;1952   	}
;;;1953   	taskEXIT_CRITICAL();
000010  f7fffffe          BL       vPortExitCritical
;;;1954   
;;;1955   	return uxReturn;
000014  4620              MOV      r0,r4
;;;1956   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000016  bd10              POP      {r4,pc}
                  |L10.24|
000018  b672              CPSID    i                     ;1947
                  |L10.26|
00001a  e7fe              B        |L10.26|
;;;1957   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vQueueAddToRegistry||, CODE, READONLY, ALIGN=2

                  vQueueAddToRegistry PROC
;;;2643   
;;;2644   	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  b510              PUSH     {r4,lr}
;;;2645   	{
;;;2646   	UBaseType_t ux;
;;;2647   
;;;2648   		/* See if there is an empty space in the registry.  A NULL name denotes
;;;2649   		a free slot. */
;;;2650   		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
;;;2651   		{
;;;2652   			if( xQueueRegistry[ ux ].pcQueueName == NULL )
000002  4b07              LDR      r3,|L11.32|
000004  2200              MOVS     r2,#0                 ;2650
                  |L11.6|
000006  00d4              LSLS     r4,r2,#3
000008  591c              LDR      r4,[r3,r4]
00000a  2c00              CMP      r4,#0
00000c  d003              BEQ      |L11.22|
00000e  1c52              ADDS     r2,r2,#1
000010  2a08              CMP      r2,#8                 ;2650
000012  d3f8              BCC      |L11.6|
;;;2653   			{
;;;2654   				/* Store the information on this queue. */
;;;2655   				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
;;;2656   				xQueueRegistry[ ux ].xHandle = xQueue;
;;;2657   
;;;2658   				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
;;;2659   				break;
;;;2660   			}
;;;2661   			else
;;;2662   			{
;;;2663   				mtCOVERAGE_TEST_MARKER();
;;;2664   			}
;;;2665   		}
;;;2666   	}
000014  bd10              POP      {r4,pc}
                  |L11.22|
000016  00d2              LSLS     r2,r2,#3              ;2655
000018  5099              STR      r1,[r3,r2]            ;2655
00001a  18d1              ADDS     r1,r2,r3              ;2656
00001c  6048              STR      r0,[r1,#4]            ;2656
00001e  bd10              POP      {r4,pc}
;;;2667   
                          ENDP

                  |L11.32|
                          DCD      ||.bss||

                          AREA ||i.vQueueDelete||, CODE, READONLY, ALIGN=1

                  vQueueDelete PROC
;;;1970   
;;;1971   void vQueueDelete( QueueHandle_t xQueue )
000000  b510              PUSH     {r4,lr}
;;;1972   {
000002  0004              MOVS     r4,r0
000004  d005              BEQ      |L12.18|
;;;1973   Queue_t * const pxQueue = xQueue;
;;;1974   
;;;1975   	configASSERT( pxQueue );
;;;1976   	traceQUEUE_DELETE( pxQueue );
;;;1977   
;;;1978   	#if ( configQUEUE_REGISTRY_SIZE > 0 )
;;;1979   	{
;;;1980   		vQueueUnregisterQueue( pxQueue );
000006  f7fffffe          BL       vQueueUnregisterQueue
;;;1981   	}
;;;1982   	#endif
;;;1983   
;;;1984   	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
;;;1985   	{
;;;1986   		/* The queue can only have been allocated dynamically - free it
;;;1987   		again. */
;;;1988   		vPortFree( pxQueue );
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       vPortFree
;;;1989   	}
;;;1990   	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
;;;1991   	{
;;;1992   		/* The queue could have been allocated statically or dynamically, so
;;;1993   		check before attempting to free the memory. */
;;;1994   		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
;;;1995   		{
;;;1996   			vPortFree( pxQueue );
;;;1997   		}
;;;1998   		else
;;;1999   		{
;;;2000   			mtCOVERAGE_TEST_MARKER();
;;;2001   		}
;;;2002   	}
;;;2003   	#else
;;;2004   	{
;;;2005   		/* The queue must have been statically allocated, so is not going to be
;;;2006   		deleted.  Avoid compiler warnings about the unused parameter. */
;;;2007   		( void ) pxQueue;
;;;2008   	}
;;;2009   	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;2010   }
000010  bd10              POP      {r4,pc}
                  |L12.18|
000012  b672              CPSID    i                     ;1975
                  |L12.20|
000014  e7fe              B        |L12.20|
;;;2011   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vQueueSetQueueNumber||, CODE, READONLY, ALIGN=1

                  vQueueSetQueueNumber PROC
;;;2024   
;;;2025   	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
000000  6481              STR      r1,[r0,#0x48]
;;;2026   	{
;;;2027   		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
;;;2028   	}
000002  4770              BX       lr
;;;2029   
                          ENDP


                          AREA ||i.vQueueUnregisterQueue||, CODE, READONLY, ALIGN=2

                  vQueueUnregisterQueue PROC
;;;2700   
;;;2701   	void vQueueUnregisterQueue( QueueHandle_t xQueue )
000000  4a08              LDR      r2,|L14.36|
;;;2702   	{
;;;2703   	UBaseType_t ux;
;;;2704   
;;;2705   		/* See if the handle of the queue being unregistered in actually in the
;;;2706   		registry. */
;;;2707   		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
000002  2100              MOVS     r1,#0
                  |L14.4|
;;;2708   		{
;;;2709   			if( xQueueRegistry[ ux ].xHandle == xQueue )
000004  00cb              LSLS     r3,r1,#3
000006  189b              ADDS     r3,r3,r2
000008  685b              LDR      r3,[r3,#4]
00000a  4283              CMP      r3,r0
00000c  d105              BNE      |L14.26|
;;;2710   			{
;;;2711   				/* Set the name to NULL to show that this slot if free again. */
;;;2712   				xQueueRegistry[ ux ].pcQueueName = NULL;
00000e  2300              MOVS     r3,#0
000010  00c8              LSLS     r0,r1,#3
000012  5013              STR      r3,[r2,r0]
;;;2713   
;;;2714   				/* Set the handle to NULL to ensure the same queue handle cannot
;;;2715   				appear in the registry twice if it is added, removed, then
;;;2716   				added again. */
;;;2717   				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
000014  1880              ADDS     r0,r0,r2
;;;2718   				break;
000016  6043              STR      r3,[r0,#4]
;;;2719   			}
;;;2720   			else
;;;2721   			{
;;;2722   				mtCOVERAGE_TEST_MARKER();
;;;2723   			}
;;;2724   		}
;;;2725   
;;;2726   	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
000018  4770              BX       lr
                  |L14.26|
00001a  1c49              ADDS     r1,r1,#1
00001c  2908              CMP      r1,#8                 ;2707
00001e  d3f1              BCC      |L14.4|
000020  4770              BX       lr
;;;2727   
                          ENDP

000022  0000              DCW      0x0000
                  |L14.36|
                          DCD      ||.bss||

                          AREA ||i.vQueueWaitForMessageRestricted||, CODE, READONLY, ALIGN=1

                  vQueueWaitForMessageRestricted PROC
;;;2732   
;;;2733   	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
000000  b570              PUSH     {r4-r6,lr}
;;;2734   	{
000002  4615              MOV      r5,r2
000004  460e              MOV      r6,r1
;;;2735   	Queue_t * const pxQueue = xQueue;
000006  4604              MOV      r4,r0
;;;2736   
;;;2737   		/* This function should not be called by application code hence the
;;;2738   		'Restricted' in its name.  It is not part of the public API.  It is
;;;2739   		designed for use by kernel code, and has special calling requirements.
;;;2740   		It can result in vListInsert() being called on a list that can only
;;;2741   		possibly ever have one item in it, so the list will be fast, but even
;;;2742   		so it should be called with the scheduler locked and not from a critical
;;;2743   		section. */
;;;2744   
;;;2745   		/* Only do anything if there are no messages in the queue.  This function
;;;2746   		will not actually cause the task to block, just place it on a blocked
;;;2747   		list.  It will not block until the scheduler is unlocked - at which
;;;2748   		time a yield will be performed.  If an item is added to the queue while
;;;2749   		the queue is locked, and the calling task blocks on the queue, then the
;;;2750   		calling task will be immediately unblocked when the queue is unlocked. */
;;;2751   		prvLockQueue( pxQueue );
000008  f7fffffe          BL       vPortEnterCritical
00000c  4620              MOV      r0,r4
00000e  3040              ADDS     r0,r0,#0x40
000010  2204              MOVS     r2,#4
000012  5682              LDRSB    r2,[r0,r2]
000014  2100              MOVS     r1,#0
000016  1c52              ADDS     r2,r2,#1
000018  d100              BNE      |L15.28|
00001a  7101              STRB     r1,[r0,#4]
                  |L15.28|
00001c  2205              MOVS     r2,#5
00001e  5682              LDRSB    r2,[r0,r2]
000020  1c52              ADDS     r2,r2,#1
000022  d100              BNE      |L15.38|
000024  7141              STRB     r1,[r0,#5]
                  |L15.38|
000026  f7fffffe          BL       vPortExitCritical
;;;2752   		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
00002a  6ba0              LDR      r0,[r4,#0x38]
00002c  2800              CMP      r0,#0
00002e  d105              BNE      |L15.60|
;;;2753   		{
;;;2754   			/* There is nothing in the queue, block for the specified period. */
;;;2755   			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
000030  4620              MOV      r0,r4
000032  462a              MOV      r2,r5
000034  4631              MOV      r1,r6
000036  3024              ADDS     r0,r0,#0x24
000038  f7fffffe          BL       vTaskPlaceOnEventListRestricted
                  |L15.60|
;;;2756   		}
;;;2757   		else
;;;2758   		{
;;;2759   			mtCOVERAGE_TEST_MARKER();
;;;2760   		}
;;;2761   		prvUnlockQueue( pxQueue );
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       prvUnlockQueue
;;;2762   	}
000042  bd70              POP      {r4-r6,pc}
;;;2763   
                          ENDP


                          AREA ||i.xQueueCreateCountingSemaphore||, CODE, READONLY, ALIGN=1

                  xQueueCreateCountingSemaphore PROC
;;;720    
;;;721    	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
000000  b510              PUSH     {r4,lr}
;;;722    	{
000002  460c              MOV      r4,r1
;;;723    	QueueHandle_t xHandle;
;;;724    
;;;725    		configASSERT( uxMaxCount != 0 );
000004  2800              CMP      r0,#0
000006  d003              BEQ      |L16.16|
;;;726    		configASSERT( uxInitialCount <= uxMaxCount );
000008  4284              CMP      r4,r0
00000a  d903              BLS      |L16.20|
00000c  b672              CPSID    i
                  |L16.14|
00000e  e7fe              B        |L16.14|
                  |L16.16|
000010  b672              CPSID    i                     ;725
                  |L16.18|
000012  e7fe              B        |L16.18|
                  |L16.20|
;;;727    
;;;728    		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
000014  2202              MOVS     r2,#2
000016  2100              MOVS     r1,#0
000018  f7fffffe          BL       xQueueGenericCreate
;;;729    
;;;730    		if( xHandle != NULL )
00001c  2800              CMP      r0,#0
00001e  d000              BEQ      |L16.34|
;;;731    		{
;;;732    			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
000020  6384              STR      r4,[r0,#0x38]
                  |L16.34|
;;;733    
;;;734    			traceCREATE_COUNTING_SEMAPHORE();
;;;735    		}
;;;736    		else
;;;737    		{
;;;738    			traceCREATE_COUNTING_SEMAPHORE_FAILED();
;;;739    		}
;;;740    
;;;741    		return xHandle;
;;;742    	}
000022  bd10              POP      {r4,pc}
;;;743    
                          ENDP


                          AREA ||i.xQueueCreateMutex||, CODE, READONLY, ALIGN=1

                  xQueueCreateMutex PROC
;;;502    
;;;503    	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
000000  b510              PUSH     {r4,lr}
;;;504    	{
;;;505    	QueueHandle_t xNewQueue;
;;;506    	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
;;;507    
;;;508    		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
000002  4602              MOV      r2,r0
000004  2100              MOVS     r1,#0
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       xQueueGenericCreate
00000c  1e04              SUBS     r4,r0,#0
00000e  d007              BEQ      |L17.32|
000010  2100              MOVS     r1,#0
000012  6081              STR      r1,[r0,#8]
000014  6001              STR      r1,[r0,#0]
000016  460b              MOV      r3,r1
000018  460a              MOV      r2,r1
00001a  60c1              STR      r1,[r0,#0xc]
00001c  f7fffffe          BL       xQueueGenericSend
                  |L17.32|
;;;509    		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
;;;510    
;;;511    		return xNewQueue;
000020  4620              MOV      r0,r4
;;;512    	}
000022  bd10              POP      {r4,pc}
;;;513    
                          ENDP


                          AREA ||i.xQueueGenericCreate||, CODE, READONLY, ALIGN=1

                  xQueueGenericCreate PROC
;;;367    
;;;368    	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
000000  b5f8              PUSH     {r3-r7,lr}
;;;369    	{
000002  4617              MOV      r7,r2
000004  460e              MOV      r6,r1
000006  0005              MOVS     r5,r0
000008  d016              BEQ      |L18.56|
;;;370    	Queue_t *pxNewQueue;
;;;371    	size_t xQueueSizeInBytes;
;;;372    	uint8_t *pucQueueStorage;
;;;373    
;;;374    		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
;;;375    
;;;376    		if( uxItemSize == ( UBaseType_t ) 0 )
00000a  2e00              CMP      r6,#0
00000c  d016              BEQ      |L18.60|
;;;377    		{
;;;378    			/* There is not going to be a queue storage area. */
;;;379    			xQueueSizeInBytes = ( size_t ) 0;
;;;380    		}
;;;381    		else
;;;382    		{
;;;383    			/* Allocate enough space to hold the maximum number of items that
;;;384    			can be in the queue at any time. */
;;;385    			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00000e  4370              MULS     r0,r6,r0
                  |L18.16|
000010  3050              ADDS     r0,r0,#0x50
;;;386    		}
;;;387    
;;;388    		/* Allocate the queue and storage area.  Justification for MISRA
;;;389    		deviation as follows:  pvPortMalloc() always ensures returned memory
;;;390    		blocks are aligned per the requirements of the MCU stack.  In this case
;;;391    		pvPortMalloc() must return a pointer that is guaranteed to meet the
;;;392    		alignment requirements of the Queue_t structure - which in this case
;;;393    		is an int8_t *.  Therefore, whenever the stack alignment requirements
;;;394    		are greater than or equal to the pointer to char requirements the cast
;;;395    		is safe.  In other cases alignment requirements are not strict (one or
;;;396    		two bytes). */
;;;397    		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
000012  f7fffffe          BL       pvPortMalloc
000016  0004              MOVS     r4,r0
;;;398    
;;;399    		if( pxNewQueue != NULL )
000018  d00c              BEQ      |L18.52|
;;;400    		{
;;;401    			/* Jump past the queue structure to find the location of the queue
;;;402    			storage area. */
;;;403    			pucQueueStorage = ( uint8_t * ) pxNewQueue;
;;;404    			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
00001a  4620              MOV      r0,r4
00001c  3050              ADDS     r0,r0,#0x50
00001e  2e00              CMP      r6,#0
000020  d00e              BEQ      |L18.64|
000022  6020              STR      r0,[r4,#0]
                  |L18.36|
000024  6426              STR      r6,[r4,#0x40]
000026  4620              MOV      r0,r4
000028  2101              MOVS     r1,#1
00002a  63e5              STR      r5,[r4,#0x3c]
00002c  f7fffffe          BL       xQueueGenericReset
000030  204c              MOVS     r0,#0x4c
000032  5507              STRB     r7,[r0,r4]
                  |L18.52|
;;;405    
;;;406    			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;407    			{
;;;408    				/* Queues can be created either statically or dynamically, so
;;;409    				note this task was created dynamically in case it is later
;;;410    				deleted. */
;;;411    				pxNewQueue->ucStaticallyAllocated = pdFALSE;
;;;412    			}
;;;413    			#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;414    
;;;415    			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
;;;416    		}
;;;417    		else
;;;418    		{
;;;419    			traceQUEUE_CREATE_FAILED( ucQueueType );
;;;420    			mtCOVERAGE_TEST_MARKER();
;;;421    		}
;;;422    
;;;423    		return pxNewQueue;
000034  4620              MOV      r0,r4
;;;424    	}
000036  bdf8              POP      {r3-r7,pc}
                  |L18.56|
000038  b672              CPSID    i                     ;374
                  |L18.58|
00003a  e7fe              B        |L18.58|
                  |L18.60|
00003c  2000              MOVS     r0,#0                 ;379
00003e  e7e7              B        |L18.16|
                  |L18.64|
000040  6024              STR      r4,[r4,#0]            ;379
000042  e7ef              B        |L18.36|
;;;425    
                          ENDP


                          AREA ||i.xQueueGenericReset||, CODE, READONLY, ALIGN=1

                  xQueueGenericReset PROC
;;;254    
;;;255    BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;256    {
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d026              BEQ      |L19.86|
;;;257    Queue_t * const pxQueue = xQueue;
;;;258    
;;;259    	configASSERT( pxQueue );
;;;260    
;;;261    	taskENTER_CRITICAL();
000008  f7fffffe          BL       vPortEnterCritical
;;;262    	{
;;;263    		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
00000c  6c21              LDR      r1,[r4,#0x40]
00000e  6be0              LDR      r0,[r4,#0x3c]
000010  4348              MULS     r0,r1,r0
000012  6821              LDR      r1,[r4,#0]
000014  1841              ADDS     r1,r0,r1
;;;264    		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
000016  60a1              STR      r1,[r4,#8]
000018  2100              MOVS     r1,#0
00001a  63a1              STR      r1,[r4,#0x38]
;;;265    		pxQueue->pcWriteTo = pxQueue->pcHead;
00001c  6821              LDR      r1,[r4,#0]
;;;266    		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
00001e  6061              STR      r1,[r4,#4]
000020  6be0              LDR      r0,[r4,#0x3c]
000022  6c21              LDR      r1,[r4,#0x40]
000024  1e40              SUBS     r0,r0,#1
000026  4348              MULS     r0,r1,r0
000028  6821              LDR      r1,[r4,#0]
;;;267    		pxQueue->cRxLock = queueUNLOCKED;
00002a  4622              MOV      r2,r4
00002c  1841              ADDS     r1,r0,r1              ;266
00002e  2000              MOVS     r0,#0
000030  43c0              MVNS     r0,r0
000032  3240              ADDS     r2,r2,#0x40
000034  60e1              STR      r1,[r4,#0xc]
000036  7110              STRB     r0,[r2,#4]
;;;268    		pxQueue->cTxLock = queueUNLOCKED;
000038  7150              STRB     r0,[r2,#5]
;;;269    
;;;270    		if( xNewQueue == pdFALSE )
;;;271    		{
;;;272    			/* If there are tasks blocked waiting to read from the queue, then
;;;273    			the tasks will remain blocked as after this function exits the queue
;;;274    			will still be empty.  If there are tasks blocked waiting to write to
;;;275    			the queue, then one should be unblocked as after this function exits
;;;276    			it will be possible to write to it. */
;;;277    			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;278    			{
;;;279    				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
00003a  4620              MOV      r0,r4
00003c  3010              ADDS     r0,r0,#0x10
00003e  2d00              CMP      r5,#0                 ;270
000040  d00b              BEQ      |L19.90|
;;;280    				{
;;;281    					queueYIELD_IF_USING_PREEMPTION();
;;;282    				}
;;;283    				else
;;;284    				{
;;;285    					mtCOVERAGE_TEST_MARKER();
;;;286    				}
;;;287    			}
;;;288    			else
;;;289    			{
;;;290    				mtCOVERAGE_TEST_MARKER();
;;;291    			}
;;;292    		}
;;;293    		else
;;;294    		{
;;;295    			/* Ensure the event queues start in the correct state. */
;;;296    			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
000042  f7fffffe          BL       vListInitialise
;;;297    			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
000046  4620              MOV      r0,r4
000048  3024              ADDS     r0,r0,#0x24
00004a  f7fffffe          BL       vListInitialise
                  |L19.78|
;;;298    		}
;;;299    	}
;;;300    	taskEXIT_CRITICAL();
00004e  f7fffffe          BL       vPortExitCritical
;;;301    
;;;302    	/* A value is returned for calling semantic consistency with previous
;;;303    	versions. */
;;;304    	return pdPASS;
000052  2001              MOVS     r0,#1
;;;305    }
000054  bd70              POP      {r4-r6,pc}
                  |L19.86|
000056  b672              CPSID    i                     ;259
                  |L19.88|
000058  e7fe              B        |L19.88|
                  |L19.90|
00005a  6921              LDR      r1,[r4,#0x10]         ;277
00005c  2900              CMP      r1,#0                 ;277
00005e  d0f6              BEQ      |L19.78|
000060  f7fffffe          BL       xTaskRemoveFromEventList
000064  2800              CMP      r0,#0                 ;279
000066  d0f2              BEQ      |L19.78|
000068  f7fffffe          BL       vPortYield
00006c  e7ef              B        |L19.78|
;;;306    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGenericSend||, CODE, READONLY, ALIGN=1

                  xQueueGenericSend PROC
;;;746    
;;;747    BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
000000  b5ff              PUSH     {r0-r7,lr}
;;;748    {
;;;749    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
000002  2500              MOVS     r5,#0
000004  b083              SUB      sp,sp,#0xc            ;748
000006  461e              MOV      r6,r3                 ;748
000008  4604              MOV      r4,r0                 ;748
;;;750    TimeOut_t xTimeOut;
;;;751    Queue_t * const pxQueue = xQueue;
;;;752    
;;;753    	configASSERT( pxQueue );
00000a  2800              CMP      r0,#0
00000c  d003              BEQ      |L20.22|
;;;754    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
00000e  9804              LDR      r0,[sp,#0x10]
000010  2800              CMP      r0,#0
000012  d002              BEQ      |L20.26|
000014  e006              B        |L20.36|
                  |L20.22|
000016  b672              CPSID    i                     ;753
                  |L20.24|
000018  e7fe              B        |L20.24|
                  |L20.26|
00001a  6c20              LDR      r0,[r4,#0x40]
00001c  2800              CMP      r0,#0
00001e  d001              BEQ      |L20.36|
000020  b672              CPSID    i
                  |L20.34|
000022  e7fe              B        |L20.34|
                  |L20.36|
;;;755    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
000024  2e02              CMP      r6,#2
000026  d104              BNE      |L20.50|
000028  6be0              LDR      r0,[r4,#0x3c]
00002a  2801              CMP      r0,#1
00002c  d001              BEQ      |L20.50|
00002e  b672              CPSID    i
                  |L20.48|
000030  e7fe              B        |L20.48|
                  |L20.50|
;;;756    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;757    	{
;;;758    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
000032  f7fffffe          BL       xTaskGetSchedulerState
000036  2800              CMP      r0,#0
000038  d104              BNE      |L20.68|
00003a  9805              LDR      r0,[sp,#0x14]
00003c  2800              CMP      r0,#0
00003e  d001              BEQ      |L20.68|
000040  b672              CPSID    i
                  |L20.66|
000042  e7fe              B        |L20.66|
                  |L20.68|
;;;759    	}
;;;760    	#endif
;;;761    
;;;762    
;;;763    	/*lint -save -e904 This function relaxes the coding standard somewhat to
;;;764    	allow return statements within the function itself.  This is done in the
;;;765    	interest of execution time efficiency. */
;;;766    	for( ;; )
;;;767    	{
;;;768    		taskENTER_CRITICAL();
000044  f7fffffe          BL       vPortEnterCritical
;;;769    		{
;;;770    			/* Is there room on the queue now?  The running task must be the
;;;771    			highest priority task wanting to access the queue.  If the head item
;;;772    			in the queue is to be overwritten then it does not matter if the
;;;773    			queue is full. */
;;;774    			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
000048  6ba0              LDR      r0,[r4,#0x38]
00004a  6be1              LDR      r1,[r4,#0x3c]
00004c  4288              CMP      r0,r1
00004e  d307              BCC      |L20.96|
000050  2e02              CMP      r6,#2
000052  d005              BEQ      |L20.96|
;;;775    			{
;;;776    				traceQUEUE_SEND( pxQueue );
;;;777    
;;;778    				#if ( configUSE_QUEUE_SETS == 1 )
;;;779    				{
;;;780    				UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
;;;781    
;;;782    					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
;;;783    
;;;784    					if( pxQueue->pxQueueSetContainer != NULL )
;;;785    					{
;;;786    						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
;;;787    						{
;;;788    							/* Do not notify the queue set as an existing item
;;;789    							was overwritten in the queue so the number of items
;;;790    							in the queue has not changed. */
;;;791    							mtCOVERAGE_TEST_MARKER();
;;;792    						}
;;;793    						else if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
;;;794    						{
;;;795    							/* The queue is a member of a queue set, and posting
;;;796    							to the queue set caused a higher priority task to
;;;797    							unblock. A context switch is required. */
;;;798    							queueYIELD_IF_USING_PREEMPTION();
;;;799    						}
;;;800    						else
;;;801    						{
;;;802    							mtCOVERAGE_TEST_MARKER();
;;;803    						}
;;;804    					}
;;;805    					else
;;;806    					{
;;;807    						/* If there was a task waiting for data to arrive on the
;;;808    						queue then unblock it now. */
;;;809    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;810    						{
;;;811    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;812    							{
;;;813    								/* The unblocked task has a priority higher than
;;;814    								our own so yield immediately.  Yes it is ok to
;;;815    								do this from within the critical section - the
;;;816    								kernel takes care of that. */
;;;817    								queueYIELD_IF_USING_PREEMPTION();
;;;818    							}
;;;819    							else
;;;820    							{
;;;821    								mtCOVERAGE_TEST_MARKER();
;;;822    							}
;;;823    						}
;;;824    						else if( xYieldRequired != pdFALSE )
;;;825    						{
;;;826    							/* This path is a special case that will only get
;;;827    							executed if the task was holding multiple mutexes
;;;828    							and the mutexes were given back in an order that is
;;;829    							different to that in which they were taken. */
;;;830    							queueYIELD_IF_USING_PREEMPTION();
;;;831    						}
;;;832    						else
;;;833    						{
;;;834    							mtCOVERAGE_TEST_MARKER();
;;;835    						}
;;;836    					}
;;;837    				}
;;;838    				#else /* configUSE_QUEUE_SETS */
;;;839    				{
;;;840    					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
;;;841    
;;;842    					/* If there was a task waiting for data to arrive on the
;;;843    					queue then unblock it now. */
;;;844    					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;845    					{
;;;846    						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;847    						{
;;;848    							/* The unblocked task has a priority higher than
;;;849    							our own so yield immediately.  Yes it is ok to do
;;;850    							this from within the critical section - the kernel
;;;851    							takes care of that. */
;;;852    							queueYIELD_IF_USING_PREEMPTION();
;;;853    						}
;;;854    						else
;;;855    						{
;;;856    							mtCOVERAGE_TEST_MARKER();
;;;857    						}
;;;858    					}
;;;859    					else if( xYieldRequired != pdFALSE )
;;;860    					{
;;;861    						/* This path is a special case that will only get
;;;862    						executed if the task was holding multiple mutexes and
;;;863    						the mutexes were given back in an order that is
;;;864    						different to that in which they were taken. */
;;;865    						queueYIELD_IF_USING_PREEMPTION();
;;;866    					}
;;;867    					else
;;;868    					{
;;;869    						mtCOVERAGE_TEST_MARKER();
;;;870    					}
;;;871    				}
;;;872    				#endif /* configUSE_QUEUE_SETS */
;;;873    
;;;874    				taskEXIT_CRITICAL();
;;;875    				return pdPASS;
;;;876    			}
;;;877    			else
;;;878    			{
;;;879    				if( xTicksToWait == ( TickType_t ) 0 )
000054  9805              LDR      r0,[sp,#0x14]
000056  2800              CMP      r0,#0
000058  d017              BEQ      |L20.138|
;;;880    				{
;;;881    					/* The queue was full and no block time is specified (or
;;;882    					the block time has expired) so leave now. */
;;;883    					taskEXIT_CRITICAL();
;;;884    
;;;885    					/* Return to the original privilege level before exiting
;;;886    					the function. */
;;;887    					traceQUEUE_SEND_FAILED( pxQueue );
;;;888    					return errQUEUE_FULL;
;;;889    				}
;;;890    				else if( xEntryTimeSet == pdFALSE )
00005a  2d00              CMP      r5,#0
00005c  d018              BEQ      |L20.144|
00005e  e01b              B        |L20.152|
                  |L20.96|
000060  4632              MOV      r2,r6                 ;840
000062  4620              MOV      r0,r4                 ;840
000064  9904              LDR      r1,[sp,#0x10]         ;840
000066  f7fffffe          BL       prvCopyDataToQueue
00006a  6a61              LDR      r1,[r4,#0x24]         ;844
00006c  2900              CMP      r1,#0                 ;844
00006e  d003              BEQ      |L20.120|
000070  4620              MOV      r0,r4                 ;846
000072  3024              ADDS     r0,r0,#0x24           ;846
000074  f7fffffe          BL       xTaskRemoveFromEventList
                  |L20.120|
000078  2800              CMP      r0,#0                 ;859
00007a  d001              BEQ      |L20.128|
00007c  f7fffffe          BL       vPortYield
                  |L20.128|
000080  f7fffffe          BL       vPortExitCritical
000084  2001              MOVS     r0,#1                 ;875
                  |L20.134|
;;;891    				{
;;;892    					/* The queue was full and a block time was specified so
;;;893    					configure the timeout structure. */
;;;894    					vTaskInternalSetTimeOutState( &xTimeOut );
;;;895    					xEntryTimeSet = pdTRUE;
;;;896    				}
;;;897    				else
;;;898    				{
;;;899    					/* Entry time was already set. */
;;;900    					mtCOVERAGE_TEST_MARKER();
;;;901    				}
;;;902    			}
;;;903    		}
;;;904    		taskEXIT_CRITICAL();
;;;905    
;;;906    		/* Interrupts and other tasks can send to and receive from the queue
;;;907    		now the critical section has been exited. */
;;;908    
;;;909    		vTaskSuspendAll();
;;;910    		prvLockQueue( pxQueue );
;;;911    
;;;912    		/* Update the timeout state to see if it has expired yet. */
;;;913    		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;914    		{
;;;915    			if( prvIsQueueFull( pxQueue ) != pdFALSE )
;;;916    			{
;;;917    				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
;;;918    				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
;;;919    
;;;920    				/* Unlocking the queue means queue events can effect the
;;;921    				event list.  It is possible that interrupts occurring now
;;;922    				remove this task from the event list again - but as the
;;;923    				scheduler is suspended the task will go onto the pending
;;;924    				ready last instead of the actual ready list. */
;;;925    				prvUnlockQueue( pxQueue );
;;;926    
;;;927    				/* Resuming the scheduler will move tasks from the pending
;;;928    				ready list into the ready list - so it is feasible that this
;;;929    				task is already in a ready list before it yields - in which
;;;930    				case the yield will not cause a context switch unless there
;;;931    				is also a higher priority task in the pending ready list. */
;;;932    				if( xTaskResumeAll() == pdFALSE )
;;;933    				{
;;;934    					portYIELD_WITHIN_API();
;;;935    				}
;;;936    			}
;;;937    			else
;;;938    			{
;;;939    				/* Try again. */
;;;940    				prvUnlockQueue( pxQueue );
;;;941    				( void ) xTaskResumeAll();
;;;942    			}
;;;943    		}
;;;944    		else
;;;945    		{
;;;946    			/* The timeout has expired. */
;;;947    			prvUnlockQueue( pxQueue );
;;;948    			( void ) xTaskResumeAll();
;;;949    
;;;950    			traceQUEUE_SEND_FAILED( pxQueue );
;;;951    			return errQUEUE_FULL;
;;;952    		}
;;;953    	} /*lint -restore */
;;;954    }
000086  b007              ADD      sp,sp,#0x1c
000088  bdf0              POP      {r4-r7,pc}
                  |L20.138|
00008a  f7fffffe          BL       vPortExitCritical
00008e  e022              B        |L20.214|
                  |L20.144|
000090  4668              MOV      r0,sp                 ;894
000092  f7fffffe          BL       vTaskInternalSetTimeOutState
000096  2501              MOVS     r5,#1                 ;895
                  |L20.152|
000098  f7fffffe          BL       vPortExitCritical
00009c  f7fffffe          BL       vTaskSuspendAll
0000a0  f7fffffe          BL       vPortEnterCritical
0000a4  4620              MOV      r0,r4                 ;910
0000a6  3040              ADDS     r0,r0,#0x40           ;910
0000a8  2104              MOVS     r1,#4                 ;910
0000aa  5641              LDRSB    r1,[r0,r1]            ;910
0000ac  1c49              ADDS     r1,r1,#1              ;910
0000ae  d100              BNE      |L20.178|
0000b0  7101              STRB     r1,[r0,#4]            ;910
                  |L20.178|
0000b2  2105              MOVS     r1,#5                 ;910
0000b4  5641              LDRSB    r1,[r0,r1]            ;910
0000b6  1c49              ADDS     r1,r1,#1              ;910
0000b8  d100              BNE      |L20.188|
0000ba  7141              STRB     r1,[r0,#5]            ;910
                  |L20.188|
0000bc  f7fffffe          BL       vPortExitCritical
0000c0  a905              ADD      r1,sp,#0x14           ;913
0000c2  4668              MOV      r0,sp                 ;913
0000c4  f7fffffe          BL       xTaskCheckForTimeOut
0000c8  2800              CMP      r0,#0                 ;913
0000ca  d006              BEQ      |L20.218|
0000cc  4620              MOV      r0,r4                 ;947
0000ce  f7fffffe          BL       prvUnlockQueue
0000d2  f7fffffe          BL       xTaskResumeAll
                  |L20.214|
0000d6  2000              MOVS     r0,#0                 ;951
0000d8  e7d5              B        |L20.134|
                  |L20.218|
0000da  f7fffffe          BL       vPortEnterCritical
0000de  6ba0              LDR      r0,[r4,#0x38]
0000e0  6be1              LDR      r1,[r4,#0x3c]
0000e2  4288              CMP      r0,r1
0000e4  d101              BNE      |L20.234|
0000e6  2701              MOVS     r7,#1
0000e8  e000              B        |L20.236|
                  |L20.234|
0000ea  2700              MOVS     r7,#0
                  |L20.236|
0000ec  f7fffffe          BL       vPortExitCritical
0000f0  2f00              CMP      r7,#0                 ;915
0000f2  d00e              BEQ      |L20.274|
0000f4  4620              MOV      r0,r4                 ;918
0000f6  3010              ADDS     r0,r0,#0x10           ;918
0000f8  9905              LDR      r1,[sp,#0x14]         ;918
0000fa  f7fffffe          BL       vTaskPlaceOnEventList
0000fe  4620              MOV      r0,r4                 ;925
000100  f7fffffe          BL       prvUnlockQueue
000104  f7fffffe          BL       xTaskResumeAll
000108  2800              CMP      r0,#0                 ;932
00010a  d19b              BNE      |L20.68|
00010c  f7fffffe          BL       vPortYield
000110  e798              B        |L20.68|
                  |L20.274|
000112  4620              MOV      r0,r4                 ;940
000114  f7fffffe          BL       prvUnlockQueue
000118  f7fffffe          BL       xTaskResumeAll
00011c  e792              B        |L20.68|
;;;955    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGenericSendFromISR||, CODE, READONLY, ALIGN=1

                  xQueueGenericSendFromISR PROC
;;;956    
;;;957    BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
000000  b5ff              PUSH     {r0-r7,lr}
;;;958    {
000002  b081              SUB      sp,sp,#4
000004  461e              MOV      r6,r3
000006  0004              MOVS     r4,r0
000008  d003              BEQ      |L21.18|
;;;959    BaseType_t xReturn;
;;;960    UBaseType_t uxSavedInterruptStatus;
;;;961    Queue_t * const pxQueue = xQueue;
;;;962    
;;;963    	configASSERT( pxQueue );
;;;964    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
00000a  9802              LDR      r0,[sp,#8]
00000c  2800              CMP      r0,#0
00000e  d002              BEQ      |L21.22|
000010  e006              B        |L21.32|
                  |L21.18|
000012  b672              CPSID    i                     ;963
                  |L21.20|
000014  e7fe              B        |L21.20|
                  |L21.22|
000016  6c20              LDR      r0,[r4,#0x40]
000018  2800              CMP      r0,#0
00001a  d001              BEQ      |L21.32|
00001c  b672              CPSID    i
                  |L21.30|
00001e  e7fe              B        |L21.30|
                  |L21.32|
;;;965    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
000020  2e02              CMP      r6,#2
000022  d104              BNE      |L21.46|
000024  6be0              LDR      r0,[r4,#0x3c]
000026  2801              CMP      r0,#1
000028  d001              BEQ      |L21.46|
00002a  b672              CPSID    i
                  |L21.44|
00002c  e7fe              B        |L21.44|
                  |L21.46|
;;;966    
;;;967    	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;968    	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;969    	above the maximum system call priority are kept permanently enabled, even
;;;970    	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;971    	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;972    	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;973    	failure if a FreeRTOS API function is called from an interrupt that has been
;;;974    	assigned a priority above the configured maximum system call priority.
;;;975    	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;976    	that have been assigned a priority at or (logically) below the maximum
;;;977    	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;978    	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;979    	More information (albeit Cortex-M specific) is provided on the following
;;;980    	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;981    	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;982    
;;;983    	/* Similar to xQueueGenericSend, except without blocking if there is no room
;;;984    	in the queue.  Also don't directly wake a task that was blocked on a queue
;;;985    	read, instead return a flag to say whether a context switch is required or
;;;986    	not (i.e. has a task with a higher priority than us been woken by this
;;;987    	post). */
;;;988    	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00002e  f7fffffe          BL       ulSetInterruptMaskFromISR
;;;989    	{
;;;990    		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
000032  9000              STR      r0,[sp,#0]
000034  6ba0              LDR      r0,[r4,#0x38]
000036  6be1              LDR      r1,[r4,#0x3c]
000038  4288              CMP      r0,r1
00003a  d308              BCC      |L21.78|
00003c  2e02              CMP      r6,#2
00003e  d006              BEQ      |L21.78|
;;;991    		{
;;;992    			const int8_t cTxLock = pxQueue->cTxLock;
;;;993    
;;;994    			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;995    
;;;996    			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
;;;997    			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
;;;998    			in a task disinheriting a priority and prvCopyDataToQueue() can be
;;;999    			called here even though the disinherit function does not check if
;;;1000   			the scheduler is suspended before accessing the ready lists. */
;;;1001   			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
;;;1002   
;;;1003   			/* The event list is not altered if the queue is locked.  This will
;;;1004   			be done when the queue is unlocked later. */
;;;1005   			if( cTxLock == queueUNLOCKED )
;;;1006   			{
;;;1007   				#if ( configUSE_QUEUE_SETS == 1 )
;;;1008   				{
;;;1009   					if( pxQueue->pxQueueSetContainer != NULL )
;;;1010   					{
;;;1011   						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
;;;1012   						{
;;;1013   							/* The queue is a member of a queue set, and posting
;;;1014   							to the queue set caused a higher priority task to
;;;1015   							unblock.  A context switch is required. */
;;;1016   							if( pxHigherPriorityTaskWoken != NULL )
;;;1017   							{
;;;1018   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1019   							}
;;;1020   							else
;;;1021   							{
;;;1022   								mtCOVERAGE_TEST_MARKER();
;;;1023   							}
;;;1024   						}
;;;1025   						else
;;;1026   						{
;;;1027   							mtCOVERAGE_TEST_MARKER();
;;;1028   						}
;;;1029   					}
;;;1030   					else
;;;1031   					{
;;;1032   						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1033   						{
;;;1034   							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1035   							{
;;;1036   								/* The task waiting has a higher priority so
;;;1037   								record that a context switch is required. */
;;;1038   								if( pxHigherPriorityTaskWoken != NULL )
;;;1039   								{
;;;1040   									*pxHigherPriorityTaskWoken = pdTRUE;
;;;1041   								}
;;;1042   								else
;;;1043   								{
;;;1044   									mtCOVERAGE_TEST_MARKER();
;;;1045   								}
;;;1046   							}
;;;1047   							else
;;;1048   							{
;;;1049   								mtCOVERAGE_TEST_MARKER();
;;;1050   							}
;;;1051   						}
;;;1052   						else
;;;1053   						{
;;;1054   							mtCOVERAGE_TEST_MARKER();
;;;1055   						}
;;;1056   					}
;;;1057   				}
;;;1058   				#else /* configUSE_QUEUE_SETS */
;;;1059   				{
;;;1060   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1061   					{
;;;1062   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1063   						{
;;;1064   							/* The task waiting has a higher priority so record that a
;;;1065   							context	switch is required. */
;;;1066   							if( pxHigherPriorityTaskWoken != NULL )
;;;1067   							{
;;;1068   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1069   							}
;;;1070   							else
;;;1071   							{
;;;1072   								mtCOVERAGE_TEST_MARKER();
;;;1073   							}
;;;1074   						}
;;;1075   						else
;;;1076   						{
;;;1077   							mtCOVERAGE_TEST_MARKER();
;;;1078   						}
;;;1079   					}
;;;1080   					else
;;;1081   					{
;;;1082   						mtCOVERAGE_TEST_MARKER();
;;;1083   					}
;;;1084   				}
;;;1085   				#endif /* configUSE_QUEUE_SETS */
;;;1086   			}
;;;1087   			else
;;;1088   			{
;;;1089   				/* Increment the lock count so the task that unlocks the queue
;;;1090   				knows that data was posted while it was locked. */
;;;1091   				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
;;;1092   			}
;;;1093   
;;;1094   			xReturn = pdPASS;
;;;1095   		}
;;;1096   		else
;;;1097   		{
;;;1098   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1099   			xReturn = errQUEUE_FULL;
000040  2400              MOVS     r4,#0
                  |L21.66|
;;;1100   		}
;;;1101   	}
;;;1102   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000042  9800              LDR      r0,[sp,#0]
000044  f7fffffe          BL       vClearInterruptMaskFromISR
;;;1103   
;;;1104   	return xReturn;
000048  4620              MOV      r0,r4
;;;1105   }
00004a  b005              ADD      sp,sp,#0x14
00004c  bdf0              POP      {r4-r7,pc}
                  |L21.78|
00004e  4620              MOV      r0,r4                 ;992
000050  3040              ADDS     r0,r0,#0x40           ;992
000052  2505              MOVS     r5,#5                 ;992
000054  5745              LDRSB    r5,[r0,r5]            ;992
000056  4607              MOV      r7,r0                 ;992
000058  4632              MOV      r2,r6                 ;1001
00005a  4620              MOV      r0,r4                 ;1001
00005c  9902              LDR      r1,[sp,#8]            ;1001
00005e  f7fffffe          BL       prvCopyDataToQueue
000062  1c68              ADDS     r0,r5,#1              ;1005
000064  d003              BEQ      |L21.110|
000066  1c6d              ADDS     r5,r5,#1              ;1005
000068  717d              STRB     r5,[r7,#5]            ;1091
                  |L21.106|
00006a  2401              MOVS     r4,#1                 ;1094
00006c  e7e9              B        |L21.66|
                  |L21.110|
00006e  6a60              LDR      r0,[r4,#0x24]         ;1060
000070  2800              CMP      r0,#0                 ;1060
000072  d0fa              BEQ      |L21.106|
000074  4620              MOV      r0,r4                 ;1062
000076  3024              ADDS     r0,r0,#0x24           ;1062
000078  f7fffffe          BL       xTaskRemoveFromEventList
00007c  2800              CMP      r0,#0                 ;1062
00007e  d0f4              BEQ      |L21.106|
000080  9803              LDR      r0,[sp,#0xc]          ;1066
000082  2800              CMP      r0,#0                 ;1066
000084  d0f1              BEQ      |L21.106|
000086  2101              MOVS     r1,#1                 ;1068
000088  6001              STR      r1,[r0,#0]            ;1068
00008a  e7ee              B        |L21.106|
;;;1106   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGiveFromISR||, CODE, READONLY, ALIGN=1

                  xQueueGiveFromISR PROC
;;;1107   
;;;1108   BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
000000  b570              PUSH     {r4-r6,lr}
;;;1109   {
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d004              BEQ      |L22.18|
;;;1110   BaseType_t xReturn;
;;;1111   UBaseType_t uxSavedInterruptStatus;
;;;1112   Queue_t * const pxQueue = xQueue;
;;;1113   
;;;1114   	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
;;;1115   	item size is 0.  Don't directly wake a task that was blocked on a queue
;;;1116   	read, instead return a flag to say whether a context switch is required or
;;;1117   	not (i.e. has a task with a higher priority than us been woken by this
;;;1118   	post). */
;;;1119   
;;;1120   	configASSERT( pxQueue );
;;;1121   
;;;1122   	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
;;;1123   	if the item size is not 0. */
;;;1124   	configASSERT( pxQueue->uxItemSize == 0 );
000008  6c20              LDR      r0,[r4,#0x40]
00000a  2800              CMP      r0,#0
00000c  d003              BEQ      |L22.22|
00000e  b672              CPSID    i
                  |L22.16|
000010  e7fe              B        |L22.16|
                  |L22.18|
000012  b672              CPSID    i                     ;1120
                  |L22.20|
000014  e7fe              B        |L22.20|
                  |L22.22|
;;;1125   
;;;1126   	/* Normally a mutex would not be given from an interrupt, especially if
;;;1127   	there is a mutex holder, as priority inheritance makes no sense for an
;;;1128   	interrupts, only tasks. */
;;;1129   	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
000016  6820              LDR      r0,[r4,#0]
000018  2800              CMP      r0,#0
00001a  d104              BNE      |L22.38|
00001c  68a0              LDR      r0,[r4,#8]
00001e  2800              CMP      r0,#0
000020  d001              BEQ      |L22.38|
000022  b672              CPSID    i
                  |L22.36|
000024  e7fe              B        |L22.36|
                  |L22.38|
;;;1130   
;;;1131   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1132   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1133   	above the maximum system call priority are kept permanently enabled, even
;;;1134   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1135   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1136   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1137   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1138   	assigned a priority above the configured maximum system call priority.
;;;1139   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1140   	that have been assigned a priority at or (logically) below the maximum
;;;1141   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1142   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1143   	More information (albeit Cortex-M specific) is provided on the following
;;;1144   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1145   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1146   
;;;1147   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000026  f7fffffe          BL       ulSetInterruptMaskFromISR
;;;1148   	{
;;;1149   		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
00002a  6ba1              LDR      r1,[r4,#0x38]
00002c  4606              MOV      r6,r0                 ;1147
;;;1150   
;;;1151   		/* When the queue is used to implement a semaphore no data is ever
;;;1152   		moved through the queue but it is still valid to see if the queue 'has
;;;1153   		space'. */
;;;1154   		if( uxMessagesWaiting < pxQueue->uxLength )
00002e  6be0              LDR      r0,[r4,#0x3c]
000030  4288              CMP      r0,r1
000032  d919              BLS      |L22.104|
;;;1155   		{
;;;1156   			const int8_t cTxLock = pxQueue->cTxLock;
000034  4622              MOV      r2,r4
000036  3240              ADDS     r2,r2,#0x40
000038  2005              MOVS     r0,#5
00003a  5610              LDRSB    r0,[r2,r0]
00003c  1c49              ADDS     r1,r1,#1
;;;1157   
;;;1158   			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;1159   
;;;1160   			/* A task can only have an inherited priority if it is a mutex
;;;1161   			holder - and if there is a mutex holder then the mutex cannot be
;;;1162   			given from an ISR.  As this is the ISR version of the function it
;;;1163   			can be assumed there is no mutex holder and no need to determine if
;;;1164   			priority disinheritance is needed.  Simply increase the count of
;;;1165   			messages (semaphores) available. */
;;;1166   			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
00003e  63a1              STR      r1,[r4,#0x38]
;;;1167   
;;;1168   			/* The event list is not altered if the queue is locked.  This will
;;;1169   			be done when the queue is unlocked later. */
;;;1170   			if( cTxLock == queueUNLOCKED )
000040  1c41              ADDS     r1,r0,#1
000042  d003              BEQ      |L22.76|
000044  1c40              ADDS     r0,r0,#1
;;;1171   			{
;;;1172   				#if ( configUSE_QUEUE_SETS == 1 )
;;;1173   				{
;;;1174   					if( pxQueue->pxQueueSetContainer != NULL )
;;;1175   					{
;;;1176   						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
;;;1177   						{
;;;1178   							/* The semaphore is a member of a queue set, and
;;;1179   							posting	to the queue set caused a higher priority
;;;1180   							task to	unblock.  A context switch is required. */
;;;1181   							if( pxHigherPriorityTaskWoken != NULL )
;;;1182   							{
;;;1183   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1184   							}
;;;1185   							else
;;;1186   							{
;;;1187   								mtCOVERAGE_TEST_MARKER();
;;;1188   							}
;;;1189   						}
;;;1190   						else
;;;1191   						{
;;;1192   							mtCOVERAGE_TEST_MARKER();
;;;1193   						}
;;;1194   					}
;;;1195   					else
;;;1196   					{
;;;1197   						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1198   						{
;;;1199   							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1200   							{
;;;1201   								/* The task waiting has a higher priority so
;;;1202   								record that a context switch is required. */
;;;1203   								if( pxHigherPriorityTaskWoken != NULL )
;;;1204   								{
;;;1205   									*pxHigherPriorityTaskWoken = pdTRUE;
;;;1206   								}
;;;1207   								else
;;;1208   								{
;;;1209   									mtCOVERAGE_TEST_MARKER();
;;;1210   								}
;;;1211   							}
;;;1212   							else
;;;1213   							{
;;;1214   								mtCOVERAGE_TEST_MARKER();
;;;1215   							}
;;;1216   						}
;;;1217   						else
;;;1218   						{
;;;1219   							mtCOVERAGE_TEST_MARKER();
;;;1220   						}
;;;1221   					}
;;;1222   				}
;;;1223   				#else /* configUSE_QUEUE_SETS */
;;;1224   				{
;;;1225   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1226   					{
;;;1227   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1228   						{
;;;1229   							/* The task waiting has a higher priority so record that a
;;;1230   							context	switch is required. */
;;;1231   							if( pxHigherPriorityTaskWoken != NULL )
;;;1232   							{
;;;1233   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1234   							}
;;;1235   							else
;;;1236   							{
;;;1237   								mtCOVERAGE_TEST_MARKER();
;;;1238   							}
;;;1239   						}
;;;1240   						else
;;;1241   						{
;;;1242   							mtCOVERAGE_TEST_MARKER();
;;;1243   						}
;;;1244   					}
;;;1245   					else
;;;1246   					{
;;;1247   						mtCOVERAGE_TEST_MARKER();
;;;1248   					}
;;;1249   				}
;;;1250   				#endif /* configUSE_QUEUE_SETS */
;;;1251   			}
;;;1252   			else
;;;1253   			{
;;;1254   				/* Increment the lock count so the task that unlocks the queue
;;;1255   				knows that data was posted while it was locked. */
;;;1256   				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
000046  7150              STRB     r0,[r2,#5]
                  |L22.72|
;;;1257   			}
;;;1258   
;;;1259   			xReturn = pdPASS;
000048  2401              MOVS     r4,#1
;;;1260   		}
00004a  e00e              B        |L22.106|
                  |L22.76|
00004c  6a60              LDR      r0,[r4,#0x24]         ;1225
00004e  2800              CMP      r0,#0                 ;1225
000050  d0fa              BEQ      |L22.72|
000052  4620              MOV      r0,r4                 ;1227
000054  3024              ADDS     r0,r0,#0x24           ;1227
000056  f7fffffe          BL       xTaskRemoveFromEventList
00005a  2800              CMP      r0,#0                 ;1227
00005c  d0f4              BEQ      |L22.72|
00005e  2d00              CMP      r5,#0                 ;1231
000060  d0f2              BEQ      |L22.72|
000062  2001              MOVS     r0,#1                 ;1233
000064  6028              STR      r0,[r5,#0]            ;1233
000066  e7ef              B        |L22.72|
                  |L22.104|
;;;1261   		else
;;;1262   		{
;;;1263   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1264   			xReturn = errQUEUE_FULL;
000068  2400              MOVS     r4,#0
                  |L22.106|
;;;1265   		}
;;;1266   	}
;;;1267   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
00006a  4630              MOV      r0,r6
00006c  f7fffffe          BL       vClearInterruptMaskFromISR
;;;1268   
;;;1269   	return xReturn;
000070  4620              MOV      r0,r4
;;;1270   }
000072  bd70              POP      {r4-r6,pc}
;;;1271   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGiveMutexRecursive||, CODE, READONLY, ALIGN=1

                  xQueueGiveMutexRecursive PROC
;;;595    
;;;596    	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
000000  b510              PUSH     {r4,lr}
;;;597    	{
000002  0004              MOVS     r4,r0
000004  d009              BEQ      |L23.26|
;;;598    	BaseType_t xReturn;
;;;599    	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
;;;600    
;;;601    		configASSERT( pxMutex );
;;;602    
;;;603    		/* If this is the task that holds the mutex then xMutexHolder will not
;;;604    		change outside of this task.  If this task does not hold the mutex then
;;;605    		pxMutexHolder can never coincidentally equal the tasks handle, and as
;;;606    		this is the only condition we are interested in it does not matter if
;;;607    		pxMutexHolder is accessed simultaneously by another task.  Therefore no
;;;608    		mutual exclusion is required to test the pxMutexHolder variable. */
;;;609    		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
000006  f7fffffe          BL       xTaskGetCurrentTaskHandle
00000a  68a1              LDR      r1,[r4,#8]
00000c  4288              CMP      r0,r1
00000e  d10e              BNE      |L23.46|
;;;610    		{
;;;611    			traceGIVE_MUTEX_RECURSIVE( pxMutex );
;;;612    
;;;613    			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
;;;614    			the task handle, therefore no underflow check is required.  Also,
;;;615    			uxRecursiveCallCount is only modified by the mutex holder, and as
;;;616    			there can only be one, no mutual exclusion is required to modify the
;;;617    			uxRecursiveCallCount member. */
;;;618    			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
000010  68e0              LDR      r0,[r4,#0xc]
000012  1e40              SUBS     r0,r0,#1
;;;619    
;;;620    			/* Has the recursive call count unwound to 0? */
;;;621    			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
000014  60e0              STR      r0,[r4,#0xc]
000016  d002              BEQ      |L23.30|
000018  e007              B        |L23.42|
                  |L23.26|
00001a  b672              CPSID    i                     ;601
                  |L23.28|
00001c  e7fe              B        |L23.28|
                  |L23.30|
;;;622    			{
;;;623    				/* Return the mutex.  This will automatically unblock any other
;;;624    				task that might be waiting to access the mutex. */
;;;625    				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
00001e  2300              MOVS     r3,#0
000020  461a              MOV      r2,r3
000022  4619              MOV      r1,r3
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       xQueueGenericSend
                  |L23.42|
;;;626    			}
;;;627    			else
;;;628    			{
;;;629    				mtCOVERAGE_TEST_MARKER();
;;;630    			}
;;;631    
;;;632    			xReturn = pdPASS;
00002a  2001              MOVS     r0,#1
;;;633    		}
;;;634    		else
;;;635    		{
;;;636    			/* The mutex cannot be given because the calling task is not the
;;;637    			holder. */
;;;638    			xReturn = pdFAIL;
;;;639    
;;;640    			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
;;;641    		}
;;;642    
;;;643    		return xReturn;
;;;644    	}
00002c  bd10              POP      {r4,pc}
                  |L23.46|
00002e  2000              MOVS     r0,#0                 ;638
000030  bd10              POP      {r4,pc}
;;;645    
                          ENDP


                          AREA ||i.xQueueIsQueueEmptyFromISR||, CODE, READONLY, ALIGN=1

                  xQueueIsQueueEmptyFromISR PROC
;;;2307   
;;;2308   BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
000000  2800              CMP      r0,#0
;;;2309   {
000002  d004              BEQ      |L24.14|
;;;2310   BaseType_t xReturn;
;;;2311   Queue_t * const pxQueue = xQueue;
;;;2312   
;;;2313   	configASSERT( pxQueue );
;;;2314   	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
000004  6b80              LDR      r0,[r0,#0x38]
000006  2800              CMP      r0,#0
000008  d003              BEQ      |L24.18|
;;;2315   	{
;;;2316   		xReturn = pdTRUE;
;;;2317   	}
;;;2318   	else
;;;2319   	{
;;;2320   		xReturn = pdFALSE;
00000a  2000              MOVS     r0,#0
;;;2321   	}
;;;2322   
;;;2323   	return xReturn;
;;;2324   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
00000c  4770              BX       lr
                  |L24.14|
00000e  b672              CPSID    i                     ;2313
                  |L24.16|
000010  e7fe              B        |L24.16|
                  |L24.18|
000012  2001              MOVS     r0,#1                 ;2316
000014  4770              BX       lr
;;;2325   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueIsQueueFullFromISR||, CODE, READONLY, ALIGN=1

                  xQueueIsQueueFullFromISR PROC
;;;2347   
;;;2348   BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
000000  2800              CMP      r0,#0
;;;2349   {
000002  d005              BEQ      |L25.16|
;;;2350   BaseType_t xReturn;
;;;2351   Queue_t * const pxQueue = xQueue;
;;;2352   
;;;2353   	configASSERT( pxQueue );
;;;2354   	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
000004  6b81              LDR      r1,[r0,#0x38]
000006  6bc0              LDR      r0,[r0,#0x3c]
000008  4281              CMP      r1,r0
00000a  d103              BNE      |L25.20|
;;;2355   	{
;;;2356   		xReturn = pdTRUE;
00000c  2001              MOVS     r0,#1
;;;2357   	}
;;;2358   	else
;;;2359   	{
;;;2360   		xReturn = pdFALSE;
;;;2361   	}
;;;2362   
;;;2363   	return xReturn;
;;;2364   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
00000e  4770              BX       lr
                  |L25.16|
000010  b672              CPSID    i                     ;2353
                  |L25.18|
000012  e7fe              B        |L25.18|
                  |L25.20|
000014  2000              MOVS     r0,#0                 ;2360
000016  4770              BX       lr
;;;2365   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueuePeek||, CODE, READONLY, ALIGN=1

                  xQueuePeek PROC
;;;1631   
;;;1632   BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1633   {
;;;1634   BaseType_t xEntryTimeSet = pdFALSE;
000002  2500              MOVS     r5,#0
000004  b082              SUB      sp,sp,#8              ;1633
000006  460f              MOV      r7,r1                 ;1633
000008  4604              MOV      r4,r0                 ;1633
;;;1635   TimeOut_t xTimeOut;
;;;1636   int8_t *pcOriginalReadPosition;
;;;1637   Queue_t * const pxQueue = xQueue;
;;;1638   
;;;1639   	/* Check the pointer is not NULL. */
;;;1640   	configASSERT( ( pxQueue ) );
00000a  2800              CMP      r0,#0
00000c  d002              BEQ      |L26.20|
;;;1641   
;;;1642   	/* The buffer into which data is received can only be NULL if the data size
;;;1643   	is zero (so no data is copied into the buffer. */
;;;1644   	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
00000e  2f00              CMP      r7,#0
000010  d002              BEQ      |L26.24|
000012  e006              B        |L26.34|
                  |L26.20|
000014  b672              CPSID    i                     ;1640
                  |L26.22|
000016  e7fe              B        |L26.22|
                  |L26.24|
000018  6c20              LDR      r0,[r4,#0x40]
00001a  2800              CMP      r0,#0
00001c  d001              BEQ      |L26.34|
00001e  b672              CPSID    i
                  |L26.32|
000020  e7fe              B        |L26.32|
                  |L26.34|
;;;1645   
;;;1646   	/* Cannot block if the scheduler is suspended. */
;;;1647   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1648   	{
;;;1649   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
000022  f7fffffe          BL       xTaskGetSchedulerState
000026  2600              MOVS     r6,#0
000028  2800              CMP      r0,#0
00002a  d104              BNE      |L26.54|
00002c  9804              LDR      r0,[sp,#0x10]
00002e  2800              CMP      r0,#0
000030  d001              BEQ      |L26.54|
000032  b672              CPSID    i
                  |L26.52|
000034  e7fe              B        |L26.52|
                  |L26.54|
;;;1650   	}
;;;1651   	#endif
;;;1652   
;;;1653   
;;;1654   	/*lint -save -e904  This function relaxes the coding standard somewhat to
;;;1655   	allow return statements within the function itself.  This is done in the
;;;1656   	interest of execution time efficiency. */
;;;1657   	for( ;; )
;;;1658   	{
;;;1659   		taskENTER_CRITICAL();
000036  f7fffffe          BL       vPortEnterCritical
;;;1660   		{
;;;1661   			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
00003a  6ba0              LDR      r0,[r4,#0x38]
;;;1662   
;;;1663   			/* Is there data in the queue now?  To be running the calling task
;;;1664   			must be the highest priority task wanting to access the queue. */
;;;1665   			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
00003c  2800              CMP      r0,#0
00003e  d015              BEQ      |L26.108|
;;;1666   			{
;;;1667   				/* Remember the read position so it can be reset after the data
;;;1668   				is read from the queue as this function is only peeking the
;;;1669   				data, not removing it. */
;;;1670   				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
;;;1671   
;;;1672   				prvCopyDataFromQueue( pxQueue, pvBuffer );
000040  4639              MOV      r1,r7
000042  4620              MOV      r0,r4
000044  68e5              LDR      r5,[r4,#0xc]
000046  f7fffffe          BL       prvCopyDataFromQueue
;;;1673   				traceQUEUE_PEEK( pxQueue );
;;;1674   
;;;1675   				/* The data is not being removed, so reset the read pointer. */
;;;1676   				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
;;;1677   
;;;1678   				/* The data is being left in the queue, so see if there are
;;;1679   				any other tasks waiting for the data. */
;;;1680   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
00004a  60e5              STR      r5,[r4,#0xc]
00004c  6a60              LDR      r0,[r4,#0x24]
00004e  2800              CMP      r0,#0
000050  d007              BEQ      |L26.98|
;;;1681   				{
;;;1682   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000052  4620              MOV      r0,r4
000054  3024              ADDS     r0,r0,#0x24
000056  f7fffffe          BL       xTaskRemoveFromEventList
00005a  2800              CMP      r0,#0
00005c  d001              BEQ      |L26.98|
;;;1683   					{
;;;1684   						/* The task waiting has a higher priority than this task. */
;;;1685   						queueYIELD_IF_USING_PREEMPTION();
00005e  f7fffffe          BL       vPortYield
                  |L26.98|
;;;1686   					}
;;;1687   					else
;;;1688   					{
;;;1689   						mtCOVERAGE_TEST_MARKER();
;;;1690   					}
;;;1691   				}
;;;1692   				else
;;;1693   				{
;;;1694   					mtCOVERAGE_TEST_MARKER();
;;;1695   				}
;;;1696   
;;;1697   				taskEXIT_CRITICAL();
000062  f7fffffe          BL       vPortExitCritical
;;;1698   				return pdPASS;
000066  2001              MOVS     r0,#1
                  |L26.104|
;;;1699   			}
;;;1700   			else
;;;1701   			{
;;;1702   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1703   				{
;;;1704   					/* The queue was empty and no block time is specified (or
;;;1705   					the block time has expired) so leave now. */
;;;1706   					taskEXIT_CRITICAL();
;;;1707   					traceQUEUE_PEEK_FAILED( pxQueue );
;;;1708   					return errQUEUE_EMPTY;
;;;1709   				}
;;;1710   				else if( xEntryTimeSet == pdFALSE )
;;;1711   				{
;;;1712   					/* The queue was empty and a block time was specified so
;;;1713   					configure the timeout structure ready to enter the blocked
;;;1714   					state. */
;;;1715   					vTaskInternalSetTimeOutState( &xTimeOut );
;;;1716   					xEntryTimeSet = pdTRUE;
;;;1717   				}
;;;1718   				else
;;;1719   				{
;;;1720   					/* Entry time was already set. */
;;;1721   					mtCOVERAGE_TEST_MARKER();
;;;1722   				}
;;;1723   			}
;;;1724   		}
;;;1725   		taskEXIT_CRITICAL();
;;;1726   
;;;1727   		/* Interrupts and other tasks can send to and receive from the queue
;;;1728   		now the critical section has been exited. */
;;;1729   
;;;1730   		vTaskSuspendAll();
;;;1731   		prvLockQueue( pxQueue );
;;;1732   
;;;1733   		/* Update the timeout state to see if it has expired yet. */
;;;1734   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1735   		{
;;;1736   			/* Timeout has not expired yet, check to see if there is data in the
;;;1737   			queue now, and if not enter the Blocked state to wait for data. */
;;;1738   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1739   			{
;;;1740   				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
;;;1741   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1742   				prvUnlockQueue( pxQueue );
;;;1743   				if( xTaskResumeAll() == pdFALSE )
;;;1744   				{
;;;1745   					portYIELD_WITHIN_API();
;;;1746   				}
;;;1747   				else
;;;1748   				{
;;;1749   					mtCOVERAGE_TEST_MARKER();
;;;1750   				}
;;;1751   			}
;;;1752   			else
;;;1753   			{
;;;1754   				/* There is data in the queue now, so don't enter the blocked
;;;1755   				state, instead return to try and obtain the data. */
;;;1756   				prvUnlockQueue( pxQueue );
;;;1757   				( void ) xTaskResumeAll();
;;;1758   			}
;;;1759   		}
;;;1760   		else
;;;1761   		{
;;;1762   			/* The timeout has expired.  If there is still no data in the queue
;;;1763   			exit, otherwise go back and try to read the data again. */
;;;1764   			prvUnlockQueue( pxQueue );
;;;1765   			( void ) xTaskResumeAll();
;;;1766   
;;;1767   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1768   			{
;;;1769   				traceQUEUE_PEEK_FAILED( pxQueue );
;;;1770   				return errQUEUE_EMPTY;
;;;1771   			}
;;;1772   			else
;;;1773   			{
;;;1774   				mtCOVERAGE_TEST_MARKER();
;;;1775   			}
;;;1776   		}
;;;1777   	} /*lint -restore */
;;;1778   }
000068  b005              ADD      sp,sp,#0x14
00006a  bdf0              POP      {r4-r7,pc}
                  |L26.108|
00006c  9804              LDR      r0,[sp,#0x10]         ;1702
00006e  2800              CMP      r0,#0                 ;1702
000070  d002              BEQ      |L26.120|
000072  2d00              CMP      r5,#0                 ;1710
000074  d003              BEQ      |L26.126|
000076  e006              B        |L26.134|
                  |L26.120|
000078  f7fffffe          BL       vPortExitCritical
00007c  e027              B        |L26.206|
                  |L26.126|
00007e  4668              MOV      r0,sp                 ;1715
000080  f7fffffe          BL       vTaskInternalSetTimeOutState
000084  2501              MOVS     r5,#1                 ;1716
                  |L26.134|
000086  f7fffffe          BL       vPortExitCritical
00008a  f7fffffe          BL       vTaskSuspendAll
00008e  f7fffffe          BL       vPortEnterCritical
000092  4620              MOV      r0,r4                 ;1731
000094  3040              ADDS     r0,r0,#0x40           ;1731
000096  2104              MOVS     r1,#4                 ;1731
000098  5641              LDRSB    r1,[r0,r1]            ;1731
00009a  1c49              ADDS     r1,r1,#1              ;1731
00009c  d100              BNE      |L26.160|
00009e  7106              STRB     r6,[r0,#4]            ;1731
                  |L26.160|
0000a0  2105              MOVS     r1,#5                 ;1731
0000a2  5641              LDRSB    r1,[r0,r1]            ;1731
0000a4  1c49              ADDS     r1,r1,#1              ;1731
0000a6  d100              BNE      |L26.170|
0000a8  7146              STRB     r6,[r0,#5]            ;1731
                  |L26.170|
0000aa  f7fffffe          BL       vPortExitCritical
0000ae  a904              ADD      r1,sp,#0x10           ;1734
0000b0  4668              MOV      r0,sp                 ;1734
0000b2  f7fffffe          BL       xTaskCheckForTimeOut
0000b6  2800              CMP      r0,#0                 ;1734
0000b8  4620              MOV      r0,r4                 ;1764
0000ba  d00a              BEQ      |L26.210|
0000bc  f7fffffe          BL       prvUnlockQueue
0000c0  f7fffffe          BL       xTaskResumeAll
0000c4  4620              MOV      r0,r4                 ;1767
0000c6  f7fffffe          BL       prvIsQueueEmpty
0000ca  2800              CMP      r0,#0                 ;1767
0000cc  d0b3              BEQ      |L26.54|
                  |L26.206|
0000ce  2000              MOVS     r0,#0                 ;1770
0000d0  e7ca              B        |L26.104|
                  |L26.210|
0000d2  f7fffffe          BL       prvIsQueueEmpty
0000d6  2800              CMP      r0,#0                 ;1738
0000d8  d00e              BEQ      |L26.248|
0000da  4620              MOV      r0,r4                 ;1741
0000dc  3024              ADDS     r0,r0,#0x24           ;1741
0000de  9904              LDR      r1,[sp,#0x10]         ;1741
0000e0  f7fffffe          BL       vTaskPlaceOnEventList
0000e4  4620              MOV      r0,r4                 ;1742
0000e6  f7fffffe          BL       prvUnlockQueue
0000ea  f7fffffe          BL       xTaskResumeAll
0000ee  2800              CMP      r0,#0                 ;1743
0000f0  d1a1              BNE      |L26.54|
0000f2  f7fffffe          BL       vPortYield
0000f6  e79e              B        |L26.54|
                  |L26.248|
0000f8  4620              MOV      r0,r4                 ;1756
0000fa  f7fffffe          BL       prvUnlockQueue
0000fe  f7fffffe          BL       xTaskResumeAll
000102  e798              B        |L26.54|
;;;1779   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueuePeekFromISR||, CODE, READONLY, ALIGN=1

                  xQueuePeekFromISR PROC
;;;1871   
;;;1872   BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
000000  b5f8              PUSH     {r3-r7,lr}
;;;1873   {
000002  460f              MOV      r7,r1
000004  0004              MOVS     r4,r0
000006  d012              BEQ      |L27.46|
;;;1874   BaseType_t xReturn;
;;;1875   UBaseType_t uxSavedInterruptStatus;
;;;1876   int8_t *pcOriginalReadPosition;
;;;1877   Queue_t * const pxQueue = xQueue;
;;;1878   
;;;1879   	configASSERT( pxQueue );
;;;1880   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
000008  2f00              CMP      r7,#0
00000a  d012              BEQ      |L27.50|
;;;1881   	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
00000c  6c20              LDR      r0,[r4,#0x40]
00000e  2800              CMP      r0,#0
000010  d014              BEQ      |L27.60|
;;;1882   
;;;1883   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1884   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1885   	above the maximum system call priority are kept permanently enabled, even
;;;1886   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1887   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1888   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1889   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1890   	assigned a priority above the configured maximum system call priority.
;;;1891   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1892   	that have been assigned a priority at or (logically) below the maximum
;;;1893   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1894   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1895   	More information (albeit Cortex-M specific) is provided on the following
;;;1896   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1897   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1898   
;;;1899   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000012  f7fffffe          BL       ulSetInterruptMaskFromISR
000016  4606              MOV      r6,r0
;;;1900   	{
;;;1901   		/* Cannot block in an ISR, so check there is data available. */
;;;1902   		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
000018  6ba0              LDR      r0,[r4,#0x38]
00001a  2800              CMP      r0,#0
00001c  d010              BEQ      |L27.64|
;;;1903   		{
;;;1904   			traceQUEUE_PEEK_FROM_ISR( pxQueue );
;;;1905   
;;;1906   			/* Remember the read position so it can be reset as nothing is
;;;1907   			actually being removed from the queue. */
;;;1908   			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
;;;1909   			prvCopyDataFromQueue( pxQueue, pvBuffer );
00001e  4639              MOV      r1,r7
000020  4620              MOV      r0,r4
000022  68e5              LDR      r5,[r4,#0xc]
000024  f7fffffe          BL       prvCopyDataFromQueue
;;;1910   			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
;;;1911   
;;;1912   			xReturn = pdPASS;
000028  60e5              STR      r5,[r4,#0xc]
00002a  2401              MOVS     r4,#1
00002c  e009              B        |L27.66|
                  |L27.46|
00002e  b672              CPSID    i                     ;1879
                  |L27.48|
000030  e7fe              B        |L27.48|
                  |L27.50|
000032  6c00              LDR      r0,[r0,#0x40]         ;1880
000034  2800              CMP      r0,#0                 ;1880
000036  d001              BEQ      |L27.60|
000038  b672              CPSID    i                     ;1880
                  |L27.58|
00003a  e7fe              B        |L27.58|
                  |L27.60|
00003c  b672              CPSID    i                     ;1881
                  |L27.62|
00003e  e7fe              B        |L27.62|
                  |L27.64|
;;;1913   		}
;;;1914   		else
;;;1915   		{
;;;1916   			xReturn = pdFAIL;
000040  2400              MOVS     r4,#0
                  |L27.66|
;;;1917   			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
;;;1918   		}
;;;1919   	}
;;;1920   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000042  4630              MOV      r0,r6
000044  f7fffffe          BL       vClearInterruptMaskFromISR
;;;1921   
;;;1922   	return xReturn;
000048  4620              MOV      r0,r4
;;;1923   }
00004a  bdf8              POP      {r3-r7,pc}
;;;1924   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueReceive||, CODE, READONLY, ALIGN=1

                  xQueueReceive PROC
;;;1272   
;;;1273   BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1274   {
;;;1275   BaseType_t xEntryTimeSet = pdFALSE;
000002  2500              MOVS     r5,#0
000004  b082              SUB      sp,sp,#8              ;1274
000006  4604              MOV      r4,r0                 ;1274
;;;1276   TimeOut_t xTimeOut;
;;;1277   Queue_t * const pxQueue = xQueue;
;;;1278   
;;;1279   	/* Check the pointer is not NULL. */
;;;1280   	configASSERT( ( pxQueue ) );
000008  2800              CMP      r0,#0
00000a  d003              BEQ      |L28.20|
;;;1281   
;;;1282   	/* The buffer into which data is received can only be NULL if the data size
;;;1283   	is zero (so no data is copied into the buffer. */
;;;1284   	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
00000c  9803              LDR      r0,[sp,#0xc]
00000e  2800              CMP      r0,#0
000010  d002              BEQ      |L28.24|
000012  e006              B        |L28.34|
                  |L28.20|
000014  b672              CPSID    i                     ;1280
                  |L28.22|
000016  e7fe              B        |L28.22|
                  |L28.24|
000018  6c20              LDR      r0,[r4,#0x40]
00001a  2800              CMP      r0,#0
00001c  d001              BEQ      |L28.34|
00001e  b672              CPSID    i
                  |L28.32|
000020  e7fe              B        |L28.32|
                  |L28.34|
;;;1285   
;;;1286   	/* Cannot block if the scheduler is suspended. */
;;;1287   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1288   	{
;;;1289   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
000022  f7fffffe          BL       xTaskGetSchedulerState
000026  2600              MOVS     r6,#0
000028  2800              CMP      r0,#0
00002a  d104              BNE      |L28.54|
00002c  9804              LDR      r0,[sp,#0x10]
00002e  2800              CMP      r0,#0
000030  d001              BEQ      |L28.54|
000032  b672              CPSID    i
                  |L28.52|
000034  e7fe              B        |L28.52|
                  |L28.54|
;;;1290   	}
;;;1291   	#endif
;;;1292   
;;;1293   
;;;1294   	/*lint -save -e904  This function relaxes the coding standard somewhat to
;;;1295   	allow return statements within the function itself.  This is done in the
;;;1296   	interest of execution time efficiency. */
;;;1297   	for( ;; )
;;;1298   	{
;;;1299   		taskENTER_CRITICAL();
000036  f7fffffe          BL       vPortEnterCritical
;;;1300   		{
;;;1301   			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
00003a  6ba7              LDR      r7,[r4,#0x38]
;;;1302   
;;;1303   			/* Is there data in the queue now?  To be running the calling task
;;;1304   			must be the highest priority task wanting to access the queue. */
;;;1305   			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
00003c  2f00              CMP      r7,#0
00003e  d015              BEQ      |L28.108|
;;;1306   			{
;;;1307   				/* Data available, remove one item. */
;;;1308   				prvCopyDataFromQueue( pxQueue, pvBuffer );
000040  4620              MOV      r0,r4
000042  9903              LDR      r1,[sp,#0xc]
000044  f7fffffe          BL       prvCopyDataFromQueue
000048  1e7f              SUBS     r7,r7,#1
;;;1309   				traceQUEUE_RECEIVE( pxQueue );
;;;1310   				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
00004a  63a7              STR      r7,[r4,#0x38]
;;;1311   
;;;1312   				/* There is now space in the queue, were any tasks waiting to
;;;1313   				post to the queue?  If so, unblock the highest priority waiting
;;;1314   				task. */
;;;1315   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
00004c  6920              LDR      r0,[r4,#0x10]
00004e  2800              CMP      r0,#0
000050  d007              BEQ      |L28.98|
;;;1316   				{
;;;1317   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000052  4620              MOV      r0,r4
000054  3010              ADDS     r0,r0,#0x10
000056  f7fffffe          BL       xTaskRemoveFromEventList
00005a  2800              CMP      r0,#0
00005c  d001              BEQ      |L28.98|
;;;1318   					{
;;;1319   						queueYIELD_IF_USING_PREEMPTION();
00005e  f7fffffe          BL       vPortYield
                  |L28.98|
;;;1320   					}
;;;1321   					else
;;;1322   					{
;;;1323   						mtCOVERAGE_TEST_MARKER();
;;;1324   					}
;;;1325   				}
;;;1326   				else
;;;1327   				{
;;;1328   					mtCOVERAGE_TEST_MARKER();
;;;1329   				}
;;;1330   
;;;1331   				taskEXIT_CRITICAL();
000062  f7fffffe          BL       vPortExitCritical
;;;1332   				return pdPASS;
000066  2001              MOVS     r0,#1
                  |L28.104|
;;;1333   			}
;;;1334   			else
;;;1335   			{
;;;1336   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1337   				{
;;;1338   					/* The queue was empty and no block time is specified (or
;;;1339   					the block time has expired) so leave now. */
;;;1340   					taskEXIT_CRITICAL();
;;;1341   					traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1342   					return errQUEUE_EMPTY;
;;;1343   				}
;;;1344   				else if( xEntryTimeSet == pdFALSE )
;;;1345   				{
;;;1346   					/* The queue was empty and a block time was specified so
;;;1347   					configure the timeout structure. */
;;;1348   					vTaskInternalSetTimeOutState( &xTimeOut );
;;;1349   					xEntryTimeSet = pdTRUE;
;;;1350   				}
;;;1351   				else
;;;1352   				{
;;;1353   					/* Entry time was already set. */
;;;1354   					mtCOVERAGE_TEST_MARKER();
;;;1355   				}
;;;1356   			}
;;;1357   		}
;;;1358   		taskEXIT_CRITICAL();
;;;1359   
;;;1360   		/* Interrupts and other tasks can send to and receive from the queue
;;;1361   		now the critical section has been exited. */
;;;1362   
;;;1363   		vTaskSuspendAll();
;;;1364   		prvLockQueue( pxQueue );
;;;1365   
;;;1366   		/* Update the timeout state to see if it has expired yet. */
;;;1367   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1368   		{
;;;1369   			/* The timeout has not expired.  If the queue is still empty place
;;;1370   			the task on the list of tasks waiting to receive from the queue. */
;;;1371   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1372   			{
;;;1373   				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
;;;1374   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1375   				prvUnlockQueue( pxQueue );
;;;1376   				if( xTaskResumeAll() == pdFALSE )
;;;1377   				{
;;;1378   					portYIELD_WITHIN_API();
;;;1379   				}
;;;1380   				else
;;;1381   				{
;;;1382   					mtCOVERAGE_TEST_MARKER();
;;;1383   				}
;;;1384   			}
;;;1385   			else
;;;1386   			{
;;;1387   				/* The queue contains data again.  Loop back to try and read the
;;;1388   				data. */
;;;1389   				prvUnlockQueue( pxQueue );
;;;1390   				( void ) xTaskResumeAll();
;;;1391   			}
;;;1392   		}
;;;1393   		else
;;;1394   		{
;;;1395   			/* Timed out.  If there is no data in the queue exit, otherwise loop
;;;1396   			back and attempt to read the data. */
;;;1397   			prvUnlockQueue( pxQueue );
;;;1398   			( void ) xTaskResumeAll();
;;;1399   
;;;1400   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1401   			{
;;;1402   				traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1403   				return errQUEUE_EMPTY;
;;;1404   			}
;;;1405   			else
;;;1406   			{
;;;1407   				mtCOVERAGE_TEST_MARKER();
;;;1408   			}
;;;1409   		}
;;;1410   	} /*lint -restore */
;;;1411   }
000068  b005              ADD      sp,sp,#0x14
00006a  bdf0              POP      {r4-r7,pc}
                  |L28.108|
00006c  9804              LDR      r0,[sp,#0x10]         ;1336
00006e  2800              CMP      r0,#0                 ;1336
000070  d002              BEQ      |L28.120|
000072  2d00              CMP      r5,#0                 ;1344
000074  d003              BEQ      |L28.126|
000076  e006              B        |L28.134|
                  |L28.120|
000078  f7fffffe          BL       vPortExitCritical
00007c  e027              B        |L28.206|
                  |L28.126|
00007e  4668              MOV      r0,sp                 ;1348
000080  f7fffffe          BL       vTaskInternalSetTimeOutState
000084  2501              MOVS     r5,#1                 ;1349
                  |L28.134|
000086  f7fffffe          BL       vPortExitCritical
00008a  f7fffffe          BL       vTaskSuspendAll
00008e  f7fffffe          BL       vPortEnterCritical
000092  4620              MOV      r0,r4                 ;1364
000094  3040              ADDS     r0,r0,#0x40           ;1364
000096  2104              MOVS     r1,#4                 ;1364
000098  5641              LDRSB    r1,[r0,r1]            ;1364
00009a  1c49              ADDS     r1,r1,#1              ;1364
00009c  d100              BNE      |L28.160|
00009e  7106              STRB     r6,[r0,#4]            ;1364
                  |L28.160|
0000a0  2105              MOVS     r1,#5                 ;1364
0000a2  5641              LDRSB    r1,[r0,r1]            ;1364
0000a4  1c49              ADDS     r1,r1,#1              ;1364
0000a6  d100              BNE      |L28.170|
0000a8  7146              STRB     r6,[r0,#5]            ;1364
                  |L28.170|
0000aa  f7fffffe          BL       vPortExitCritical
0000ae  a904              ADD      r1,sp,#0x10           ;1367
0000b0  4668              MOV      r0,sp                 ;1367
0000b2  f7fffffe          BL       xTaskCheckForTimeOut
0000b6  2800              CMP      r0,#0                 ;1367
0000b8  4620              MOV      r0,r4                 ;1397
0000ba  d00a              BEQ      |L28.210|
0000bc  f7fffffe          BL       prvUnlockQueue
0000c0  f7fffffe          BL       xTaskResumeAll
0000c4  4620              MOV      r0,r4                 ;1400
0000c6  f7fffffe          BL       prvIsQueueEmpty
0000ca  2800              CMP      r0,#0                 ;1400
0000cc  d0b3              BEQ      |L28.54|
                  |L28.206|
0000ce  2000              MOVS     r0,#0                 ;1403
0000d0  e7ca              B        |L28.104|
                  |L28.210|
0000d2  f7fffffe          BL       prvIsQueueEmpty
0000d6  2800              CMP      r0,#0                 ;1371
0000d8  d00e              BEQ      |L28.248|
0000da  4620              MOV      r0,r4                 ;1374
0000dc  3024              ADDS     r0,r0,#0x24           ;1374
0000de  9904              LDR      r1,[sp,#0x10]         ;1374
0000e0  f7fffffe          BL       vTaskPlaceOnEventList
0000e4  4620              MOV      r0,r4                 ;1375
0000e6  f7fffffe          BL       prvUnlockQueue
0000ea  f7fffffe          BL       xTaskResumeAll
0000ee  2800              CMP      r0,#0                 ;1376
0000f0  d1a1              BNE      |L28.54|
0000f2  f7fffffe          BL       vPortYield
0000f6  e79e              B        |L28.54|
                  |L28.248|
0000f8  4620              MOV      r0,r4                 ;1389
0000fa  f7fffffe          BL       prvUnlockQueue
0000fe  f7fffffe          BL       xTaskResumeAll
000102  e798              B        |L28.54|
;;;1412   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueReceiveFromISR||, CODE, READONLY, ALIGN=1

                  xQueueReceiveFromISR PROC
;;;1780   
;;;1781   BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1782   {
000002  b082              SUB      sp,sp,#8
000004  0004              MOVS     r4,r0
000006  d003              BEQ      |L29.16|
;;;1783   BaseType_t xReturn;
;;;1784   UBaseType_t uxSavedInterruptStatus;
;;;1785   Queue_t * const pxQueue = xQueue;
;;;1786   
;;;1787   	configASSERT( pxQueue );
;;;1788   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
000008  9803              LDR      r0,[sp,#0xc]
00000a  2800              CMP      r0,#0
00000c  d002              BEQ      |L29.20|
00000e  e006              B        |L29.30|
                  |L29.16|
000010  b672              CPSID    i                     ;1787
                  |L29.18|
000012  e7fe              B        |L29.18|
                  |L29.20|
000014  6c20              LDR      r0,[r4,#0x40]
000016  2800              CMP      r0,#0
000018  d001              BEQ      |L29.30|
00001a  b672              CPSID    i
                  |L29.28|
00001c  e7fe              B        |L29.28|
                  |L29.30|
;;;1789   
;;;1790   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1791   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1792   	above the maximum system call priority are kept permanently enabled, even
;;;1793   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1794   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1795   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1796   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1797   	assigned a priority above the configured maximum system call priority.
;;;1798   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1799   	that have been assigned a priority at or (logically) below the maximum
;;;1800   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1801   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1802   	More information (albeit Cortex-M specific) is provided on the following
;;;1803   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1804   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1805   
;;;1806   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00001e  f7fffffe          BL       ulSetInterruptMaskFromISR
;;;1807   	{
;;;1808   		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
000022  9000              STR      r0,[sp,#0]
000024  6ba6              LDR      r6,[r4,#0x38]
;;;1809   
;;;1810   		/* Cannot block in an ISR, so check there is data available. */
;;;1811   		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
000026  2e00              CMP      r6,#0
000028  d01f              BEQ      |L29.106|
;;;1812   		{
;;;1813   			const int8_t cRxLock = pxQueue->cRxLock;
00002a  4620              MOV      r0,r4
00002c  3040              ADDS     r0,r0,#0x40
00002e  2504              MOVS     r5,#4
000030  5745              LDRSB    r5,[r0,r5]
000032  4607              MOV      r7,r0
;;;1814   
;;;1815   			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
;;;1816   
;;;1817   			prvCopyDataFromQueue( pxQueue, pvBuffer );
000034  4620              MOV      r0,r4
000036  9903              LDR      r1,[sp,#0xc]
000038  f7fffffe          BL       prvCopyDataFromQueue
00003c  1e76              SUBS     r6,r6,#1
;;;1818   			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
00003e  63a6              STR      r6,[r4,#0x38]
;;;1819   
;;;1820   			/* If the queue is locked the event list will not be modified.
;;;1821   			Instead update the lock count so the task that unlocks the queue
;;;1822   			will know that an ISR has removed data while the queue was
;;;1823   			locked. */
;;;1824   			if( cRxLock == queueUNLOCKED )
000040  1c68              ADDS     r0,r5,#1
000042  d003              BEQ      |L29.76|
000044  1c6d              ADDS     r5,r5,#1
;;;1825   			{
;;;1826   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;1827   				{
;;;1828   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
;;;1829   					{
;;;1830   						/* The task waiting has a higher priority than us so
;;;1831   						force a context switch. */
;;;1832   						if( pxHigherPriorityTaskWoken != NULL )
;;;1833   						{
;;;1834   							*pxHigherPriorityTaskWoken = pdTRUE;
;;;1835   						}
;;;1836   						else
;;;1837   						{
;;;1838   							mtCOVERAGE_TEST_MARKER();
;;;1839   						}
;;;1840   					}
;;;1841   					else
;;;1842   					{
;;;1843   						mtCOVERAGE_TEST_MARKER();
;;;1844   					}
;;;1845   				}
;;;1846   				else
;;;1847   				{
;;;1848   					mtCOVERAGE_TEST_MARKER();
;;;1849   				}
;;;1850   			}
;;;1851   			else
;;;1852   			{
;;;1853   				/* Increment the lock count so the task that unlocks the queue
;;;1854   				knows that data was removed while it was locked. */
;;;1855   				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
000046  713d              STRB     r5,[r7,#4]
                  |L29.72|
;;;1856   			}
;;;1857   
;;;1858   			xReturn = pdPASS;
000048  2401              MOVS     r4,#1
;;;1859   		}
00004a  e00f              B        |L29.108|
                  |L29.76|
00004c  6920              LDR      r0,[r4,#0x10]         ;1826
00004e  2800              CMP      r0,#0                 ;1826
000050  d0fa              BEQ      |L29.72|
000052  4620              MOV      r0,r4                 ;1828
000054  3010              ADDS     r0,r0,#0x10           ;1828
000056  f7fffffe          BL       xTaskRemoveFromEventList
00005a  2800              CMP      r0,#0                 ;1828
00005c  d0f4              BEQ      |L29.72|
00005e  9804              LDR      r0,[sp,#0x10]         ;1832
000060  2800              CMP      r0,#0                 ;1832
000062  d0f1              BEQ      |L29.72|
000064  2101              MOVS     r1,#1                 ;1834
000066  6001              STR      r1,[r0,#0]            ;1834
000068  e7ee              B        |L29.72|
                  |L29.106|
;;;1860   		else
;;;1861   		{
;;;1862   			xReturn = pdFAIL;
00006a  2400              MOVS     r4,#0
                  |L29.108|
;;;1863   			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
;;;1864   		}
;;;1865   	}
;;;1866   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
00006c  9800              LDR      r0,[sp,#0]
00006e  f7fffffe          BL       vClearInterruptMaskFromISR
;;;1867   
;;;1868   	return xReturn;
000072  4620              MOV      r0,r4
;;;1869   }
000074  b005              ADD      sp,sp,#0x14
000076  bdf0              POP      {r4-r7,pc}
;;;1870   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueSemaphoreTake||, CODE, READONLY, ALIGN=1

                  xQueueSemaphoreTake PROC
;;;1413   
;;;1414   BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;1415   {
;;;1416   BaseType_t xEntryTimeSet = pdFALSE;
000002  2500              MOVS     r5,#0
000004  b083              SUB      sp,sp,#0xc            ;1415
000006  4604              MOV      r4,r0                 ;1415
;;;1417   TimeOut_t xTimeOut;
;;;1418   Queue_t * const pxQueue = xQueue;
;;;1419   
;;;1420   #if( configUSE_MUTEXES == 1 )
;;;1421   	BaseType_t xInheritanceOccurred = pdFALSE;
000008  462e              MOV      r6,r5
;;;1422   #endif
;;;1423   
;;;1424   	/* Check the queue pointer is not NULL. */
;;;1425   	configASSERT( ( pxQueue ) );
00000a  2800              CMP      r0,#0
00000c  d004              BEQ      |L30.24|
;;;1426   
;;;1427   	/* Check this really is a semaphore, in which case the item size will be
;;;1428   	0. */
;;;1429   	configASSERT( pxQueue->uxItemSize == 0 );
00000e  6c20              LDR      r0,[r4,#0x40]
000010  2800              CMP      r0,#0
000012  d003              BEQ      |L30.28|
000014  b672              CPSID    i
                  |L30.22|
000016  e7fe              B        |L30.22|
                  |L30.24|
000018  b672              CPSID    i                     ;1425
                  |L30.26|
00001a  e7fe              B        |L30.26|
                  |L30.28|
;;;1430   
;;;1431   	/* Cannot block if the scheduler is suspended. */
;;;1432   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1433   	{
;;;1434   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
00001c  f7fffffe          BL       xTaskGetSchedulerState
000020  2700              MOVS     r7,#0
000022  2800              CMP      r0,#0
000024  d104              BNE      |L30.48|
000026  9804              LDR      r0,[sp,#0x10]
000028  2800              CMP      r0,#0
00002a  d001              BEQ      |L30.48|
00002c  b672              CPSID    i
                  |L30.46|
00002e  e7fe              B        |L30.46|
                  |L30.48|
;;;1435   	}
;;;1436   	#endif
;;;1437   
;;;1438   
;;;1439   	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
;;;1440   	statements within the function itself.  This is done in the interest
;;;1441   	of execution time efficiency. */
;;;1442   	for( ;; )
;;;1443   	{
;;;1444   		taskENTER_CRITICAL();
000030  f7fffffe          BL       vPortEnterCritical
;;;1445   		{
;;;1446   			/* Semaphores are queues with an item size of 0, and where the
;;;1447   			number of messages in the queue is the semaphore's count value. */
;;;1448   			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
000034  6ba0              LDR      r0,[r4,#0x38]
;;;1449   
;;;1450   			/* Is there data in the queue now?  To be running the calling task
;;;1451   			must be the highest priority task wanting to access the queue. */
;;;1452   			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
000036  2800              CMP      r0,#0
000038  d017              BEQ      |L30.106|
00003a  1e40              SUBS     r0,r0,#1
;;;1453   			{
;;;1454   				traceQUEUE_RECEIVE( pxQueue );
;;;1455   
;;;1456   				/* Semaphores are queues with a data size of zero and where the
;;;1457   				messages waiting is the semaphore's count.  Reduce the count. */
;;;1458   				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
00003c  63a0              STR      r0,[r4,#0x38]
;;;1459   
;;;1460   				#if ( configUSE_MUTEXES == 1 )
;;;1461   				{
;;;1462   					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
00003e  6820              LDR      r0,[r4,#0]
000040  2800              CMP      r0,#0
000042  d102              BNE      |L30.74|
;;;1463   					{
;;;1464   						/* Record the information required to implement
;;;1465   						priority inheritance should it become necessary. */
;;;1466   						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
000044  f7fffffe          BL       pvTaskIncrementMutexHeldCount
000048  60a0              STR      r0,[r4,#8]
                  |L30.74|
;;;1467   					}
;;;1468   					else
;;;1469   					{
;;;1470   						mtCOVERAGE_TEST_MARKER();
;;;1471   					}
;;;1472   				}
;;;1473   				#endif /* configUSE_MUTEXES */
;;;1474   
;;;1475   				/* Check to see if other tasks are blocked waiting to give the
;;;1476   				semaphore, and if so, unblock the highest priority such task. */
;;;1477   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
00004a  6920              LDR      r0,[r4,#0x10]
00004c  2800              CMP      r0,#0
00004e  d007              BEQ      |L30.96|
;;;1478   				{
;;;1479   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000050  4620              MOV      r0,r4
000052  3010              ADDS     r0,r0,#0x10
000054  f7fffffe          BL       xTaskRemoveFromEventList
000058  2800              CMP      r0,#0
00005a  d001              BEQ      |L30.96|
;;;1480   					{
;;;1481   						queueYIELD_IF_USING_PREEMPTION();
00005c  f7fffffe          BL       vPortYield
                  |L30.96|
;;;1482   					}
;;;1483   					else
;;;1484   					{
;;;1485   						mtCOVERAGE_TEST_MARKER();
;;;1486   					}
;;;1487   				}
;;;1488   				else
;;;1489   				{
;;;1490   					mtCOVERAGE_TEST_MARKER();
;;;1491   				}
;;;1492   
;;;1493   				taskEXIT_CRITICAL();
000060  f7fffffe          BL       vPortExitCritical
;;;1494   				return pdPASS;
000064  2001              MOVS     r0,#1
                  |L30.102|
;;;1495   			}
;;;1496   			else
;;;1497   			{
;;;1498   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1499   				{
;;;1500   					/* For inheritance to have occurred there must have been an
;;;1501   					initial timeout, and an adjusted timeout cannot become 0, as
;;;1502   					if it were 0 the function would have exited. */
;;;1503   					#if( configUSE_MUTEXES == 1 )
;;;1504   					{
;;;1505   						configASSERT( xInheritanceOccurred == pdFALSE );
;;;1506   					}
;;;1507   					#endif /* configUSE_MUTEXES */
;;;1508   
;;;1509   					/* The semaphore count was 0 and no block time is specified
;;;1510   					(or the block time has expired) so exit now. */
;;;1511   					taskEXIT_CRITICAL();
;;;1512   					traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1513   					return errQUEUE_EMPTY;
;;;1514   				}
;;;1515   				else if( xEntryTimeSet == pdFALSE )
;;;1516   				{
;;;1517   					/* The semaphore count was 0 and a block time was specified
;;;1518   					so configure the timeout structure ready to block. */
;;;1519   					vTaskInternalSetTimeOutState( &xTimeOut );
;;;1520   					xEntryTimeSet = pdTRUE;
;;;1521   				}
;;;1522   				else
;;;1523   				{
;;;1524   					/* Entry time was already set. */
;;;1525   					mtCOVERAGE_TEST_MARKER();
;;;1526   				}
;;;1527   			}
;;;1528   		}
;;;1529   		taskEXIT_CRITICAL();
;;;1530   
;;;1531   		/* Interrupts and other tasks can give to and take from the semaphore
;;;1532   		now the critical section has been exited. */
;;;1533   
;;;1534   		vTaskSuspendAll();
;;;1535   		prvLockQueue( pxQueue );
;;;1536   
;;;1537   		/* Update the timeout state to see if it has expired yet. */
;;;1538   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1539   		{
;;;1540   			/* A block time is specified and not expired.  If the semaphore
;;;1541   			count is 0 then enter the Blocked state to wait for a semaphore to
;;;1542   			become available.  As semaphores are implemented with queues the
;;;1543   			queue being empty is equivalent to the semaphore count being 0. */
;;;1544   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1545   			{
;;;1546   				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
;;;1547   
;;;1548   				#if ( configUSE_MUTEXES == 1 )
;;;1549   				{
;;;1550   					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1551   					{
;;;1552   						taskENTER_CRITICAL();
;;;1553   						{
;;;1554   							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
;;;1555   						}
;;;1556   						taskEXIT_CRITICAL();
;;;1557   					}
;;;1558   					else
;;;1559   					{
;;;1560   						mtCOVERAGE_TEST_MARKER();
;;;1561   					}
;;;1562   				}
;;;1563   				#endif
;;;1564   
;;;1565   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1566   				prvUnlockQueue( pxQueue );
;;;1567   				if( xTaskResumeAll() == pdFALSE )
;;;1568   				{
;;;1569   					portYIELD_WITHIN_API();
;;;1570   				}
;;;1571   				else
;;;1572   				{
;;;1573   					mtCOVERAGE_TEST_MARKER();
;;;1574   				}
;;;1575   			}
;;;1576   			else
;;;1577   			{
;;;1578   				/* There was no timeout and the semaphore count was not 0, so
;;;1579   				attempt to take the semaphore again. */
;;;1580   				prvUnlockQueue( pxQueue );
;;;1581   				( void ) xTaskResumeAll();
;;;1582   			}
;;;1583   		}
;;;1584   		else
;;;1585   		{
;;;1586   			/* Timed out. */
;;;1587   			prvUnlockQueue( pxQueue );
;;;1588   			( void ) xTaskResumeAll();
;;;1589   
;;;1590   			/* If the semaphore count is 0 exit now as the timeout has
;;;1591   			expired.  Otherwise return to attempt to take the semaphore that is
;;;1592   			known to be available.  As semaphores are implemented by queues the
;;;1593   			queue being empty is equivalent to the semaphore count being 0. */
;;;1594   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1595   			{
;;;1596   				#if ( configUSE_MUTEXES == 1 )
;;;1597   				{
;;;1598   					/* xInheritanceOccurred could only have be set if
;;;1599   					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
;;;1600   					test the mutex type again to check it is actually a mutex. */
;;;1601   					if( xInheritanceOccurred != pdFALSE )
;;;1602   					{
;;;1603   						taskENTER_CRITICAL();
;;;1604   						{
;;;1605   							UBaseType_t uxHighestWaitingPriority;
;;;1606   
;;;1607   							/* This task blocking on the mutex caused another
;;;1608   							task to inherit this task's priority.  Now this task
;;;1609   							has timed out the priority should be disinherited
;;;1610   							again, but only as low as the next highest priority
;;;1611   							task that is waiting for the same mutex. */
;;;1612   							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
;;;1613   							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
;;;1614   						}
;;;1615   						taskEXIT_CRITICAL();
;;;1616   					}
;;;1617   				}
;;;1618   				#endif /* configUSE_MUTEXES */
;;;1619   
;;;1620   				traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1621   				return errQUEUE_EMPTY;
;;;1622   			}
;;;1623   			else
;;;1624   			{
;;;1625   				mtCOVERAGE_TEST_MARKER();
;;;1626   			}
;;;1627   		}
;;;1628   	} /*lint -restore */
;;;1629   }
000066  b005              ADD      sp,sp,#0x14
000068  bdf0              POP      {r4-r7,pc}
                  |L30.106|
00006a  9804              LDR      r0,[sp,#0x10]         ;1498
00006c  2800              CMP      r0,#0                 ;1498
00006e  d002              BEQ      |L30.118|
000070  2d00              CMP      r5,#0                 ;1515
000072  d007              BEQ      |L30.132|
000074  e00a              B        |L30.140|
                  |L30.118|
000076  2e00              CMP      r6,#0                 ;1505
000078  d001              BEQ      |L30.126|
00007a  b672              CPSID    i                     ;1505
                  |L30.124|
00007c  e7fe              B        |L30.124|
                  |L30.126|
00007e  f7fffffe          BL       vPortExitCritical
000082  e05c              B        |L30.318|
                  |L30.132|
000084  4668              MOV      r0,sp                 ;1519
000086  f7fffffe          BL       vTaskInternalSetTimeOutState
00008a  2501              MOVS     r5,#1                 ;1520
                  |L30.140|
00008c  f7fffffe          BL       vPortExitCritical
000090  f7fffffe          BL       vTaskSuspendAll
000094  f7fffffe          BL       vPortEnterCritical
000098  4620              MOV      r0,r4                 ;1535
00009a  3040              ADDS     r0,r0,#0x40           ;1535
00009c  2104              MOVS     r1,#4                 ;1535
00009e  5641              LDRSB    r1,[r0,r1]            ;1535
0000a0  1c49              ADDS     r1,r1,#1              ;1535
0000a2  d100              BNE      |L30.166|
0000a4  7107              STRB     r7,[r0,#4]            ;1535
                  |L30.166|
0000a6  2105              MOVS     r1,#5                 ;1535
0000a8  5641              LDRSB    r1,[r0,r1]            ;1535
0000aa  1c49              ADDS     r1,r1,#1              ;1535
0000ac  d100              BNE      |L30.176|
0000ae  7147              STRB     r7,[r0,#5]            ;1535
                  |L30.176|
0000b0  f7fffffe          BL       vPortExitCritical
0000b4  a904              ADD      r1,sp,#0x10           ;1538
0000b6  4668              MOV      r0,sp                 ;1538
0000b8  f7fffffe          BL       xTaskCheckForTimeOut
0000bc  2800              CMP      r0,#0                 ;1538
0000be  4620              MOV      r0,r4                 ;1587
0000c0  d014              BEQ      |L30.236|
0000c2  f7fffffe          BL       prvUnlockQueue
0000c6  f7fffffe          BL       xTaskResumeAll
0000ca  4620              MOV      r0,r4                 ;1594
0000cc  f7fffffe          BL       prvIsQueueEmpty
0000d0  2800              CMP      r0,#0                 ;1594
0000d2  d0ad              BEQ      |L30.48|
0000d4  2e00              CMP      r6,#0                 ;1601
0000d6  d032              BEQ      |L30.318|
0000d8  f7fffffe          BL       vPortEnterCritical
0000dc  6a60              LDR      r0,[r4,#0x24]         ;1603
0000de  2800              CMP      r0,#0                 ;1603
0000e0  d028              BEQ      |L30.308|
0000e2  6b20              LDR      r0,[r4,#0x30]         ;1603
0000e4  2105              MOVS     r1,#5                 ;1603
0000e6  6800              LDR      r0,[r0,#0]            ;1603
0000e8  1a09              SUBS     r1,r1,r0              ;1603
0000ea  e024              B        |L30.310|
                  |L30.236|
0000ec  f7fffffe          BL       prvIsQueueEmpty
0000f0  2800              CMP      r0,#0                 ;1544
0000f2  d019              BEQ      |L30.296|
0000f4  6820              LDR      r0,[r4,#0]            ;1550
0000f6  2800              CMP      r0,#0                 ;1550
0000f8  d107              BNE      |L30.266|
0000fa  f7fffffe          BL       vPortEnterCritical
0000fe  68a0              LDR      r0,[r4,#8]            ;1554
000100  f7fffffe          BL       xTaskPriorityInherit
000104  4606              MOV      r6,r0                 ;1554
000106  f7fffffe          BL       vPortExitCritical
                  |L30.266|
00010a  4620              MOV      r0,r4                 ;1565
00010c  3024              ADDS     r0,r0,#0x24           ;1565
00010e  9904              LDR      r1,[sp,#0x10]         ;1565
000110  f7fffffe          BL       vTaskPlaceOnEventList
000114  4620              MOV      r0,r4                 ;1566
000116  f7fffffe          BL       prvUnlockQueue
00011a  f7fffffe          BL       xTaskResumeAll
00011e  2800              CMP      r0,#0                 ;1567
000120  d186              BNE      |L30.48|
000122  f7fffffe          BL       vPortYield
000126  e783              B        |L30.48|
                  |L30.296|
000128  4620              MOV      r0,r4                 ;1580
00012a  f7fffffe          BL       prvUnlockQueue
00012e  f7fffffe          BL       xTaskResumeAll
000132  e77d              B        |L30.48|
                  |L30.308|
000134  2100              MOVS     r1,#0                 ;1581
                  |L30.310|
000136  68a0              LDR      r0,[r4,#8]            ;1613
000138  f7fffffe          BL       vTaskPriorityDisinheritAfterTimeout
00013c  e79f              B        |L30.126|
                  |L30.318|
00013e  2000              MOVS     r0,#0                 ;1621
000140  e791              B        |L30.102|
;;;1630   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueTakeMutexRecursive||, CODE, READONLY, ALIGN=1

                  xQueueTakeMutexRecursive PROC
;;;650    
;;;651    	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;652    	{
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d009              BEQ      |L31.28|
;;;653    	BaseType_t xReturn;
;;;654    	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
;;;655    
;;;656    		configASSERT( pxMutex );
;;;657    
;;;658    		/* Comments regarding mutual exclusion as per those within
;;;659    		xQueueGiveMutexRecursive(). */
;;;660    
;;;661    		traceTAKE_MUTEX_RECURSIVE( pxMutex );
;;;662    
;;;663    		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
000008  f7fffffe          BL       xTaskGetCurrentTaskHandle
00000c  68a1              LDR      r1,[r4,#8]
00000e  4288              CMP      r0,r1
000010  d106              BNE      |L31.32|
;;;664    		{
;;;665    			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
000012  68e0              LDR      r0,[r4,#0xc]
000014  1c40              ADDS     r0,r0,#1
;;;666    			xReturn = pdPASS;
000016  60e0              STR      r0,[r4,#0xc]
000018  2001              MOVS     r0,#1
                  |L31.26|
;;;667    		}
;;;668    		else
;;;669    		{
;;;670    			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
;;;671    
;;;672    			/* pdPASS will only be returned if the mutex was successfully
;;;673    			obtained.  The calling task may have entered the Blocked state
;;;674    			before reaching here. */
;;;675    			if( xReturn != pdFAIL )
;;;676    			{
;;;677    				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
;;;678    			}
;;;679    			else
;;;680    			{
;;;681    				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
;;;682    			}
;;;683    		}
;;;684    
;;;685    		return xReturn;
;;;686    	}
00001a  bd70              POP      {r4-r6,pc}
                  |L31.28|
00001c  b672              CPSID    i                     ;656
                  |L31.30|
00001e  e7fe              B        |L31.30|
                  |L31.32|
000020  4629              MOV      r1,r5                 ;670
000022  4620              MOV      r0,r4                 ;670
000024  f7fffffe          BL       xQueueSemaphoreTake
000028  2800              CMP      r0,#0                 ;675
00002a  d0f6              BEQ      |L31.26|
00002c  68e1              LDR      r1,[r4,#0xc]          ;677
00002e  1c49              ADDS     r1,r1,#1              ;677
000030  60e1              STR      r1,[r4,#0xc]          ;677
000032  bd70              POP      {r4-r6,pc}
;;;687    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  xQueueRegistry
                          %        64

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\ThirdParty\\FreeRTOS\\Source\\queue.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_queue_c_48e2f297____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___7_queue_c_48e2f297____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_queue_c_48e2f297____REVSH|
#line 402
|__asm___7_queue_c_48e2f297____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
