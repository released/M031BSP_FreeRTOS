; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\tasks.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\tasks.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -I..\..\..\ThirdParty\FreeRTOS\Source\include -I..\..\..\ThirdParty\FreeRTOS\Demo\Common\include -I..\..\..\ThirdParty\FreeRTOS\Source\portable\RVDS\ARM_CM0 -I..\..\..\ThirdParty\FreeRTOS -I..\..\Template -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\tasks.crf ..\..\..\ThirdParty\FreeRTOS\Source\tasks.c]
                          THUMB

                          AREA ||i.eTaskGetState||, CODE, READONLY, ALIGN=2

                  eTaskGetState PROC
;;;1377   
;;;1378   	eTaskState eTaskGetState( TaskHandle_t xTask )
000000  b5f8              PUSH     {r3-r7,lr}
;;;1379   	{
000002  0004              MOVS     r4,r0
000004  d005              BEQ      |L1.18|
;;;1380   	eTaskState eReturn;
;;;1381   	List_t const * pxStateList, *pxDelayedList, *pxOverflowedDelayedList;
;;;1382   	const TCB_t * const pxTCB = xTask;
;;;1383   
;;;1384   		configASSERT( pxTCB );
;;;1385   
;;;1386   		if( pxTCB == pxCurrentTCB )
000006  4e15              LDR      r6,|L1.92|
000008  6830              LDR      r0,[r6,#0]  ; pxCurrentTCB
00000a  4284              CMP      r4,r0
00000c  d103              BNE      |L1.22|
;;;1387   		{
;;;1388   			/* The task calling this function is querying its own state. */
;;;1389   			eReturn = eRunning;
00000e  2000              MOVS     r0,#0
;;;1390   		}
;;;1391   		else
;;;1392   		{
;;;1393   			taskENTER_CRITICAL();
;;;1394   			{
;;;1395   				pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
;;;1396   				pxDelayedList = pxDelayedTaskList;
;;;1397   				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
;;;1398   			}
;;;1399   			taskEXIT_CRITICAL();
;;;1400   
;;;1401   			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
;;;1402   			{
;;;1403   				/* The task being queried is referenced from one of the Blocked
;;;1404   				lists. */
;;;1405   				eReturn = eBlocked;
;;;1406   			}
;;;1407   
;;;1408   			#if ( INCLUDE_vTaskSuspend == 1 )
;;;1409   				else if( pxStateList == &xSuspendedTaskList )
;;;1410   				{
;;;1411   					/* The task being queried is referenced from the suspended
;;;1412   					list.  Is it genuinely suspended or is it blocked
;;;1413   					indefinitely? */
;;;1414   					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
;;;1415   					{
;;;1416   						#if( configUSE_TASK_NOTIFICATIONS == 1 )
;;;1417   						{
;;;1418   							/* The task does not appear on the event list item of
;;;1419   							and of the RTOS objects, but could still be in the
;;;1420   							blocked state if it is waiting on its notification
;;;1421   							rather than waiting on an object. */
;;;1422   							if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
;;;1423   							{
;;;1424   								eReturn = eBlocked;
;;;1425   							}
;;;1426   							else
;;;1427   							{
;;;1428   								eReturn = eSuspended;
;;;1429   							}
;;;1430   						}
;;;1431   						#else
;;;1432   						{
;;;1433   							eReturn = eSuspended;
;;;1434   						}
;;;1435   						#endif
;;;1436   					}
;;;1437   					else
;;;1438   					{
;;;1439   						eReturn = eBlocked;
;;;1440   					}
;;;1441   				}
;;;1442   			#endif
;;;1443   
;;;1444   			#if ( INCLUDE_vTaskDelete == 1 )
;;;1445   				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
;;;1446   				{
;;;1447   					/* The task being queried is referenced from the deleted
;;;1448   					tasks list, or it is not referenced from any lists at
;;;1449   					all. */
;;;1450   					eReturn = eDeleted;
;;;1451   				}
;;;1452   			#endif
;;;1453   
;;;1454   			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
;;;1455   			{
;;;1456   				/* If the task is not in any other state, it must be in the
;;;1457   				Ready (including pending ready) state. */
;;;1458   				eReturn = eReady;
;;;1459   			}
;;;1460   		}
;;;1461   
;;;1462   		return eReturn;
;;;1463   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
000010  bdf8              POP      {r3-r7,pc}
                  |L1.18|
000012  b672              CPSID    i                     ;1384
                  |L1.20|
000014  e7fe              B        |L1.20|
                  |L1.22|
000016  f7fffffe          BL       vPortEnterCritical
00001a  6965              LDR      r5,[r4,#0x14]         ;1396
00001c  6b77              LDR      r7,[r6,#0x34]         ;1396  ; pxDelayedTaskList
00001e  6bb6              LDR      r6,[r6,#0x38]         ;1397  ; pxOverflowDelayedTaskList
000020  f7fffffe          BL       vPortExitCritical
000024  42bd              CMP      r5,r7                 ;1401
000026  d001              BEQ      |L1.44|
000028  42b5              CMP      r5,r6                 ;1401
00002a  d101              BNE      |L1.48|
                  |L1.44|
00002c  2002              MOVS     r0,#2                 ;1405
00002e  bdf8              POP      {r3-r7,pc}
                  |L1.48|
000030  480b              LDR      r0,|L1.96|
000032  4285              CMP      r5,r0                 ;1409
000034  d108              BNE      |L1.72|
000036  6aa0              LDR      r0,[r4,#0x28]         ;1414
000038  2800              CMP      r0,#0                 ;1414
00003a  d1f7              BNE      |L1.44|
00003c  3440              ADDS     r4,r4,#0x40           ;1414
00003e  7e20              LDRB     r0,[r4,#0x18]         ;1422
000040  2801              CMP      r0,#1                 ;1422
000042  d0f3              BEQ      |L1.44|
000044  2003              MOVS     r0,#3                 ;1428
000046  bdf8              POP      {r3-r7,pc}
                  |L1.72|
000048  4805              LDR      r0,|L1.96|
00004a  3814              SUBS     r0,r0,#0x14           ;1445
00004c  4285              CMP      r5,r0                 ;1445
00004e  d003              BEQ      |L1.88|
000050  2d00              CMP      r5,#0                 ;1445
000052  d001              BEQ      |L1.88|
000054  2001              MOVS     r0,#1                 ;1458
000056  bdf8              POP      {r3-r7,pc}
                  |L1.88|
000058  2004              MOVS     r0,#4                 ;1450
00005a  bdf8              POP      {r3-r7,pc}
;;;1464   
                          ENDP

                  |L1.92|
                          DCD      ||.data||
                  |L1.96|
                          DCD      ||.bss||+0xb4

                          AREA ||i.pcTaskGetName||, CODE, READONLY, ALIGN=2

                  pcTaskGetName PROC
;;;2336   
;;;2337   char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  2800              CMP      r0,#0
;;;2338   {
000002  d101              BNE      |L2.8|
;;;2339   TCB_t *pxTCB;
;;;2340   
;;;2341   	/* If null is passed in here then the name of the calling task is being
;;;2342   	queried. */
;;;2343   	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
000004  4803              LDR      r0,|L2.20|
000006  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
                  |L2.8|
;;;2344   	configASSERT( pxTCB );
000008  2800              CMP      r0,#0
00000a  d001              BEQ      |L2.16|
00000c  3034              ADDS     r0,r0,#0x34
;;;2345   	return &( pxTCB->pcTaskName[ 0 ] );
;;;2346   }
00000e  4770              BX       lr
                  |L2.16|
000010  b672              CPSID    i                     ;2344
                  |L2.18|
000012  e7fe              B        |L2.18|
;;;2347   /*-----------------------------------------------------------*/
                          ENDP

                  |L2.20|
                          DCD      ||.data||

                          AREA ||i.prvAddCurrentTaskToDelayedList||, CODE, READONLY, ALIGN=2

                  prvAddCurrentTaskToDelayedList PROC
;;;5079   
;;;5080   static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
000000  b5f8              PUSH     {r3-r7,lr}
;;;5081   {
;;;5082   TickType_t xTimeToWake;
;;;5083   const TickType_t xConstTickCount = xTickCount;
000002  4e13              LDR      r6,|L3.80|
000004  460f              MOV      r7,r1                 ;5081
000006  68f5              LDR      r5,[r6,#0xc]  ; xTickCount
000008  4604              MOV      r4,r0                 ;5081
;;;5084   
;;;5085   	#if( INCLUDE_xTaskAbortDelay == 1 )
;;;5086   	{
;;;5087   		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
;;;5088   		reset to pdFALSE so it can be detected as having been set to pdTRUE
;;;5089   		when the task leaves the Blocked state. */
;;;5090   		pxCurrentTCB->ucDelayAborted = pdFALSE;
;;;5091   	}
;;;5092   	#endif
;;;5093   
;;;5094   	/* Remove the task from the ready list before adding it to the blocked list
;;;5095   	as the same list item is used for both lists. */
;;;5096   	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
00000a  6830              LDR      r0,[r6,#0]  ; pxCurrentTCB
00000c  1d00              ADDS     r0,r0,#4
00000e  f7fffffe          BL       uxListRemove
;;;5097   	{
;;;5098   		/* The current task must be in a ready list, so there is no need to
;;;5099   		check, and the port reset macro can be called directly. */
;;;5100   		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
;;;5101   	}
;;;5102   	else
;;;5103   	{
;;;5104   		mtCOVERAGE_TEST_MARKER();
;;;5105   	}
;;;5106   
;;;5107   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;5108   	{
;;;5109   		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
000012  1c60              ADDS     r0,r4,#1
000014  d107              BNE      |L3.38|
000016  2f00              CMP      r7,#0
000018  d005              BEQ      |L3.38|
;;;5110   		{
;;;5111   			/* Add the task to the suspended task list instead of a delayed task
;;;5112   			list to ensure it is not woken by a timing event.  It will block
;;;5113   			indefinitely. */
;;;5114   			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
00001a  6831              LDR      r1,[r6,#0]  ; pxCurrentTCB
00001c  480d              LDR      r0,|L3.84|
00001e  1d09              ADDS     r1,r1,#4
000020  f7fffffe          BL       vListInsertEnd
;;;5115   		}
;;;5116   		else
;;;5117   		{
;;;5118   			/* Calculate the time at which the task should be woken if the event
;;;5119   			does not occur.  This may overflow but this doesn't matter, the
;;;5120   			kernel will manage it correctly. */
;;;5121   			xTimeToWake = xConstTickCount + xTicksToWait;
;;;5122   
;;;5123   			/* The list item will be inserted in wake time order. */
;;;5124   			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
;;;5125   
;;;5126   			if( xTimeToWake < xConstTickCount )
;;;5127   			{
;;;5128   				/* Wake time has overflowed.  Place this item in the overflow
;;;5129   				list. */
;;;5130   				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;5131   			}
;;;5132   			else
;;;5133   			{
;;;5134   				/* The wake time has not overflowed, so the current block list
;;;5135   				is used. */
;;;5136   				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;5137   
;;;5138   				/* If the task entering the blocked state was placed at the
;;;5139   				head of the list of blocked tasks then xNextTaskUnblockTime
;;;5140   				needs to be updated too. */
;;;5141   				if( xTimeToWake < xNextTaskUnblockTime )
;;;5142   				{
;;;5143   					xNextTaskUnblockTime = xTimeToWake;
;;;5144   				}
;;;5145   				else
;;;5146   				{
;;;5147   					mtCOVERAGE_TEST_MARKER();
;;;5148   				}
;;;5149   			}
;;;5150   		}
;;;5151   	}
;;;5152   	#else /* INCLUDE_vTaskSuspend */
;;;5153   	{
;;;5154   		/* Calculate the time at which the task should be woken if the event
;;;5155   		does not occur.  This may overflow but this doesn't matter, the kernel
;;;5156   		will manage it correctly. */
;;;5157   		xTimeToWake = xConstTickCount + xTicksToWait;
;;;5158   
;;;5159   		/* The list item will be inserted in wake time order. */
;;;5160   		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
;;;5161   
;;;5162   		if( xTimeToWake < xConstTickCount )
;;;5163   		{
;;;5164   			/* Wake time has overflowed.  Place this item in the overflow list. */
;;;5165   			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;5166   		}
;;;5167   		else
;;;5168   		{
;;;5169   			/* The wake time has not overflowed, so the current block list is used. */
;;;5170   			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;5171   
;;;5172   			/* If the task entering the blocked state was placed at the head of the
;;;5173   			list of blocked tasks then xNextTaskUnblockTime needs to be updated
;;;5174   			too. */
;;;5175   			if( xTimeToWake < xNextTaskUnblockTime )
;;;5176   			{
;;;5177   				xNextTaskUnblockTime = xTimeToWake;
;;;5178   			}
;;;5179   			else
;;;5180   			{
;;;5181   				mtCOVERAGE_TEST_MARKER();
;;;5182   			}
;;;5183   		}
;;;5184   
;;;5185   		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
;;;5186   		( void ) xCanBlockIndefinitely;
;;;5187   	}
;;;5188   	#endif /* INCLUDE_vTaskSuspend */
;;;5189   }
000024  bdf8              POP      {r3-r7,pc}
                  |L3.38|
000026  6830              LDR      r0,[r6,#0]            ;5124  ; pxCurrentTCB
000028  192c              ADDS     r4,r5,r4              ;5121
00002a  6044              STR      r4,[r0,#4]            ;5126
00002c  6831              LDR      r1,[r6,#0]            ;5136  ; pxCurrentTCB
00002e  42ac              CMP      r4,r5                 ;5126
000030  d204              BCS      |L3.60|
000032  6bb0              LDR      r0,[r6,#0x38]         ;5130  ; pxOverflowDelayedTaskList
000034  1d09              ADDS     r1,r1,#4              ;5130
000036  f7fffffe          BL       vListInsert
                  |L3.58|
00003a  bdf8              POP      {r3-r7,pc}
                  |L3.60|
00003c  6b70              LDR      r0,[r6,#0x34]         ;5136  ; pxDelayedTaskList
00003e  1d09              ADDS     r1,r1,#4              ;5136
000040  f7fffffe          BL       vListInsert
000044  6ab0              LDR      r0,[r6,#0x28]         ;5141  ; xNextTaskUnblockTime
000046  4284              CMP      r4,r0                 ;5141
000048  d2f7              BCS      |L3.58|
00004a  62b4              STR      r4,[r6,#0x28]         ;5143  ; xNextTaskUnblockTime
00004c  bdf8              POP      {r3-r7,pc}
;;;5190   
                          ENDP

00004e  0000              DCW      0x0000
                  |L3.80|
                          DCD      ||.data||
                  |L3.84|
                          DCD      ||.bss||+0xb4

                          AREA ||i.prvAddNewTaskToReadyList||, CODE, READONLY, ALIGN=2

                  prvAddNewTaskToReadyList PROC
;;;1071   
;;;1072   static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
000000  b5f8              PUSH     {r3-r7,lr}
;;;1073   {
000002  4605              MOV      r5,r0
;;;1074   	/* Ensure interrupts don't access the task lists while the lists are being
;;;1075   	updated. */
;;;1076   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1077   	{
;;;1078   		uxCurrentNumberOfTasks++;
000008  4e2a              LDR      r6,|L4.180|
00000a  68b0              LDR      r0,[r6,#8]  ; uxCurrentNumberOfTasks
00000c  1c40              ADDS     r0,r0,#1
00000e  60b0              STR      r0,[r6,#8]  ; uxCurrentNumberOfTasks
;;;1079   		if( pxCurrentTCB == NULL )
000010  6830              LDR      r0,[r6,#0]  ; pxCurrentTCB
000012  4f29              LDR      r7,|L4.184|
000014  2800              CMP      r0,#0
000016  d003              BEQ      |L4.32|
;;;1080   		{
;;;1081   			/* There are no other tasks, or all the other tasks are in
;;;1082   			the suspended state - make this the current task. */
;;;1083   			pxCurrentTCB = pxNewTCB;
;;;1084   
;;;1085   			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
;;;1086   			{
;;;1087   				/* This is the first task to be created so do the preliminary
;;;1088   				initialisation required.  We will not recover if this call
;;;1089   				fails, but we will report the failure. */
;;;1090   				prvInitialiseTaskLists();
;;;1091   			}
;;;1092   			else
;;;1093   			{
;;;1094   				mtCOVERAGE_TEST_MARKER();
;;;1095   			}
;;;1096   		}
;;;1097   		else
;;;1098   		{
;;;1099   			/* If the scheduler is not already running, make this task the
;;;1100   			current task if it is the highest priority task to be created
;;;1101   			so far. */
;;;1102   			if( xSchedulerRunning == pdFALSE )
000018  6970              LDR      r0,[r6,#0x14]  ; xSchedulerRunning
00001a  2800              CMP      r0,#0
00001c  d027              BEQ      |L4.110|
00001e  e02c              B        |L4.122|
                  |L4.32|
000020  6035              STR      r5,[r6,#0]            ;1083  ; pxCurrentTCB
000022  68b0              LDR      r0,[r6,#8]            ;1085  ; uxCurrentNumberOfTasks
000024  2801              CMP      r0,#1                 ;1085
000026  d128              BNE      |L4.122|
000028  2400              MOVS     r4,#0                 ;1085
                  |L4.42|
00002a  2014              MOVS     r0,#0x14              ;1085
00002c  4360              MULS     r0,r4,r0              ;1085
00002e  19c0              ADDS     r0,r0,r7              ;1085
000030  f7fffffe          BL       vListInitialise
000034  1c64              ADDS     r4,r4,#1              ;1085
000036  2c05              CMP      r4,#5                 ;1085
000038  d3f7              BCC      |L4.42|
00003a  481f              LDR      r0,|L4.184|
00003c  3064              ADDS     r0,r0,#0x64           ;1085
00003e  f7fffffe          BL       vListInitialise
000042  481d              LDR      r0,|L4.184|
000044  3078              ADDS     r0,r0,#0x78           ;1085
000046  f7fffffe          BL       vListInitialise
00004a  481b              LDR      r0,|L4.184|
00004c  308c              ADDS     r0,r0,#0x8c           ;1085
00004e  f7fffffe          BL       vListInitialise
000052  4819              LDR      r0,|L4.184|
000054  30a0              ADDS     r0,r0,#0xa0           ;1085
000056  f7fffffe          BL       vListInitialise
00005a  4817              LDR      r0,|L4.184|
00005c  30b4              ADDS     r0,r0,#0xb4           ;1085
00005e  f7fffffe          BL       vListInitialise
000062  4815              LDR      r0,|L4.184|
000064  3064              ADDS     r0,r0,#0x64           ;1085
000066  6370              STR      r0,[r6,#0x34]         ;1085  ; pxDelayedTaskList
000068  3014              ADDS     r0,r0,#0x14           ;1085
00006a  63b0              STR      r0,[r6,#0x38]         ;1085  ; pxOverflowDelayedTaskList
00006c  e005              B        |L4.122|
                  |L4.110|
;;;1103   			{
;;;1104   				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
00006e  6830              LDR      r0,[r6,#0]  ; pxCurrentTCB
000070  6ae9              LDR      r1,[r5,#0x2c]
000072  6ac0              LDR      r0,[r0,#0x2c]
000074  4288              CMP      r0,r1
000076  d800              BHI      |L4.122|
;;;1105   				{
;;;1106   					pxCurrentTCB = pxNewTCB;
000078  6035              STR      r5,[r6,#0]  ; pxCurrentTCB
                  |L4.122|
;;;1107   				}
;;;1108   				else
;;;1109   				{
;;;1110   					mtCOVERAGE_TEST_MARKER();
;;;1111   				}
;;;1112   			}
;;;1113   			else
;;;1114   			{
;;;1115   				mtCOVERAGE_TEST_MARKER();
;;;1116   			}
;;;1117   		}
;;;1118   
;;;1119   		uxTaskNumber++;
00007a  6a70              LDR      r0,[r6,#0x24]  ; uxTaskNumber
00007c  1c40              ADDS     r0,r0,#1
;;;1120   
;;;1121   		#if ( configUSE_TRACE_FACILITY == 1 )
;;;1122   		{
;;;1123   			/* Add a counter into the TCB for tracing only. */
;;;1124   			pxNewTCB->uxTCBNumber = uxTaskNumber;
00007e  6270              STR      r0,[r6,#0x24]  ; uxTaskNumber
;;;1125   		}
;;;1126   		#endif /* configUSE_TRACE_FACILITY */
;;;1127   		traceTASK_CREATE( pxNewTCB );
;;;1128   
;;;1129   		prvAddTaskToReadyList( pxNewTCB );
000080  6468              STR      r0,[r5,#0x44]
000082  6ae8              LDR      r0,[r5,#0x2c]
000084  6931              LDR      r1,[r6,#0x10]  ; uxTopReadyPriority
000086  4288              CMP      r0,r1
000088  d900              BLS      |L4.140|
00008a  6130              STR      r0,[r6,#0x10]  ; uxTopReadyPriority
                  |L4.140|
00008c  2114              MOVS     r1,#0x14
00008e  4348              MULS     r0,r1,r0
000090  19c0              ADDS     r0,r0,r7
000092  1d29              ADDS     r1,r5,#4
000094  f7fffffe          BL       vListInsertEnd
;;;1130   
;;;1131   		portSETUP_TCB( pxNewTCB );
;;;1132   	}
;;;1133   	taskEXIT_CRITICAL();
000098  f7fffffe          BL       vPortExitCritical
;;;1134   
;;;1135   	if( xSchedulerRunning != pdFALSE )
00009c  6970              LDR      r0,[r6,#0x14]  ; xSchedulerRunning
00009e  2800              CMP      r0,#0
0000a0  d006              BEQ      |L4.176|
;;;1136   	{
;;;1137   		/* If the created task is of a higher priority than the current task
;;;1138   		then it should run now. */
;;;1139   		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
0000a2  6830              LDR      r0,[r6,#0]  ; pxCurrentTCB
0000a4  6ae9              LDR      r1,[r5,#0x2c]
0000a6  6ac0              LDR      r0,[r0,#0x2c]
0000a8  4288              CMP      r0,r1
0000aa  d201              BCS      |L4.176|
;;;1140   		{
;;;1141   			taskYIELD_IF_USING_PREEMPTION();
0000ac  f7fffffe          BL       vPortYield
                  |L4.176|
;;;1142   		}
;;;1143   		else
;;;1144   		{
;;;1145   			mtCOVERAGE_TEST_MARKER();
;;;1146   		}
;;;1147   	}
;;;1148   	else
;;;1149   	{
;;;1150   		mtCOVERAGE_TEST_MARKER();
;;;1151   	}
;;;1152   }
0000b0  bdf8              POP      {r3-r7,pc}
;;;1153   /*-----------------------------------------------------------*/
                          ENDP

0000b2  0000              DCW      0x0000
                  |L4.180|
                          DCD      ||.data||
                  |L4.184|
                          DCD      ||.bss||

                          AREA ||i.prvDeleteTCB||, CODE, READONLY, ALIGN=1

                  prvDeleteTCB PROC
;;;3824   
;;;3825   	static void prvDeleteTCB( TCB_t *pxTCB )
000000  b510              PUSH     {r4,lr}
;;;3826   	{
000002  4604              MOV      r4,r0
;;;3827   		/* This call is required specifically for the TriCore port.  It must be
;;;3828   		above the vPortFree() calls.  The call is also used by ports/demos that
;;;3829   		want to allocate and clean RAM statically. */
;;;3830   		portCLEAN_UP_TCB( pxTCB );
;;;3831   
;;;3832   		/* Free up the memory allocated by the scheduler for the task.  It is up
;;;3833   		to the task to free any memory allocated at the application level. */
;;;3834   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;3835   		{
;;;3836   			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
;;;3837   		}
;;;3838   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;3839   
;;;3840   		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
;;;3841   		{
;;;3842   			/* The task can only have been allocated dynamically - free both
;;;3843   			the stack and TCB. */
;;;3844   			vPortFree( pxTCB->pxStack );
000004  6b00              LDR      r0,[r0,#0x30]
000006  f7fffffe          BL       vPortFree
;;;3845   			vPortFree( pxTCB );
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       vPortFree
;;;3846   		}
;;;3847   		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
;;;3848   		{
;;;3849   			/* The task could have been allocated statically or dynamically, so
;;;3850   			check what was statically allocated before trying to free the
;;;3851   			memory. */
;;;3852   			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
;;;3853   			{
;;;3854   				/* Both the stack and TCB were allocated dynamically, so both
;;;3855   				must be freed. */
;;;3856   				vPortFree( pxTCB->pxStack );
;;;3857   				vPortFree( pxTCB );
;;;3858   			}
;;;3859   			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
;;;3860   			{
;;;3861   				/* Only the stack was statically allocated, so the TCB is the
;;;3862   				only memory that must be freed. */
;;;3863   				vPortFree( pxTCB );
;;;3864   			}
;;;3865   			else
;;;3866   			{
;;;3867   				/* Neither the stack nor the TCB were allocated dynamically, so
;;;3868   				nothing needs to be freed. */
;;;3869   				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
;;;3870   				mtCOVERAGE_TEST_MARKER();
;;;3871   			}
;;;3872   		}
;;;3873   		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;3874   	}
000010  bd10              POP      {r4,pc}
;;;3875   
                          ENDP


                          AREA ||i.prvIdleTask||, CODE, READONLY, ALIGN=2

                  prvIdleTask PROC
;;;3332    */
;;;3333   static portTASK_FUNCTION( prvIdleTask, pvParameters )
000000  4e0f              LDR      r6,|L6.64|
000002  4d10              LDR      r5,|L6.68|
;;;3334   {
;;;3335   	/* Stop warnings. */
;;;3336   	( void ) pvParameters;
;;;3337   
;;;3338   	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
;;;3339   	SCHEDULER IS STARTED. **/
;;;3340   
;;;3341   	/* In case a task that has a secure context deletes itself, in which case
;;;3342   	the idle task is responsible for deleting the task's secure context, if
;;;3343   	any. */
;;;3344   	portALLOCATE_SECURE_CONTEXT( configMINIMAL_SECURE_STACK_SIZE );
;;;3345   
;;;3346   	for( ;; )
;;;3347   	{
;;;3348   		/* See if any tasks have deleted themselves - if so then the idle task
;;;3349   		is responsible for freeing the deleted task's TCB and stack. */
;;;3350   		prvCheckTasksWaitingTermination();
;;;3351   
;;;3352   		#if ( configUSE_PREEMPTION == 0 )
;;;3353   		{
;;;3354   			/* If we are not using preemption we keep forcing a task switch to
;;;3355   			see if any other task has become available.  If we are using
;;;3356   			preemption we don't need to do this as any task becoming available
;;;3357   			will automatically get the processor anyway. */
;;;3358   			taskYIELD();
;;;3359   		}
;;;3360   		#endif /* configUSE_PREEMPTION */
;;;3361   
;;;3362   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
;;;3363   		{
;;;3364   			/* When using preemption tasks of equal priority will be
;;;3365   			timesliced.  If a task that is sharing the idle priority is ready
;;;3366   			to run then the idle task should yield before the end of the
;;;3367   			timeslice.
;;;3368   
;;;3369   			A critical region is not required here as we are just reading from
;;;3370   			the list, and an occasional incorrect value will not matter.  If
;;;3371   			the ready list at the idle priority contains more than one task
;;;3372   			then a task other than the idle task is ready to execute. */
;;;3373   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
000004  4637              MOV      r7,r6
000006  3fa0              SUBS     r7,r7,#0xa0
000008  e011              B        |L6.46|
                  |L6.10|
00000a  f7fffffe          BL       vPortEnterCritical
00000e  68f0              LDR      r0,[r6,#0xc]  ; xTasksWaitingTermination
000010  68c4              LDR      r4,[r0,#0xc]
000012  1d20              ADDS     r0,r4,#4
000014  f7fffffe          BL       uxListRemove
000018  68a8              LDR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
00001a  1e40              SUBS     r0,r0,#1
00001c  60a8              STR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
00001e  6868              LDR      r0,[r5,#4]  ; uxDeletedTasksWaitingCleanUp
000020  1e40              SUBS     r0,r0,#1
000022  6068              STR      r0,[r5,#4]  ; uxDeletedTasksWaitingCleanUp
000024  f7fffffe          BL       vPortExitCritical
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       prvDeleteTCB
                  |L6.46|
00002e  6868              LDR      r0,[r5,#4]  ; uxDeletedTasksWaitingCleanUp
000030  2800              CMP      r0,#0
000032  d1ea              BNE      |L6.10|
000034  6838              LDR      r0,[r7,#0]  ; pxReadyTasksLists
000036  2801              CMP      r0,#1
000038  d9f9              BLS      |L6.46|
;;;3374   			{
;;;3375   				taskYIELD();
00003a  f7fffffe          BL       vPortYield
00003e  e7f6              B        |L6.46|
;;;3376   			}
;;;3377   			else
;;;3378   			{
;;;3379   				mtCOVERAGE_TEST_MARKER();
;;;3380   			}
;;;3381   		}
;;;3382   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
;;;3383   
;;;3384   		#if ( configUSE_IDLE_HOOK == 1 )
;;;3385   		{
;;;3386   			extern void vApplicationIdleHook( void );
;;;3387   
;;;3388   			/* Call the user defined function from within the idle task.  This
;;;3389   			allows the application designer to add background functionality
;;;3390   			without the overhead of a separate task.
;;;3391   			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
;;;3392   			CALL A FUNCTION THAT MIGHT BLOCK. */
;;;3393   			vApplicationIdleHook();
;;;3394   		}
;;;3395   		#endif /* configUSE_IDLE_HOOK */
;;;3396   
;;;3397   		/* This conditional compilation should use inequality to 0, not equality
;;;3398   		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
;;;3399   		user defined low power mode	implementations require
;;;3400   		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
;;;3401   		#if ( configUSE_TICKLESS_IDLE != 0 )
;;;3402   		{
;;;3403   		TickType_t xExpectedIdleTime;
;;;3404   
;;;3405   			/* It is not desirable to suspend then resume the scheduler on
;;;3406   			each iteration of the idle task.  Therefore, a preliminary
;;;3407   			test of the expected idle time is performed without the
;;;3408   			scheduler suspended.  The result here is not necessarily
;;;3409   			valid. */
;;;3410   			xExpectedIdleTime = prvGetExpectedIdleTime();
;;;3411   
;;;3412   			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;3413   			{
;;;3414   				vTaskSuspendAll();
;;;3415   				{
;;;3416   					/* Now the scheduler is suspended, the expected idle
;;;3417   					time can be sampled again, and this time its value can
;;;3418   					be used. */
;;;3419   					configASSERT( xNextTaskUnblockTime >= xTickCount );
;;;3420   					xExpectedIdleTime = prvGetExpectedIdleTime();
;;;3421   
;;;3422   					/* Define the following macro to set xExpectedIdleTime to 0
;;;3423   					if the application does not want
;;;3424   					portSUPPRESS_TICKS_AND_SLEEP() to be called. */
;;;3425   					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
;;;3426   
;;;3427   					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;3428   					{
;;;3429   						traceLOW_POWER_IDLE_BEGIN();
;;;3430   						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
;;;3431   						traceLOW_POWER_IDLE_END();
;;;3432   					}
;;;3433   					else
;;;3434   					{
;;;3435   						mtCOVERAGE_TEST_MARKER();
;;;3436   					}
;;;3437   				}
;;;3438   				( void ) xTaskResumeAll();
;;;3439   			}
;;;3440   			else
;;;3441   			{
;;;3442   				mtCOVERAGE_TEST_MARKER();
;;;3443   			}
;;;3444   		}
;;;3445   		#endif /* configUSE_TICKLESS_IDLE */
;;;3446   	}
;;;3447   }
;;;3448   /*-----------------------------------------------------------*/
                          ENDP

                  |L6.64|
                          DCD      ||.bss||+0xa0
                  |L6.68|
                          DCD      ||.data||

                          AREA ||i.prvInitialiseNewTask||, CODE, READONLY, ALIGN=1

                  prvInitialiseNewTask PROC
;;;820    
;;;821    static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
000000  b5ff              PUSH     {r0-r7,lr}
;;;822    									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;;;823    									const uint32_t ulStackDepth,
;;;824    									void * const pvParameters,
;;;825    									UBaseType_t uxPriority,
;;;826    									TaskHandle_t * const pxCreatedTask,
;;;827    									TCB_t *pxNewTCB,
;;;828    									const MemoryRegion_t * const xRegions )
;;;829    {
000002  b081              SUB      sp,sp,#4
000004  460e              MOV      r6,r1
;;;830    StackType_t *pxTopOfStack;
;;;831    UBaseType_t x;
;;;832    
;;;833    	#if( portUSING_MPU_WRAPPERS == 1 )
;;;834    		/* Should the task be created in privileged mode? */
;;;835    		BaseType_t xRunPrivileged;
;;;836    		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
;;;837    		{
;;;838    			xRunPrivileged = pdTRUE;
;;;839    		}
;;;840    		else
;;;841    		{
;;;842    			xRunPrivileged = pdFALSE;
;;;843    		}
;;;844    		uxPriority &= ~portPRIVILEGE_BIT;
;;;845    	#endif /* portUSING_MPU_WRAPPERS == 1 */
;;;846    
;;;847    	/* Avoid dependency on memset() if it is not required. */
;;;848    	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
;;;849    	{
;;;850    		/* Fill the stack with a known value to assist debugging. */
;;;851    		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
000006  0091              LSLS     r1,r2,#2
000008  9c0c              LDR      r4,[sp,#0x30]
00000a  460f              MOV      r7,r1
00000c  9d0a              LDR      r5,[sp,#0x28]
00000e  22a5              MOVS     r2,#0xa5
000010  6b20              LDR      r0,[r4,#0x30]
000012  f7fffffe          BL       __aeabi_memset
;;;852    	}
;;;853    	#endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
;;;854    
;;;855    	/* Calculate the top of stack address.  This depends on whether the stack
;;;856    	grows from high memory to low (as per the 80x86) or vice versa.
;;;857    	portSTACK_GROWTH is used to make the result positive or negative as required
;;;858    	by the port. */
;;;859    	#if( portSTACK_GROWTH < 0 )
;;;860    	{
;;;861    		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
000016  6b20              LDR      r0,[r4,#0x30]
000018  1f3f              SUBS     r7,r7,#4
00001a  19c0              ADDS     r0,r0,r7
;;;862    		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
00001c  08c0              LSRS     r0,r0,#3
00001e  00c0              LSLS     r0,r0,#3
;;;863    
;;;864    		/* Check the alignment of the calculated top of stack is correct. */
;;;865    		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
000020  9000              STR      r0,[sp,#0]
000022  0740              LSLS     r0,r0,#29
000024  d001              BEQ      |L7.42|
000026  b672              CPSID    i
                  |L7.40|
000028  e7fe              B        |L7.40|
                  |L7.42|
;;;866    
;;;867    		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
;;;868    		{
;;;869    			/* Also record the stack's high address, which may assist
;;;870    			debugging. */
;;;871    			pxNewTCB->pxEndOfStack = pxTopOfStack;
;;;872    		}
;;;873    		#endif /* configRECORD_STACK_HIGH_ADDRESS */
;;;874    	}
;;;875    	#else /* portSTACK_GROWTH */
;;;876    	{
;;;877    		pxTopOfStack = pxNewTCB->pxStack;
;;;878    
;;;879    		/* Check the alignment of the stack buffer is correct. */
;;;880    		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;881    
;;;882    		/* The other extreme of the stack space is required if stack checking is
;;;883    		performed. */
;;;884    		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
;;;885    	}
;;;886    	#endif /* portSTACK_GROWTH */
;;;887    
;;;888    	/* Store the task name in the TCB. */
;;;889    	if( pcName != NULL )
;;;890    	{
;;;891    		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
;;;892    		{
;;;893    			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
;;;894    
;;;895    			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
;;;896    			configMAX_TASK_NAME_LEN characters just in case the memory after the
;;;897    			string is not accessible (extremely unlikely). */
;;;898    			if( pcName[ x ] == ( char ) 0x00 )
;;;899    			{
;;;900    				break;
;;;901    			}
;;;902    			else
;;;903    			{
;;;904    				mtCOVERAGE_TEST_MARKER();
;;;905    			}
;;;906    		}
;;;907    
;;;908    		/* Ensure the name string is terminated in the case that the string length
;;;909    		was greater or equal to configMAX_TASK_NAME_LEN. */
;;;910    		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
00002a  4627              MOV      r7,r4
00002c  3740              ADDS     r7,r7,#0x40
00002e  2000              MOVS     r0,#0
000030  2e00              CMP      r6,#0                 ;889
000032  d00c              BEQ      |L7.78|
000034  2100              MOVS     r1,#0                 ;891
                  |L7.54|
000036  1863              ADDS     r3,r4,r1              ;893
000038  5c72              LDRB     r2,[r6,r1]            ;893
00003a  3320              ADDS     r3,r3,#0x20           ;893
00003c  751a              STRB     r2,[r3,#0x14]         ;893
00003e  5c72              LDRB     r2,[r6,r1]            ;898
000040  2a00              CMP      r2,#0                 ;898
000042  d002              BEQ      |L7.74|
000044  1c49              ADDS     r1,r1,#1              ;898
000046  2910              CMP      r1,#0x10              ;891
000048  d3f5              BCC      |L7.54|
                  |L7.74|
00004a  70f8              STRB     r0,[r7,#3]
00004c  e001              B        |L7.82|
                  |L7.78|
;;;911    	}
;;;912    	else
;;;913    	{
;;;914    		/* The task has not been given a name, so just ensure there is a NULL
;;;915    		terminator when it is read out. */
;;;916    		pxNewTCB->pcTaskName[ 0 ] = 0x00;
00004e  2134              MOVS     r1,#0x34
000050  5508              STRB     r0,[r1,r4]
                  |L7.82|
;;;917    	}
;;;918    
;;;919    	/* This is used as an array index so must ensure it's not too large.  First
;;;920    	remove the privilege bit if one is present. */
;;;921    	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
000052  2d05              CMP      r5,#5
000054  d300              BCC      |L7.88|
;;;922    	{
;;;923    		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
000056  2504              MOVS     r5,#4
                  |L7.88|
;;;924    	}
;;;925    	else
;;;926    	{
;;;927    		mtCOVERAGE_TEST_MARKER();
;;;928    	}
;;;929    
;;;930    	pxNewTCB->uxPriority = uxPriority;
;;;931    	#if ( configUSE_MUTEXES == 1 )
;;;932    	{
;;;933    		pxNewTCB->uxBasePriority = uxPriority;
000058  62e5              STR      r5,[r4,#0x2c]
;;;934    		pxNewTCB->uxMutexesHeld = 0;
;;;935    	}
;;;936    	#endif /* configUSE_MUTEXES */
;;;937    
;;;938    	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
00005a  64e5              STR      r5,[r4,#0x4c]
00005c  4606              MOV      r6,r0                 ;934
00005e  6520              STR      r0,[r4,#0x50]
000060  1d20              ADDS     r0,r4,#4
000062  f7fffffe          BL       vListInitialiseItem
;;;939    	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
000066  4620              MOV      r0,r4
000068  3018              ADDS     r0,r0,#0x18
00006a  f7fffffe          BL       vListInitialiseItem
;;;940    
;;;941    	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
;;;942    	back to	the containing TCB from a generic item in a list. */
;;;943    	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
00006e  6124              STR      r4,[r4,#0x10]
;;;944    
;;;945    	/* Event lists are always in priority order. */
;;;946    	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000070  2005              MOVS     r0,#5
000072  1b40              SUBS     r0,r0,r5
;;;947    	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
000074  6264              STR      r4,[r4,#0x24]
000076  61a0              STR      r0,[r4,#0x18]
;;;948    
;;;949    	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
;;;950    	{
;;;951    		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
;;;952    	}
;;;953    	#endif /* portCRITICAL_NESTING_IN_TCB */
;;;954    
;;;955    	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
;;;956    	{
;;;957    		pxNewTCB->pxTaskTag = NULL;
;;;958    	}
;;;959    	#endif /* configUSE_APPLICATION_TASK_TAG */
;;;960    
;;;961    	#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;962    	{
;;;963    		pxNewTCB->ulRunTimeCounter = 0UL;
;;;964    	}
;;;965    	#endif /* configGENERATE_RUN_TIME_STATS */
;;;966    
;;;967    	#if ( portUSING_MPU_WRAPPERS == 1 )
;;;968    	{
;;;969    		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
;;;970    	}
;;;971    	#else
;;;972    	{
;;;973    		/* Avoid compiler warning about unreferenced parameter. */
;;;974    		( void ) xRegions;
;;;975    	}
;;;976    	#endif
;;;977    
;;;978    	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
;;;979    	{
;;;980    		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
;;;981    		{
;;;982    			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
;;;983    		}
;;;984    	}
;;;985    	#endif
;;;986    
;;;987    	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
;;;988    	{
;;;989    		pxNewTCB->ulNotifiedValue = 0;
000078  6566              STR      r6,[r4,#0x54]
;;;990    		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
00007a  763e              STRB     r6,[r7,#0x18]
;;;991    	}
;;;992    	#endif
;;;993    
;;;994    	#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;995    	{
;;;996    		/* Initialise this task's Newlib reent structure. */
;;;997    		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
;;;998    	}
;;;999    	#endif
;;;1000   
;;;1001   	#if( INCLUDE_xTaskAbortDelay == 1 )
;;;1002   	{
;;;1003   		pxNewTCB->ucDelayAborted = pdFALSE;
;;;1004   	}
;;;1005   	#endif
;;;1006   
;;;1007   	/* Initialize the TCB stack to look as if the task was already running,
;;;1008   	but had been interrupted by the scheduler.  The return address is set
;;;1009   	to the start of the task function. Once the stack has been initialised
;;;1010   	the top of stack variable is updated. */
;;;1011   	#if( portUSING_MPU_WRAPPERS == 1 )
;;;1012   	{
;;;1013   		/* If the port has capability to detect stack overflow,
;;;1014   		pass the stack end address to the stack initialization
;;;1015   		function as well. */
;;;1016   		#if( portHAS_STACK_OVERFLOW_CHECKING == 1 )
;;;1017   		{
;;;1018   			#if( portSTACK_GROWTH < 0 )
;;;1019   			{
;;;1020   				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxStack, pxTaskCode, pvParameters, xRunPrivileged );
;;;1021   			}
;;;1022   			#else /* portSTACK_GROWTH */
;;;1023   			{
;;;1024   				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxEndOfStack, pxTaskCode, pvParameters, xRunPrivileged );
;;;1025   			}
;;;1026   			#endif /* portSTACK_GROWTH */
;;;1027   		}
;;;1028   		#else /* portHAS_STACK_OVERFLOW_CHECKING */
;;;1029   		{
;;;1030   			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
;;;1031   		}
;;;1032   		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
;;;1033   	}
;;;1034   	#else /* portUSING_MPU_WRAPPERS */
;;;1035   	{
;;;1036   		/* If the port has capability to detect stack overflow,
;;;1037   		pass the stack end address to the stack initialization
;;;1038   		function as well. */
;;;1039   		#if( portHAS_STACK_OVERFLOW_CHECKING == 1 )
;;;1040   		{
;;;1041   			#if( portSTACK_GROWTH < 0 )
;;;1042   			{
;;;1043   				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxStack, pxTaskCode, pvParameters );
;;;1044   			}
;;;1045   			#else /* portSTACK_GROWTH */
;;;1046   			{
;;;1047   				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxEndOfStack, pxTaskCode, pvParameters );
;;;1048   			}
;;;1049   			#endif /* portSTACK_GROWTH */
;;;1050   		}
;;;1051   		#else /* portHAS_STACK_OVERFLOW_CHECKING */
;;;1052   		{
;;;1053   			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
00007c  9a04              LDR      r2,[sp,#0x10]
00007e  9901              LDR      r1,[sp,#4]
000080  9800              LDR      r0,[sp,#0]
000082  f7fffffe          BL       pxPortInitialiseStack
;;;1054   		}
;;;1055   		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
;;;1056   	}
;;;1057   	#endif /* portUSING_MPU_WRAPPERS */
;;;1058   
;;;1059   	if( pxCreatedTask != NULL )
000086  6020              STR      r0,[r4,#0]
000088  980b              LDR      r0,[sp,#0x2c]
00008a  2800              CMP      r0,#0
00008c  d000              BEQ      |L7.144|
;;;1060   	{
;;;1061   		/* Pass the handle out in an anonymous way.  The handle can be used to
;;;1062   		change the created task's priority, delete the created task, etc.*/
;;;1063   		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
00008e  6004              STR      r4,[r0,#0]
                  |L7.144|
;;;1064   	}
;;;1065   	else
;;;1066   	{
;;;1067   		mtCOVERAGE_TEST_MARKER();
;;;1068   	}
;;;1069   }
000090  b005              ADD      sp,sp,#0x14
000092  bdf0              POP      {r4-r7,pc}
;;;1070   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvListTasksWithinSingleList||, CODE, READONLY, ALIGN=1

                  prvListTasksWithinSingleList PROC
;;;3703   
;;;3704   	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;3705   	{
;;;3706   	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
;;;3707   	UBaseType_t uxTask = 0;
;;;3708   
;;;3709   		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
000002  6808              LDR      r0,[r1,#0]
000004  b082              SUB      sp,sp,#8              ;3705
000006  460c              MOV      r4,r1                 ;3705
000008  2500              MOVS     r5,#0                 ;3707
00000a  2800              CMP      r0,#0
00000c  d021              BEQ      |L8.82|
;;;3710   		{
;;;3711   			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
00000e  6860              LDR      r0,[r4,#4]
000010  4621              MOV      r1,r4
000012  6840              LDR      r0,[r0,#4]
000014  3108              ADDS     r1,r1,#8
000016  6060              STR      r0,[r4,#4]
000018  9100              STR      r1,[sp,#0]
00001a  4288              CMP      r0,r1
00001c  d101              BNE      |L8.34|
00001e  6841              LDR      r1,[r0,#4]
000020  6061              STR      r1,[r4,#4]
                  |L8.34|
000022  6860              LDR      r0,[r4,#4]
000024  68c6              LDR      r6,[r0,#0xc]
                  |L8.38|
;;;3712   
;;;3713   			/* Populate an TaskStatus_t structure within the
;;;3714   			pxTaskStatusArray array for each task that is referenced from
;;;3715   			pxList.  See the definition of TaskStatus_t in task.h for the
;;;3716   			meaning of each TaskStatus_t structure member. */
;;;3717   			do
;;;3718   			{
;;;3719   				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000026  6860              LDR      r0,[r4,#4]
000028  6842              LDR      r2,[r0,#4]
00002a  6062              STR      r2,[r4,#4]
00002c  9800              LDR      r0,[sp,#0]
00002e  4282              CMP      r2,r0
000030  d101              BNE      |L8.54|
000032  6851              LDR      r1,[r2,#4]
000034  6061              STR      r1,[r4,#4]
                  |L8.54|
000036  6860              LDR      r0,[r4,#4]
;;;3720   				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
000038  9902              LDR      r1,[sp,#8]
00003a  68c7              LDR      r7,[r0,#0xc]
00003c  2024              MOVS     r0,#0x24
00003e  4368              MULS     r0,r5,r0
000040  1841              ADDS     r1,r0,r1
000042  2201              MOVS     r2,#1
000044  4638              MOV      r0,r7
000046  9b04              LDR      r3,[sp,#0x10]
000048  f7fffffe          BL       vTaskGetInfo
00004c  1c6d              ADDS     r5,r5,#1
;;;3721   				uxTask++;
;;;3722   			} while( pxNextTCB != pxFirstTCB );
00004e  42b7              CMP      r7,r6
000050  d1e9              BNE      |L8.38|
                  |L8.82|
;;;3723   		}
;;;3724   		else
;;;3725   		{
;;;3726   			mtCOVERAGE_TEST_MARKER();
;;;3727   		}
;;;3728   
;;;3729   		return uxTask;
000052  4628              MOV      r0,r5
;;;3730   	}
000054  b005              ADD      sp,sp,#0x14
000056  bdf0              POP      {r4-r7,pc}
;;;3731   
                          ENDP


                          AREA ||i.prvResetNextTaskUnblockTime||, CODE, READONLY, ALIGN=2

                  prvResetNextTaskUnblockTime PROC
;;;3878   
;;;3879   static void prvResetNextTaskUnblockTime( void )
000000  4806              LDR      r0,|L9.28|
;;;3880   {
;;;3881   TCB_t *pxTCB;
;;;3882   
;;;3883   	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
000002  6b41              LDR      r1,[r0,#0x34]  ; pxDelayedTaskList
000004  6809              LDR      r1,[r1,#0]
000006  2900              CMP      r1,#0
000008  d005              BEQ      |L9.22|
;;;3884   	{
;;;3885   		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
;;;3886   		the maximum possible value so it is	extremely unlikely that the
;;;3887   		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
;;;3888   		there is an item in the delayed list. */
;;;3889   		xNextTaskUnblockTime = portMAX_DELAY;
;;;3890   	}
;;;3891   	else
;;;3892   	{
;;;3893   		/* The new current delayed list is not empty, get the value of
;;;3894   		the item at the head of the delayed list.  This is the time at
;;;3895   		which the task at the head of the delayed list should be removed
;;;3896   		from the Blocked state. */
;;;3897   		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
00000a  6b41              LDR      r1,[r0,#0x34]  ; pxDelayedTaskList
00000c  68c9              LDR      r1,[r1,#0xc]
00000e  68c9              LDR      r1,[r1,#0xc]
;;;3898   		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
000010  6849              LDR      r1,[r1,#4]
                  |L9.18|
000012  6281              STR      r1,[r0,#0x28]         ;3889  ; xNextTaskUnblockTime
;;;3899   	}
;;;3900   }
000014  4770              BX       lr
                  |L9.22|
000016  2100              MOVS     r1,#0                 ;3889
000018  43c9              MVNS     r1,r1                 ;3889
00001a  e7fa              B        |L9.18|
;;;3901   /*-----------------------------------------------------------*/
                          ENDP

                  |L9.28|
                          DCD      ||.data||

                          AREA ||i.prvTaskIsTaskSuspended||, CODE, READONLY, ALIGN=2

                  prvTaskIsTaskSuspended PROC
;;;1796   
;;;1797   	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
000000  2100              MOVS     r1,#0
;;;1798   	{
;;;1799   	BaseType_t xReturn = pdFALSE;
;;;1800   	const TCB_t * const pxTCB = xTask;
;;;1801   
;;;1802   		/* Accesses xPendingReadyList so must be called from a critical
;;;1803   		section. */
;;;1804   
;;;1805   		/* It does not make sense to check if the calling task is suspended. */
;;;1806   		configASSERT( xTask );
000002  2800              CMP      r0,#0
000004  d00b              BEQ      |L10.30|
;;;1807   
;;;1808   		/* Is the task being resumed actually in the suspended list? */
;;;1809   		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
000006  4b08              LDR      r3,|L10.40|
000008  6942              LDR      r2,[r0,#0x14]
00000a  429a              CMP      r2,r3
00000c  d10a              BNE      |L10.36|
;;;1810   		{
;;;1811   			/* Has the task already been resumed from within an ISR? */
;;;1812   			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
00000e  6a80              LDR      r0,[r0,#0x28]
000010  461a              MOV      r2,r3
000012  3a28              SUBS     r2,r2,#0x28
000014  4290              CMP      r0,r2
000016  d005              BEQ      |L10.36|
;;;1813   			{
;;;1814   				/* Is it in the suspended list because it is in the	Suspended
;;;1815   				state, or because is is blocked with no timeout? */
;;;1816   				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
000018  2800              CMP      r0,#0
00001a  d002              BEQ      |L10.34|
00001c  e002              B        |L10.36|
                  |L10.30|
00001e  b672              CPSID    i                     ;1806
                  |L10.32|
000020  e7fe              B        |L10.32|
                  |L10.34|
;;;1817   				{
;;;1818   					xReturn = pdTRUE;
000022  2101              MOVS     r1,#1
                  |L10.36|
;;;1819   				}
;;;1820   				else
;;;1821   				{
;;;1822   					mtCOVERAGE_TEST_MARKER();
;;;1823   				}
;;;1824   			}
;;;1825   			else
;;;1826   			{
;;;1827   				mtCOVERAGE_TEST_MARKER();
;;;1828   			}
;;;1829   		}
;;;1830   		else
;;;1831   		{
;;;1832   			mtCOVERAGE_TEST_MARKER();
;;;1833   		}
;;;1834   
;;;1835   		return xReturn;
000024  4608              MOV      r0,r1
;;;1836   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
000026  4770              BX       lr
;;;1837   
                          ENDP

                  |L10.40|
                          DCD      ||.bss||+0xb4

                          AREA ||i.pvTaskIncrementMutexHeldCount||, CODE, READONLY, ALIGN=2

                  pvTaskIncrementMutexHeldCount PROC
;;;4547   
;;;4548   	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
000000  4904              LDR      r1,|L11.20|
;;;4549   	{
;;;4550   		/* If xSemaphoreCreateMutex() is called before any tasks have been created
;;;4551   		then pxCurrentTCB will be NULL. */
;;;4552   		if( pxCurrentTCB != NULL )
000002  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
000004  2800              CMP      r0,#0
000006  d003              BEQ      |L11.16|
;;;4553   		{
;;;4554   			( pxCurrentTCB->uxMutexesHeld )++;
000008  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
00000a  6d02              LDR      r2,[r0,#0x50]
00000c  1c52              ADDS     r2,r2,#1
00000e  6502              STR      r2,[r0,#0x50]
                  |L11.16|
;;;4555   		}
;;;4556   
;;;4557   		return pxCurrentTCB;
000010  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
;;;4558   	}
000012  4770              BX       lr
;;;4559   
                          ENDP

                  |L11.20|
                          DCD      ||.data||

                          AREA ||i.ulTaskNotifyTake||, CODE, READONLY, ALIGN=2

                  ulTaskNotifyTake PROC
;;;4564   
;;;4565   	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;4566   	{
000002  460c              MOV      r4,r1
000004  4606              MOV      r6,r0
;;;4567   	uint32_t ulReturn;
;;;4568   
;;;4569   		taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;4570   		{
;;;4571   			/* Only block if the notification count is not already non-zero. */
;;;4572   			if( pxCurrentTCB->ulNotifiedValue == 0UL )
00000a  4d14              LDR      r5,|L12.92|
00000c  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00000e  6d40              LDR      r0,[r0,#0x54]
000010  2800              CMP      r0,#0
000012  d10a              BNE      |L12.42|
;;;4573   			{
;;;4574   				/* Mark this task as waiting for a notification. */
;;;4575   				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
000014  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000016  2101              MOVS     r1,#1
000018  3040              ADDS     r0,r0,#0x40
00001a  7601              STRB     r1,[r0,#0x18]
;;;4576   
;;;4577   				if( xTicksToWait > ( TickType_t ) 0 )
00001c  2c00              CMP      r4,#0
00001e  d004              BEQ      |L12.42|
;;;4578   				{
;;;4579   					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;4580   					traceTASK_NOTIFY_TAKE_BLOCK();
;;;4581   
;;;4582   					/* All ports are written to allow a yield in a critical
;;;4583   					section (some will yield immediately, others wait until the
;;;4584   					critical section exits) - but it is not something that
;;;4585   					application code should ever do. */
;;;4586   					portYIELD_WITHIN_API();
000026  f7fffffe          BL       vPortYield
                  |L12.42|
;;;4587   				}
;;;4588   				else
;;;4589   				{
;;;4590   					mtCOVERAGE_TEST_MARKER();
;;;4591   				}
;;;4592   			}
;;;4593   			else
;;;4594   			{
;;;4595   				mtCOVERAGE_TEST_MARKER();
;;;4596   			}
;;;4597   		}
;;;4598   		taskEXIT_CRITICAL();
00002a  f7fffffe          BL       vPortExitCritical
;;;4599   
;;;4600   		taskENTER_CRITICAL();
00002e  f7fffffe          BL       vPortEnterCritical
;;;4601   		{
;;;4602   			traceTASK_NOTIFY_TAKE();
;;;4603   			ulReturn = pxCurrentTCB->ulNotifiedValue;
000032  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000034  6d44              LDR      r4,[r0,#0x54]
000036  2100              MOVS     r1,#0
;;;4604   
;;;4605   			if( ulReturn != 0UL )
000038  2c00              CMP      r4,#0
00003a  d007              BEQ      |L12.76|
;;;4606   			{
;;;4607   				if( xClearCountOnExit != pdFALSE )
00003c  2e00              CMP      r6,#0
00003e  d002              BEQ      |L12.70|
;;;4608   				{
;;;4609   					pxCurrentTCB->ulNotifiedValue = 0UL;
000040  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000042  6541              STR      r1,[r0,#0x54]
000044  e002              B        |L12.76|
                  |L12.70|
;;;4610   				}
;;;4611   				else
;;;4612   				{
;;;4613   					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
000046  682a              LDR      r2,[r5,#0]  ; pxCurrentTCB
000048  1e60              SUBS     r0,r4,#1
00004a  6550              STR      r0,[r2,#0x54]
                  |L12.76|
;;;4614   				}
;;;4615   			}
;;;4616   			else
;;;4617   			{
;;;4618   				mtCOVERAGE_TEST_MARKER();
;;;4619   			}
;;;4620   
;;;4621   			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
00004c  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00004e  3040              ADDS     r0,r0,#0x40
000050  7601              STRB     r1,[r0,#0x18]
;;;4622   		}
;;;4623   		taskEXIT_CRITICAL();
000052  f7fffffe          BL       vPortExitCritical
;;;4624   
;;;4625   		return ulReturn;
000056  4620              MOV      r0,r4
;;;4626   	}
000058  bd70              POP      {r4-r6,pc}
;;;4627   
                          ENDP

00005a  0000              DCW      0x0000
                  |L12.92|
                          DCD      ||.data||

                          AREA ||i.uxTaskGetNumberOfTasks||, CODE, READONLY, ALIGN=2

                  uxTaskGetNumberOfTasks PROC
;;;2328   
;;;2329   UBaseType_t uxTaskGetNumberOfTasks( void )
000000  4801              LDR      r0,|L13.8|
;;;2330   {
;;;2331   	/* A critical section is not required because the variables are of type
;;;2332   	BaseType_t. */
;;;2333   	return uxCurrentNumberOfTasks;
000002  6880              LDR      r0,[r0,#8]  ; uxCurrentNumberOfTasks
;;;2334   }
000004  4770              BX       lr
;;;2335   /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      ||.data||

                          AREA ||i.uxTaskGetSystemState||, CODE, READONLY, ALIGN=2

                  uxTaskGetSystemState PROC
;;;2483   
;;;2484   	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
000000  b5f8              PUSH     {r3-r7,lr}
;;;2485   	{
000002  4617              MOV      r7,r2
000004  460a              MOV      r2,r1
000006  4606              MOV      r6,r0
;;;2486   	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
000008  2400              MOVS     r4,#0
00000a  2505              MOVS     r5,#5
;;;2487   
;;;2488   		vTaskSuspendAll();
00000c  f7fffffe          BL       vTaskSuspendAll
;;;2489   		{
;;;2490   			/* Is there a space in the array for each task in the system? */
;;;2491   			if( uxArraySize >= uxCurrentNumberOfTasks )
000010  481e              LDR      r0,|L14.140|
000012  6880              LDR      r0,[r0,#8]  ; uxCurrentNumberOfTasks
000014  4282              CMP      r2,r0
000016  d334              BCC      |L14.130|
                  |L14.24|
;;;2492   			{
;;;2493   				/* Fill in an TaskStatus_t structure with information on each
;;;2494   				task in the Ready state. */
;;;2495   				do
;;;2496   				{
;;;2497   					uxQueue--;
;;;2498   					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
000018  2014              MOVS     r0,#0x14
00001a  1e6d              SUBS     r5,r5,#1
00001c  491c              LDR      r1,|L14.144|
00001e  4368              MULS     r0,r5,r0
000020  1841              ADDS     r1,r0,r1
000022  2024              MOVS     r0,#0x24
000024  4360              MULS     r0,r4,r0
000026  1980              ADDS     r0,r0,r6
000028  2201              MOVS     r2,#1
00002a  f7fffffe          BL       prvListTasksWithinSingleList
00002e  1904              ADDS     r4,r0,r4
;;;2499   
;;;2500   				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000030  2d00              CMP      r5,#0
000032  d1f1              BNE      |L14.24|
;;;2501   
;;;2502   				/* Fill in an TaskStatus_t structure with information on each
;;;2503   				task in the Blocked state. */
;;;2504   				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
000034  2024              MOVS     r0,#0x24
000036  4d15              LDR      r5,|L14.140|
000038  4360              MULS     r0,r4,r0
00003a  1980              ADDS     r0,r0,r6
00003c  2202              MOVS     r2,#2
00003e  6b69              LDR      r1,[r5,#0x34]  ; pxDelayedTaskList
000040  f7fffffe          BL       prvListTasksWithinSingleList
000044  1904              ADDS     r4,r0,r4
;;;2505   				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
000046  2024              MOVS     r0,#0x24
000048  4360              MULS     r0,r4,r0
00004a  1980              ADDS     r0,r0,r6
00004c  2202              MOVS     r2,#2
00004e  6ba9              LDR      r1,[r5,#0x38]  ; pxOverflowDelayedTaskList
000050  f7fffffe          BL       prvListTasksWithinSingleList
000054  1904              ADDS     r4,r0,r4
;;;2506   
;;;2507   				#if( INCLUDE_vTaskDelete == 1 )
;;;2508   				{
;;;2509   					/* Fill in an TaskStatus_t structure with information on
;;;2510   					each task that has been deleted but not yet cleaned up. */
;;;2511   					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
000056  2024              MOVS     r0,#0x24
000058  490d              LDR      r1,|L14.144|
00005a  4360              MULS     r0,r4,r0
00005c  1980              ADDS     r0,r0,r6
00005e  2204              MOVS     r2,#4
000060  31a0              ADDS     r1,r1,#0xa0
000062  f7fffffe          BL       prvListTasksWithinSingleList
000066  1904              ADDS     r4,r0,r4
;;;2512   				}
;;;2513   				#endif
;;;2514   
;;;2515   				#if ( INCLUDE_vTaskSuspend == 1 )
;;;2516   				{
;;;2517   					/* Fill in an TaskStatus_t structure with information on
;;;2518   					each task in the Suspended state. */
;;;2519   					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
000068  2024              MOVS     r0,#0x24
00006a  4909              LDR      r1,|L14.144|
00006c  4360              MULS     r0,r4,r0
00006e  1980              ADDS     r0,r0,r6
000070  2203              MOVS     r2,#3
000072  31b4              ADDS     r1,r1,#0xb4
000074  f7fffffe          BL       prvListTasksWithinSingleList
000078  1904              ADDS     r4,r0,r4
;;;2520   				}
;;;2521   				#endif
;;;2522   
;;;2523   				#if ( configGENERATE_RUN_TIME_STATS == 1)
;;;2524   				{
;;;2525   					if( pulTotalRunTime != NULL )
;;;2526   					{
;;;2527   						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
;;;2528   							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
;;;2529   						#else
;;;2530   							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
;;;2531   						#endif
;;;2532   					}
;;;2533   				}
;;;2534   				#else
;;;2535   				{
;;;2536   					if( pulTotalRunTime != NULL )
00007a  2f00              CMP      r7,#0
00007c  d001              BEQ      |L14.130|
;;;2537   					{
;;;2538   						*pulTotalRunTime = 0;
00007e  2000              MOVS     r0,#0
000080  6038              STR      r0,[r7,#0]
                  |L14.130|
;;;2539   					}
;;;2540   				}
;;;2541   				#endif
;;;2542   			}
;;;2543   			else
;;;2544   			{
;;;2545   				mtCOVERAGE_TEST_MARKER();
;;;2546   			}
;;;2547   		}
;;;2548   		( void ) xTaskResumeAll();
000082  f7fffffe          BL       xTaskResumeAll
;;;2549   
;;;2550   		return uxTask;
000086  4620              MOV      r0,r4
;;;2551   	}
000088  bdf8              POP      {r3-r7,pc}
;;;2552   
                          ENDP

00008a  0000              DCW      0x0000
                  |L14.140|
                          DCD      ||.data||
                  |L14.144|
                          DCD      ||.bss||

                          AREA ||i.uxTaskGetTaskNumber||, CODE, READONLY, ALIGN=1

                  uxTaskGetTaskNumber PROC
;;;3285   
;;;3286   	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
000000  2800              CMP      r0,#0
;;;3287   	{
000002  d000              BEQ      |L15.6|
;;;3288   	UBaseType_t uxReturn;
;;;3289   	TCB_t const *pxTCB;
;;;3290   
;;;3291   		if( xTask != NULL )
;;;3292   		{
;;;3293   			pxTCB = xTask;
;;;3294   			uxReturn = pxTCB->uxTaskNumber;
000004  6c80              LDR      r0,[r0,#0x48]
                  |L15.6|
;;;3295   		}
;;;3296   		else
;;;3297   		{
;;;3298   			uxReturn = 0U;
;;;3299   		}
;;;3300   
;;;3301   		return uxReturn;
;;;3302   	}
000006  4770              BX       lr
;;;3303   
                          ENDP


                          AREA ||i.uxTaskPriorityGet||, CODE, READONLY, ALIGN=2

                  uxTaskPriorityGet PROC
;;;1469   
;;;1470   	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
000000  b510              PUSH     {r4,lr}
;;;1471   	{
000002  4604              MOV      r4,r0
;;;1472   	TCB_t const *pxTCB;
;;;1473   	UBaseType_t uxReturn;
;;;1474   
;;;1475   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1476   		{
;;;1477   			/* If null is passed in here then it is the priority of the task
;;;1478   			that called uxTaskPriorityGet() that is being queried. */
;;;1479   			pxTCB = prvGetTCBFromHandle( xTask );
000008  2c00              CMP      r4,#0
00000a  d101              BNE      |L16.16|
00000c  4803              LDR      r0,|L16.28|
00000e  6804              LDR      r4,[r0,#0]  ; pxCurrentTCB
                  |L16.16|
;;;1480   			uxReturn = pxTCB->uxPriority;
000010  6ae4              LDR      r4,[r4,#0x2c]
;;;1481   		}
;;;1482   		taskEXIT_CRITICAL();
000012  f7fffffe          BL       vPortExitCritical
;;;1483   
;;;1484   		return uxReturn;
000016  4620              MOV      r0,r4
;;;1485   	}
000018  bd10              POP      {r4,pc}
;;;1486   
                          ENDP

00001a  0000              DCW      0x0000
                  |L16.28|
                          DCD      ||.data||

                          AREA ||i.uxTaskPriorityGetFromISR||, CODE, READONLY, ALIGN=2

                  uxTaskPriorityGetFromISR PROC
;;;1491   
;;;1492   	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
000000  b510              PUSH     {r4,lr}
;;;1493   	{
000002  4604              MOV      r4,r0
;;;1494   	TCB_t const *pxTCB;
;;;1495   	UBaseType_t uxReturn, uxSavedInterruptState;
;;;1496   
;;;1497   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1498   		maximum	system call (or maximum API call) interrupt priority.
;;;1499   		Interrupts that are	above the maximum system call priority are keep
;;;1500   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1501   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1502   		is defined in FreeRTOSConfig.h then
;;;1503   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1504   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1505   		been assigned a priority above the configured maximum system call
;;;1506   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1507   		from interrupts	that have been assigned a priority at or (logically)
;;;1508   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1509   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1510   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1511   		provided on the following link:
;;;1512   		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1513   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1514   
;;;1515   		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
000004  f7fffffe          BL       ulSetInterruptMaskFromISR
;;;1516   		{
;;;1517   			/* If null is passed in here then it is the priority of the calling
;;;1518   			task that is being queried. */
;;;1519   			pxTCB = prvGetTCBFromHandle( xTask );
000008  2c00              CMP      r4,#0
00000a  d101              BNE      |L17.16|
00000c  4903              LDR      r1,|L17.28|
00000e  680c              LDR      r4,[r1,#0]  ; pxCurrentTCB
                  |L17.16|
;;;1520   			uxReturn = pxTCB->uxPriority;
000010  6ae4              LDR      r4,[r4,#0x2c]
;;;1521   		}
;;;1522   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
000012  f7fffffe          BL       vClearInterruptMaskFromISR
;;;1523   
;;;1524   		return uxReturn;
000016  4620              MOV      r0,r4
;;;1525   	}
000018  bd10              POP      {r4,pc}
;;;1526   
                          ENDP

00001a  0000              DCW      0x0000
                  |L17.28|
                          DCD      ||.data||

                          AREA ||i.uxTaskResetEventItemValue||, CODE, READONLY, ALIGN=2

                  uxTaskResetEventItemValue PROC
;;;4531   
;;;4532   TickType_t uxTaskResetEventItemValue( void )
000000  4904              LDR      r1,|L18.20|
;;;4533   {
;;;4534   TickType_t uxReturn;
;;;4535   
;;;4536   	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
000002  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
;;;4537   
;;;4538   	/* Reset the event list item to its normal value - so it can be used with
;;;4539   	queues and semaphores. */
;;;4540   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000004  680a              LDR      r2,[r1,#0]  ; pxCurrentTCB
000006  6980              LDR      r0,[r0,#0x18]         ;4536
000008  6ad2              LDR      r2,[r2,#0x2c]
00000a  2305              MOVS     r3,#5
00000c  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00000e  1a9a              SUBS     r2,r3,r2
000010  618a              STR      r2,[r1,#0x18]
;;;4541   
;;;4542   	return uxReturn;
;;;4543   }
000012  4770              BX       lr
;;;4544   /*-----------------------------------------------------------*/
                          ENDP

                  |L18.20|
                          DCD      ||.data||

                          AREA ||i.vTaskDelay||, CODE, READONLY, ALIGN=2

                  vTaskDelay PROC
;;;1332   
;;;1333   	void vTaskDelay( const TickType_t xTicksToDelay )
000000  b510              PUSH     {r4,lr}
;;;1334   	{
000002  0002              MOVS     r2,r0
000004  d00f              BEQ      |L19.38|
;;;1335   	BaseType_t xAlreadyYielded = pdFALSE;
;;;1336   
;;;1337   		/* A delay time of zero just forces a reschedule. */
;;;1338   		if( xTicksToDelay > ( TickType_t ) 0U )
;;;1339   		{
;;;1340   			configASSERT( uxSchedulerSuspended == 0 );
000006  4809              LDR      r0,|L19.44|
000008  6b00              LDR      r0,[r0,#0x30]  ; uxSchedulerSuspended
00000a  2800              CMP      r0,#0
00000c  d001              BEQ      |L19.18|
00000e  b672              CPSID    i
                  |L19.16|
000010  e7fe              B        |L19.16|
                  |L19.18|
;;;1341   			vTaskSuspendAll();
000012  f7fffffe          BL       vTaskSuspendAll
;;;1342   			{
;;;1343   				traceTASK_DELAY();
;;;1344   
;;;1345   				/* A task that is removed from the event list while the
;;;1346   				scheduler is suspended will not get placed in the ready
;;;1347   				list or removed from the blocked list until the scheduler
;;;1348   				is resumed.
;;;1349   
;;;1350   				This task cannot be in an event list as it is the currently
;;;1351   				executing task. */
;;;1352   				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
000016  2100              MOVS     r1,#0
000018  4610              MOV      r0,r2
00001a  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;1353   			}
;;;1354   			xAlreadyYielded = xTaskResumeAll();
00001e  f7fffffe          BL       xTaskResumeAll
;;;1355   		}
;;;1356   		else
;;;1357   		{
;;;1358   			mtCOVERAGE_TEST_MARKER();
;;;1359   		}
;;;1360   
;;;1361   		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;1362   		have put ourselves to sleep. */
;;;1363   		if( xAlreadyYielded == pdFALSE )
000022  2800              CMP      r0,#0
000024  d101              BNE      |L19.42|
                  |L19.38|
;;;1364   		{
;;;1365   			portYIELD_WITHIN_API();
000026  f7fffffe          BL       vPortYield
                  |L19.42|
;;;1366   		}
;;;1367   		else
;;;1368   		{
;;;1369   			mtCOVERAGE_TEST_MARKER();
;;;1370   		}
;;;1371   	}
00002a  bd10              POP      {r4,pc}
;;;1372   
                          ENDP

                  |L19.44|
                          DCD      ||.data||

                          AREA ||i.vTaskDelayUntil||, CODE, READONLY, ALIGN=2

                  vTaskDelayUntil PROC
;;;1248   
;;;1249   	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
000000  b570              PUSH     {r4-r6,lr}
;;;1250   	{
;;;1251   	TickType_t xTimeToWake;
;;;1252   	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
000002  2300              MOVS     r3,#0
000004  460e              MOV      r6,r1                 ;1250
000006  4605              MOV      r5,r0                 ;1250
;;;1253   
;;;1254   		configASSERT( pxPreviousWakeTime );
000008  2800              CMP      r0,#0
00000a  d007              BEQ      |L20.28|
;;;1255   		configASSERT( ( xTimeIncrement > 0U ) );
00000c  2e00              CMP      r6,#0
00000e  d007              BEQ      |L20.32|
;;;1256   		configASSERT( uxSchedulerSuspended == 0 );
000010  4a13              LDR      r2,|L20.96|
000012  6b10              LDR      r0,[r2,#0x30]  ; uxSchedulerSuspended
000014  2800              CMP      r0,#0
000016  d005              BEQ      |L20.36|
000018  b672              CPSID    i
                  |L20.26|
00001a  e7fe              B        |L20.26|
                  |L20.28|
00001c  b672              CPSID    i                     ;1254
                  |L20.30|
00001e  e7fe              B        |L20.30|
                  |L20.32|
000020  b672              CPSID    i                     ;1255
                  |L20.34|
000022  e7fe              B        |L20.34|
                  |L20.36|
;;;1257   
;;;1258   		vTaskSuspendAll();
000024  f7fffffe          BL       vTaskSuspendAll
;;;1259   		{
;;;1260   			/* Minor optimisation.  The tick count cannot change in this
;;;1261   			block. */
;;;1262   			const TickType_t xConstTickCount = xTickCount;
000028  68d2              LDR      r2,[r2,#0xc]  ; xTickCount
;;;1263   
;;;1264   			/* Generate the tick time at which the task wants to wake. */
;;;1265   			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
00002a  682c              LDR      r4,[r5,#0]
00002c  19a1              ADDS     r1,r4,r6
;;;1266   
;;;1267   			if( xConstTickCount < *pxPreviousWakeTime )
00002e  4294              CMP      r4,r2
000030  d902              BLS      |L20.56|
;;;1268   			{
;;;1269   				/* The tick count has overflowed since this function was
;;;1270   				lasted called.  In this case the only time we should ever
;;;1271   				actually delay is if the wake time has also	overflowed,
;;;1272   				and the wake time is greater than the tick time.  When this
;;;1273   				is the case it is as if neither time had overflowed. */
;;;1274   				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
000032  428c              CMP      r4,r1
000034  d802              BHI      |L20.60|
000036  e004              B        |L20.66|
                  |L20.56|
;;;1275   				{
;;;1276   					xShouldDelay = pdTRUE;
;;;1277   				}
;;;1278   				else
;;;1279   				{
;;;1280   					mtCOVERAGE_TEST_MARKER();
;;;1281   				}
;;;1282   			}
;;;1283   			else
;;;1284   			{
;;;1285   				/* The tick time has not overflowed.  In this case we will
;;;1286   				delay if either the wake time has overflowed, and/or the
;;;1287   				tick time is less than the wake time. */
;;;1288   				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
000038  428c              CMP      r4,r1
00003a  d801              BHI      |L20.64|
                  |L20.60|
00003c  4291              CMP      r1,r2
00003e  d900              BLS      |L20.66|
                  |L20.64|
;;;1289   				{
;;;1290   					xShouldDelay = pdTRUE;
000040  2301              MOVS     r3,#1
                  |L20.66|
;;;1291   				}
;;;1292   				else
;;;1293   				{
;;;1294   					mtCOVERAGE_TEST_MARKER();
;;;1295   				}
;;;1296   			}
;;;1297   
;;;1298   			/* Update the wake time ready for the next call. */
;;;1299   			*pxPreviousWakeTime = xTimeToWake;
;;;1300   
;;;1301   			if( xShouldDelay != pdFALSE )
000042  6029              STR      r1,[r5,#0]
000044  2b00              CMP      r3,#0
000046  d003              BEQ      |L20.80|
;;;1302   			{
;;;1303   				traceTASK_DELAY_UNTIL( xTimeToWake );
;;;1304   
;;;1305   				/* prvAddCurrentTaskToDelayedList() needs the block time, not
;;;1306   				the time to wake, so subtract the current tick count. */
;;;1307   				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
000048  1a88              SUBS     r0,r1,r2
00004a  2100              MOVS     r1,#0
00004c  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L20.80|
;;;1308   			}
;;;1309   			else
;;;1310   			{
;;;1311   				mtCOVERAGE_TEST_MARKER();
;;;1312   			}
;;;1313   		}
;;;1314   		xAlreadyYielded = xTaskResumeAll();
000050  f7fffffe          BL       xTaskResumeAll
;;;1315   
;;;1316   		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;1317   		have put ourselves to sleep. */
;;;1318   		if( xAlreadyYielded == pdFALSE )
000054  2800              CMP      r0,#0
000056  d101              BNE      |L20.92|
;;;1319   		{
;;;1320   			portYIELD_WITHIN_API();
000058  f7fffffe          BL       vPortYield
                  |L20.92|
;;;1321   		}
;;;1322   		else
;;;1323   		{
;;;1324   			mtCOVERAGE_TEST_MARKER();
;;;1325   		}
;;;1326   	}
00005c  bd70              POP      {r4-r6,pc}
;;;1327   
                          ENDP

00005e  0000              DCW      0x0000
                  |L20.96|
                          DCD      ||.data||

                          AREA ||i.vTaskDelete||, CODE, READONLY, ALIGN=2

                  vTaskDelete PROC
;;;1156   
;;;1157   	void vTaskDelete( TaskHandle_t xTaskToDelete )
000000  b570              PUSH     {r4-r6,lr}
;;;1158   	{
000002  4604              MOV      r4,r0
;;;1159   	TCB_t *pxTCB;
;;;1160   
;;;1161   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1162   		{
;;;1163   			/* If null is passed in here then it is the calling task that is
;;;1164   			being deleted. */
;;;1165   			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
000008  4d19              LDR      r5,|L21.112|
00000a  2c00              CMP      r4,#0
00000c  d100              BNE      |L21.16|
00000e  682c              LDR      r4,[r5,#0]  ; pxCurrentTCB
                  |L21.16|
;;;1166   
;;;1167   			/* Remove task from the ready list. */
;;;1168   			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000010  1d20              ADDS     r0,r4,#4
000012  f7fffffe          BL       uxListRemove
;;;1169   			{
;;;1170   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;1171   			}
;;;1172   			else
;;;1173   			{
;;;1174   				mtCOVERAGE_TEST_MARKER();
;;;1175   			}
;;;1176   
;;;1177   			/* Is the task waiting on an event also? */
;;;1178   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
000016  6aa0              LDR      r0,[r4,#0x28]
000018  2800              CMP      r0,#0
00001a  d003              BEQ      |L21.36|
;;;1179   			{
;;;1180   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
00001c  4620              MOV      r0,r4
00001e  3018              ADDS     r0,r0,#0x18
000020  f7fffffe          BL       uxListRemove
                  |L21.36|
;;;1181   			}
;;;1182   			else
;;;1183   			{
;;;1184   				mtCOVERAGE_TEST_MARKER();
;;;1185   			}
;;;1186   
;;;1187   			/* Increment the uxTaskNumber also so kernel aware debuggers can
;;;1188   			detect that the task lists need re-generating.  This is done before
;;;1189   			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
;;;1190   			not return. */
;;;1191   			uxTaskNumber++;
000024  6a68              LDR      r0,[r5,#0x24]  ; uxTaskNumber
000026  1c40              ADDS     r0,r0,#1
;;;1192   
;;;1193   			if( pxTCB == pxCurrentTCB )
000028  6268              STR      r0,[r5,#0x24]  ; uxTaskNumber
00002a  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00002c  4284              CMP      r4,r0
00002e  d107              BNE      |L21.64|
;;;1194   			{
;;;1195   				/* A task is deleting itself.  This cannot complete within the
;;;1196   				task itself, as a context switch to another task is required.
;;;1197   				Place the task in the termination list.  The idle task will
;;;1198   				check the termination list and free up any memory allocated by
;;;1199   				the scheduler for the TCB and stack of the deleted task. */
;;;1200   				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
000030  1d21              ADDS     r1,r4,#4
000032  4810              LDR      r0,|L21.116|
000034  f7fffffe          BL       vListInsertEnd
;;;1201   
;;;1202   				/* Increment the ucTasksDeleted variable so the idle task knows
;;;1203   				there is a task that has been deleted and that it should therefore
;;;1204   				check the xTasksWaitingTermination list. */
;;;1205   				++uxDeletedTasksWaitingCleanUp;
000038  6868              LDR      r0,[r5,#4]  ; uxDeletedTasksWaitingCleanUp
00003a  1c40              ADDS     r0,r0,#1
00003c  6068              STR      r0,[r5,#4]  ; uxDeletedTasksWaitingCleanUp
00003e  e007              B        |L21.80|
                  |L21.64|
;;;1206   
;;;1207   				/* The pre-delete hook is primarily for the Windows simulator,
;;;1208   				in which Windows specific clean up operations are performed,
;;;1209   				after which it is not possible to yield away from this task -
;;;1210   				hence xYieldPending is used to latch that a context switch is
;;;1211   				required. */
;;;1212   				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
;;;1213   			}
;;;1214   			else
;;;1215   			{
;;;1216   				--uxCurrentNumberOfTasks;
000040  68a8              LDR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
000042  1e40              SUBS     r0,r0,#1
000044  60a8              STR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
;;;1217   				prvDeleteTCB( pxTCB );
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       prvDeleteTCB
;;;1218   
;;;1219   				/* Reset the next expected unblock time in case it referred to
;;;1220   				the task that has just been deleted. */
;;;1221   				prvResetNextTaskUnblockTime();
00004c  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L21.80|
;;;1222   			}
;;;1223   
;;;1224   			traceTASK_DELETE( pxTCB );
;;;1225   		}
;;;1226   		taskEXIT_CRITICAL();
000050  f7fffffe          BL       vPortExitCritical
;;;1227   
;;;1228   		/* Force a reschedule if it is the currently running task that has just
;;;1229   		been deleted. */
;;;1230   		if( xSchedulerRunning != pdFALSE )
000054  6968              LDR      r0,[r5,#0x14]  ; xSchedulerRunning
000056  2800              CMP      r0,#0
000058  d009              BEQ      |L21.110|
;;;1231   		{
;;;1232   			if( pxTCB == pxCurrentTCB )
00005a  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00005c  4284              CMP      r4,r0
00005e  d106              BNE      |L21.110|
;;;1233   			{
;;;1234   				configASSERT( uxSchedulerSuspended == 0 );
000060  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
000062  2800              CMP      r0,#0
000064  d001              BEQ      |L21.106|
000066  b672              CPSID    i
                  |L21.104|
000068  e7fe              B        |L21.104|
                  |L21.106|
;;;1235   				portYIELD_WITHIN_API();
00006a  f7fffffe          BL       vPortYield
                  |L21.110|
;;;1236   			}
;;;1237   			else
;;;1238   			{
;;;1239   				mtCOVERAGE_TEST_MARKER();
;;;1240   			}
;;;1241   		}
;;;1242   	}
00006e  bd70              POP      {r4-r6,pc}
;;;1243   
                          ENDP

                  |L21.112|
                          DCD      ||.data||
                  |L21.116|
                          DCD      ||.bss||+0xa0

                          AREA ||i.vTaskEndScheduler||, CODE, READONLY, ALIGN=2

                  vTaskEndScheduler PROC
;;;2088   
;;;2089   void vTaskEndScheduler( void )
000000  b510              PUSH     {r4,lr}
;;;2090   {
;;;2091   	/* Stop the scheduler interrupts and call the portable scheduler end
;;;2092   	routine so the original ISRs can be restored if necessary.  The port
;;;2093   	layer must ensure interrupts enable	bit is left in the correct state. */
;;;2094   	portDISABLE_INTERRUPTS();
000002  b672              CPSID    i
;;;2095   	xSchedulerRunning = pdFALSE;
000004  2000              MOVS     r0,#0
000006  4902              LDR      r1,|L22.16|
000008  6148              STR      r0,[r1,#0x14]  ; xSchedulerRunning
;;;2096   	vPortEndScheduler();
00000a  f7fffffe          BL       vPortEndScheduler
;;;2097   }
00000e  bd10              POP      {r4,pc}
;;;2098   /*----------------------------------------------------------*/
                          ENDP

                  |L22.16|
                          DCD      ||.data||

                          AREA ||i.vTaskGetInfo||, CODE, READONLY, ALIGN=2

                  vTaskGetInfo PROC
;;;3607   
;;;3608   	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
000000  b5f8              PUSH     {r3-r7,lr}
;;;3609   	{
000002  460c              MOV      r4,r1
;;;3610   	TCB_t *pxTCB;
;;;3611   
;;;3612   		/* xTask is NULL then get the state of the calling task. */
;;;3613   		pxTCB = prvGetTCBFromHandle( xTask );
000004  491d              LDR      r1,|L23.124|
000006  4617              MOV      r7,r2                 ;3609
000008  2800              CMP      r0,#0
00000a  d015              BEQ      |L23.56|
00000c  4605              MOV      r5,r0
                  |L23.14|
;;;3614   
;;;3615   		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
;;;3616   		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
00000e  4628              MOV      r0,r5
000010  3034              ADDS     r0,r0,#0x34
;;;3617   		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
000012  6025              STR      r5,[r4,#0]
000014  6060              STR      r0,[r4,#4]
000016  6ae8              LDR      r0,[r5,#0x2c]
;;;3618   		pxTaskStatus->pxStackBase = pxTCB->pxStack;
000018  6120              STR      r0,[r4,#0x10]
00001a  6b28              LDR      r0,[r5,#0x30]
;;;3619   		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
00001c  61e0              STR      r0,[r4,#0x1c]
00001e  6c68              LDR      r0,[r5,#0x44]
;;;3620   
;;;3621   		#if ( configUSE_MUTEXES == 1 )
;;;3622   		{
;;;3623   			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
000020  60a0              STR      r0,[r4,#8]
;;;3624   		}
;;;3625   		#else
;;;3626   		{
;;;3627   			pxTaskStatus->uxBasePriority = 0;
;;;3628   		}
;;;3629   		#endif
;;;3630   
;;;3631   		#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;3632   		{
;;;3633   			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
;;;3634   		}
;;;3635   		#else
;;;3636   		{
;;;3637   			pxTaskStatus->ulRunTimeCounter = 0;
000022  2600              MOVS     r6,#0
000024  6ce8              LDR      r0,[r5,#0x4c]         ;3623
;;;3638   		}
;;;3639   		#endif
;;;3640   
;;;3641   		/* Obtaining the task state is a little fiddly, so is only done if the
;;;3642   		value of eState passed into this function is eInvalid - otherwise the
;;;3643   		state is just set to whatever is passed in. */
;;;3644   		if( eState != eInvalid )
000026  61a6              STR      r6,[r4,#0x18]
000028  6160              STR      r0,[r4,#0x14]
00002a  2b05              CMP      r3,#5
00002c  d013              BEQ      |L23.86|
;;;3645   		{
;;;3646   			if( pxTCB == pxCurrentTCB )
00002e  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
000030  4285              CMP      r5,r0
000032  d103              BNE      |L23.60|
;;;3647   			{
;;;3648   				pxTaskStatus->eCurrentState = eRunning;
000034  7326              STRB     r6,[r4,#0xc]
000036  e012              B        |L23.94|
                  |L23.56|
000038  680d              LDR      r5,[r1,#0]            ;3613  ; pxCurrentTCB
00003a  e7e8              B        |L23.14|
                  |L23.60|
;;;3649   			}
;;;3650   			else
;;;3651   			{
;;;3652   				pxTaskStatus->eCurrentState = eState;
00003c  7323              STRB     r3,[r4,#0xc]
;;;3653   
;;;3654   				#if ( INCLUDE_vTaskSuspend == 1 )
;;;3655   				{
;;;3656   					/* If the task is in the suspended list then there is a
;;;3657   					chance it is actually just blocked indefinitely - so really
;;;3658   					it should be reported as being in the Blocked state. */
;;;3659   					if( eState == eSuspended )
00003e  2b03              CMP      r3,#3
000040  d10d              BNE      |L23.94|
;;;3660   					{
;;;3661   						vTaskSuspendAll();
000042  f7fffffe          BL       vTaskSuspendAll
;;;3662   						{
;;;3663   							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
000046  6aa8              LDR      r0,[r5,#0x28]
000048  2800              CMP      r0,#0
00004a  d001              BEQ      |L23.80|
;;;3664   							{
;;;3665   								pxTaskStatus->eCurrentState = eBlocked;
00004c  2002              MOVS     r0,#2
00004e  7320              STRB     r0,[r4,#0xc]
                  |L23.80|
;;;3666   							}
;;;3667   						}
;;;3668   						( void ) xTaskResumeAll();
000050  f7fffffe          BL       xTaskResumeAll
000054  e003              B        |L23.94|
                  |L23.86|
;;;3669   					}
;;;3670   				}
;;;3671   				#endif /* INCLUDE_vTaskSuspend */
;;;3672   			}
;;;3673   		}
;;;3674   		else
;;;3675   		{
;;;3676   			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       eTaskGetState
00005c  7320              STRB     r0,[r4,#0xc]
                  |L23.94|
;;;3677   		}
;;;3678   
;;;3679   		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
;;;3680   		parameter is provided to allow it to be skipped. */
;;;3681   		if( xGetFreeStackSpace != pdFALSE )
00005e  2f00              CMP      r7,#0
000060  d00a              BEQ      |L23.120|
000062  2100              MOVS     r1,#0
;;;3682   		{
;;;3683   			#if ( portSTACK_GROWTH > 0 )
;;;3684   			{
;;;3685   				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
;;;3686   			}
;;;3687   			#else
;;;3688   			{
;;;3689   				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
000064  6b28              LDR      r0,[r5,#0x30]
000066  e001              B        |L23.108|
                  |L23.104|
000068  1c40              ADDS     r0,r0,#1
00006a  1c49              ADDS     r1,r1,#1
                  |L23.108|
00006c  7802              LDRB     r2,[r0,#0]
00006e  2aa5              CMP      r2,#0xa5
000070  d0fa              BEQ      |L23.104|
000072  0888              LSRS     r0,r1,#2
000074  8420              STRH     r0,[r4,#0x20]
;;;3690   			}
;;;3691   			#endif
;;;3692   		}
;;;3693   		else
;;;3694   		{
;;;3695   			pxTaskStatus->usStackHighWaterMark = 0;
;;;3696   		}
;;;3697   	}
000076  bdf8              POP      {r3-r7,pc}
                  |L23.120|
000078  8426              STRH     r6,[r4,#0x20]         ;3695
00007a  bdf8              POP      {r3-r7,pc}
;;;3698   
                          ENDP

                  |L23.124|
                          DCD      ||.data||

                          AREA ||i.vTaskInternalSetTimeOutState||, CODE, READONLY, ALIGN=2

                  vTaskInternalSetTimeOutState PROC
;;;3206   
;;;3207   void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
000000  4902              LDR      r1,|L24.12|
;;;3208   {
;;;3209   	/* For internal use only as it does not use a critical section. */
;;;3210   	pxTimeOut->xOverflowCount = xNumOfOverflows;
000002  6a0a              LDR      r2,[r1,#0x20]  ; xNumOfOverflows
;;;3211   	pxTimeOut->xTimeOnEntering = xTickCount;
000004  6002              STR      r2,[r0,#0]
000006  68c9              LDR      r1,[r1,#0xc]  ; xTickCount
000008  6041              STR      r1,[r0,#4]
;;;3212   }
00000a  4770              BX       lr
;;;3213   /*-----------------------------------------------------------*/
                          ENDP

                  |L24.12|
                          DCD      ||.data||

                          AREA ||i.vTaskMissedYield||, CODE, READONLY, ALIGN=2

                  vTaskMissedYield PROC
;;;3277   
;;;3278   void vTaskMissedYield( void )
000000  4901              LDR      r1,|L25.8|
;;;3279   {
;;;3280   	xYieldPending = pdTRUE;
000002  2001              MOVS     r0,#1
000004  61c8              STR      r0,[r1,#0x1c]  ; xYieldPending
;;;3281   }
000006  4770              BX       lr
;;;3282   /*-----------------------------------------------------------*/
                          ENDP

                  |L25.8|
                          DCD      ||.data||

                          AREA ||i.vTaskNotifyGiveFromISR||, CODE, READONLY, ALIGN=2

                  vTaskNotifyGiveFromISR PROC
;;;4955   
;;;4956   	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
000000  b5f8              PUSH     {r3-r7,lr}
;;;4957   	{
000002  460e              MOV      r6,r1
;;;4958   	TCB_t * pxTCB;
;;;4959   	uint8_t ucOriginalNotifyState;
;;;4960   	UBaseType_t uxSavedInterruptStatus;
;;;4961   
;;;4962   		configASSERT( xTaskToNotify );
000004  2800              CMP      r0,#0
000006  d00e              BEQ      |L26.38|
;;;4963   
;;;4964   		/* RTOS ports that support interrupt nesting have the concept of a
;;;4965   		maximum	system call (or maximum API call) interrupt priority.
;;;4966   		Interrupts that are	above the maximum system call priority are keep
;;;4967   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;4968   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;4969   		is defined in FreeRTOSConfig.h then
;;;4970   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;4971   		failure if a FreeRTOS API function is called from an interrupt that has
;;;4972   		been assigned a priority above the configured maximum system call
;;;4973   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;4974   		from interrupts	that have been assigned a priority at or (logically)
;;;4975   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;4976   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;4977   		simple as possible.  More information (albeit Cortex-M specific) is
;;;4978   		provided on the following link:
;;;4979   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;4980   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;4981   
;;;4982   		pxTCB = xTaskToNotify;
000008  4604              MOV      r4,r0
;;;4983   
;;;4984   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00000a  f7fffffe          BL       ulSetInterruptMaskFromISR
00000e  4607              MOV      r7,r0
;;;4985   		{
;;;4986   			ucOriginalNotifyState = pxTCB->ucNotifyState;
000010  4620              MOV      r0,r4
000012  3040              ADDS     r0,r0,#0x40
000014  7e01              LDRB     r1,[r0,#0x18]
;;;4987   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
000016  2202              MOVS     r2,#2
000018  7602              STRB     r2,[r0,#0x18]
;;;4988   
;;;4989   			/* 'Giving' is equivalent to incrementing a count in a counting
;;;4990   			semaphore. */
;;;4991   			( pxTCB->ulNotifiedValue )++;
00001a  6d62              LDR      r2,[r4,#0x54]
00001c  1c52              ADDS     r2,r2,#1
00001e  6562              STR      r2,[r4,#0x54]
;;;4992   
;;;4993   			traceTASK_NOTIFY_GIVE_FROM_ISR();
;;;4994   
;;;4995   			/* If the task is in the blocked state specifically to wait for a
;;;4996   			notification then unblock it now. */
;;;4997   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
000020  2901              CMP      r1,#1
000022  d002              BEQ      |L26.42|
000024  e028              B        |L26.120|
                  |L26.38|
000026  b672              CPSID    i                     ;4962
                  |L26.40|
000028  e7fe              B        |L26.40|
                  |L26.42|
;;;4998   			{
;;;4999   				/* The task should not have been on an event list. */
;;;5000   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
00002a  6aa0              LDR      r0,[r4,#0x28]
00002c  2800              CMP      r0,#0
00002e  d001              BEQ      |L26.52|
000030  b672              CPSID    i
                  |L26.50|
000032  e7fe              B        |L26.50|
                  |L26.52|
;;;5001   
;;;5002   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000034  4d12              LDR      r5,|L26.128|
000036  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
000038  2800              CMP      r0,#0
00003a  d003              BEQ      |L26.68|
;;;5003   				{
;;;5004   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
;;;5005   					prvAddTaskToReadyList( pxTCB );
;;;5006   				}
;;;5007   				else
;;;5008   				{
;;;5009   					/* The delayed and ready lists cannot be accessed, so hold
;;;5010   					this task pending until the scheduler is resumed. */
;;;5011   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
00003c  4621              MOV      r1,r4
00003e  3118              ADDS     r1,r1,#0x18
000040  4810              LDR      r0,|L26.132|
000042  e00d              B        |L26.96|
                  |L26.68|
000044  1d20              ADDS     r0,r4,#4              ;5004
000046  f7fffffe          BL       uxListRemove
00004a  6ae0              LDR      r0,[r4,#0x2c]         ;5005
00004c  6929              LDR      r1,[r5,#0x10]         ;5005  ; uxTopReadyPriority
00004e  4288              CMP      r0,r1                 ;5005
000050  d900              BLS      |L26.84|
000052  6128              STR      r0,[r5,#0x10]         ;5005  ; uxTopReadyPriority
                  |L26.84|
000054  2114              MOVS     r1,#0x14              ;5005
000056  4348              MULS     r0,r1,r0              ;5005
000058  490a              LDR      r1,|L26.132|
00005a  398c              SUBS     r1,r1,#0x8c           ;5005
00005c  1840              ADDS     r0,r0,r1              ;5005
00005e  1d21              ADDS     r1,r4,#4              ;5005
                  |L26.96|
000060  f7fffffe          BL       vListInsertEnd
;;;5012   				}
;;;5013   
;;;5014   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
000064  6ae0              LDR      r0,[r4,#0x2c]
000066  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000068  6ac9              LDR      r1,[r1,#0x2c]
00006a  4288              CMP      r0,r1
00006c  d904              BLS      |L26.120|
00006e  2001              MOVS     r0,#1                 ;4959
;;;5015   				{
;;;5016   					/* The notified task has a priority above the currently
;;;5017   					executing task so a yield is required. */
;;;5018   					if( pxHigherPriorityTaskWoken != NULL )
000070  2e00              CMP      r6,#0
000072  d000              BEQ      |L26.118|
;;;5019   					{
;;;5020   						*pxHigherPriorityTaskWoken = pdTRUE;
000074  6030              STR      r0,[r6,#0]
                  |L26.118|
;;;5021   					}
;;;5022   
;;;5023   					/* Mark that a yield is pending in case the user is not
;;;5024   					using the "xHigherPriorityTaskWoken" parameter in an ISR
;;;5025   					safe FreeRTOS function. */
;;;5026   					xYieldPending = pdTRUE;
000076  61e8              STR      r0,[r5,#0x1c]  ; xYieldPending
                  |L26.120|
;;;5027   				}
;;;5028   				else
;;;5029   				{
;;;5030   					mtCOVERAGE_TEST_MARKER();
;;;5031   				}
;;;5032   			}
;;;5033   		}
;;;5034   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000078  4638              MOV      r0,r7
00007a  f7fffffe          BL       vClearInterruptMaskFromISR
;;;5035   	}
00007e  bdf8              POP      {r3-r7,pc}
;;;5036   
                          ENDP

                  |L26.128|
                          DCD      ||.data||
                  |L26.132|
                          DCD      ||.bss||+0x8c

                          AREA ||i.vTaskPlaceOnEventList||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnEventList PROC
;;;3018   
;;;3019   void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
000000  b510              PUSH     {r4,lr}
;;;3020   {
000002  460c              MOV      r4,r1
;;;3021   	configASSERT( pxEventList );
000004  2800              CMP      r0,#0
000006  d009              BEQ      |L27.28|
;;;3022   
;;;3023   	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
;;;3024   	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
;;;3025   
;;;3026   	/* Place the event list item of the TCB in the appropriate event list.
;;;3027   	This is placed in the list in priority order so the highest priority task
;;;3028   	is the first to be woken by the event.  The queue that contains the event
;;;3029   	list is locked, preventing simultaneous access from interrupts. */
;;;3030   	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
000008  4905              LDR      r1,|L27.32|
00000a  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00000c  3118              ADDS     r1,r1,#0x18
00000e  f7fffffe          BL       vListInsert
;;;3031   
;;;3032   	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
000012  2101              MOVS     r1,#1
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;3033   }
00001a  bd10              POP      {r4,pc}
                  |L27.28|
00001c  b672              CPSID    i                     ;3021
                  |L27.30|
00001e  e7fe              B        |L27.30|
;;;3034   /*-----------------------------------------------------------*/
                          ENDP

                  |L27.32|
                          DCD      ||.data||

                          AREA ||i.vTaskPlaceOnEventListRestricted||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnEventListRestricted PROC
;;;3061   
;;;3062   	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
000000  b570              PUSH     {r4-r6,lr}
;;;3063   	{
000002  4614              MOV      r4,r2
000004  460d              MOV      r5,r1
;;;3064   		configASSERT( pxEventList );
000006  2800              CMP      r0,#0
000008  d00d              BEQ      |L28.38|
;;;3065   
;;;3066   		/* This function should not be called by application code hence the
;;;3067   		'Restricted' in its name.  It is not part of the public API.  It is
;;;3068   		designed for use by kernel code, and has special calling requirements -
;;;3069   		it should be called with the scheduler suspended. */
;;;3070   
;;;3071   
;;;3072   		/* Place the event list item of the TCB in the appropriate event list.
;;;3073   		In this case it is assume that this is the only task that is going to
;;;3074   		be waiting on this event list, so the faster vListInsertEnd() function
;;;3075   		can be used in place of vListInsert. */
;;;3076   		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
00000a  4908              LDR      r1,|L28.44|
00000c  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00000e  3118              ADDS     r1,r1,#0x18
000010  f7fffffe          BL       vListInsertEnd
;;;3077   
;;;3078   		/* If the task should block indefinitely then set the block time to a
;;;3079   		value that will be recognised as an indefinite delay inside the
;;;3080   		prvAddCurrentTaskToDelayedList() function. */
;;;3081   		if( xWaitIndefinitely != pdFALSE )
000014  2c00              CMP      r4,#0
000016  d001              BEQ      |L28.28|
;;;3082   		{
;;;3083   			xTicksToWait = portMAX_DELAY;
000018  2500              MOVS     r5,#0
00001a  43ed              MVNS     r5,r5
                  |L28.28|
;;;3084   		}
;;;3085   
;;;3086   		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
;;;3087   		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
00001c  4621              MOV      r1,r4
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;3088   	}
000024  bd70              POP      {r4-r6,pc}
                  |L28.38|
000026  b672              CPSID    i                     ;3064
                  |L28.40|
000028  e7fe              B        |L28.40|
;;;3089   
                          ENDP

00002a  0000              DCW      0x0000
                  |L28.44|
                          DCD      ||.data||

                          AREA ||i.vTaskPlaceOnUnorderedEventList||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnUnorderedEventList PROC
;;;3035   
;;;3036   void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
000000  b510              PUSH     {r4,lr}
;;;3037   {
000002  4614              MOV      r4,r2
;;;3038   	configASSERT( pxEventList );
000004  2800              CMP      r0,#0
000006  d011              BEQ      |L29.44|
;;;3039   
;;;3040   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;3041   	the event groups implementation. */
;;;3042   	configASSERT( uxSchedulerSuspended != 0 );
000008  4b0a              LDR      r3,|L29.52|
00000a  6b1a              LDR      r2,[r3,#0x30]  ; uxSchedulerSuspended
00000c  2a00              CMP      r2,#0
00000e  d00f              BEQ      |L29.48|
;;;3043   
;;;3044   	/* Store the item value in the event list item.  It is safe to access the
;;;3045   	event list item here as interrupts won't access the event list item of a
;;;3046   	task that is not in the Blocked state. */
;;;3047   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
000010  2201              MOVS     r2,#1
000012  07d2              LSLS     r2,r2,#31
000014  4311              ORRS     r1,r1,r2
000016  681a              LDR      r2,[r3,#0]  ; pxCurrentTCB
;;;3048   
;;;3049   	/* Place the event list item of the TCB at the end of the appropriate event
;;;3050   	list.  It is safe to access the event list here because it is part of an
;;;3051   	event group implementation - and interrupts don't access event groups
;;;3052   	directly (instead they access them indirectly by pending function calls to
;;;3053   	the task level). */
;;;3054   	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
000018  6191              STR      r1,[r2,#0x18]
00001a  6819              LDR      r1,[r3,#0]  ; pxCurrentTCB
00001c  3118              ADDS     r1,r1,#0x18
00001e  f7fffffe          BL       vListInsertEnd
;;;3055   
;;;3056   	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
000022  2101              MOVS     r1,#1
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;3057   }
00002a  bd10              POP      {r4,pc}
                  |L29.44|
00002c  b672              CPSID    i                     ;3038
                  |L29.46|
00002e  e7fe              B        |L29.46|
                  |L29.48|
000030  b672              CPSID    i                     ;3042
                  |L29.50|
000032  e7fe              B        |L29.50|
;;;3058   /*-----------------------------------------------------------*/
                          ENDP

                  |L29.52|
                          DCD      ||.data||

                          AREA ||i.vTaskPriorityDisinheritAfterTimeout||, CODE, READONLY, ALIGN=2

                  vTaskPriorityDisinheritAfterTimeout PROC
;;;4116   
;;;4117   	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
000000  b570              PUSH     {r4-r6,lr}
;;;4118   	{
000002  460b              MOV      r3,r1
;;;4119   	TCB_t * const pxTCB = pxMutexHolder;
000004  0004              MOVS     r4,r0
000006  d02f              BEQ      |L30.104|
;;;4120   	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
;;;4121   	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
;;;4122   
;;;4123   		if( pxMutexHolder != NULL )
;;;4124   		{
;;;4125   			/* If pxMutexHolder is not NULL then the holder must hold at least
;;;4126   			one mutex. */
;;;4127   			configASSERT( pxTCB->uxMutexesHeld );
000008  6d22              LDR      r2,[r4,#0x50]
00000a  2a00              CMP      r2,#0
00000c  d00e              BEQ      |L30.44|
;;;4128   
;;;4129   			/* Determine the priority to which the priority of the task that
;;;4130   			holds the mutex should be set.  This will be the greater of the
;;;4131   			holding task's base priority and the priority of the highest
;;;4132   			priority task that is waiting to obtain the mutex. */
;;;4133   			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
00000e  6ce1              LDR      r1,[r4,#0x4c]
000010  4299              CMP      r1,r3
000012  d200              BCS      |L30.22|
;;;4134   			{
;;;4135   				uxPriorityToUse = uxHighestPriorityWaitingTask;
000014  4619              MOV      r1,r3
                  |L30.22|
;;;4136   			}
;;;4137   			else
;;;4138   			{
;;;4139   				uxPriorityToUse = pxTCB->uxBasePriority;
;;;4140   			}
;;;4141   
;;;4142   			/* Does the priority need to change? */
;;;4143   			if( pxTCB->uxPriority != uxPriorityToUse )
000016  6ae0              LDR      r0,[r4,#0x2c]
000018  4288              CMP      r0,r1
00001a  d025              BEQ      |L30.104|
;;;4144   			{
;;;4145   				/* Only disinherit if no other mutexes are held.  This is a
;;;4146   				simplification in the priority inheritance implementation.  If
;;;4147   				the task that holds the mutex is also holding other mutexes then
;;;4148   				the other mutexes may have caused the priority inheritance. */
;;;4149   				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
00001c  2a01              CMP      r2,#1
00001e  d123              BNE      |L30.104|
;;;4150   				{
;;;4151   					/* If a task has timed out because it already holds the
;;;4152   					mutex it was trying to obtain then it cannot of inherited
;;;4153   					its own priority. */
;;;4154   					configASSERT( pxTCB != pxCurrentTCB );
000020  4d12              LDR      r5,|L30.108|
000022  682a              LDR      r2,[r5,#0]  ; pxCurrentTCB
000024  4294              CMP      r4,r2
000026  d103              BNE      |L30.48|
000028  b672              CPSID    i
                  |L30.42|
00002a  e7fe              B        |L30.42|
                  |L30.44|
00002c  b672              CPSID    i                     ;4127
                  |L30.46|
00002e  e7fe              B        |L30.46|
                  |L30.48|
;;;4155   
;;;4156   					/* Disinherit the priority, remembering the previous
;;;4157   					priority to facilitate determining the subject task's
;;;4158   					state. */
;;;4159   					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
;;;4160   					uxPriorityUsedOnEntry = pxTCB->uxPriority;
;;;4161   					pxTCB->uxPriority = uxPriorityToUse;
;;;4162   
;;;4163   					/* Only reset the event list item value if the value is not
;;;4164   					being used for anything else. */
;;;4165   					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000030  62e1              STR      r1,[r4,#0x2c]
000032  69a2              LDR      r2,[r4,#0x18]
000034  2a00              CMP      r2,#0
000036  db02              BLT      |L30.62|
;;;4166   					{
;;;4167   						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000038  2205              MOVS     r2,#5
00003a  1a51              SUBS     r1,r2,r1
00003c  61a1              STR      r1,[r4,#0x18]
                  |L30.62|
;;;4168   					}
;;;4169   					else
;;;4170   					{
;;;4171   						mtCOVERAGE_TEST_MARKER();
;;;4172   					}
;;;4173   
;;;4174   					/* If the running task is not the task that holds the mutex
;;;4175   					then the task that holds the mutex could be in either the
;;;4176   					Ready, Blocked or Suspended states.  Only remove the task
;;;4177   					from its current state list if it is in the Ready state as
;;;4178   					the task's priority is going to change and there is one
;;;4179   					Ready list per priority. */
;;;4180   					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
00003e  2214              MOVS     r2,#0x14
000040  4e0b              LDR      r6,|L30.112|
000042  4350              MULS     r0,r2,r0
000044  6961              LDR      r1,[r4,#0x14]
000046  1980              ADDS     r0,r0,r6
000048  4281              CMP      r1,r0
00004a  d10d              BNE      |L30.104|
;;;4181   					{
;;;4182   						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
00004c  1d20              ADDS     r0,r4,#4
00004e  f7fffffe          BL       uxListRemove
;;;4183   						{
;;;4184   							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;4185   						}
;;;4186   						else
;;;4187   						{
;;;4188   							mtCOVERAGE_TEST_MARKER();
;;;4189   						}
;;;4190   
;;;4191   						prvAddTaskToReadyList( pxTCB );
000052  6ae0              LDR      r0,[r4,#0x2c]
000054  6929              LDR      r1,[r5,#0x10]  ; uxTopReadyPriority
000056  4288              CMP      r0,r1
000058  d900              BLS      |L30.92|
00005a  6128              STR      r0,[r5,#0x10]  ; uxTopReadyPriority
                  |L30.92|
00005c  2114              MOVS     r1,#0x14
00005e  4348              MULS     r0,r1,r0
000060  1980              ADDS     r0,r0,r6
000062  1d21              ADDS     r1,r4,#4
000064  f7fffffe          BL       vListInsertEnd
                  |L30.104|
;;;4192   					}
;;;4193   					else
;;;4194   					{
;;;4195   						mtCOVERAGE_TEST_MARKER();
;;;4196   					}
;;;4197   				}
;;;4198   				else
;;;4199   				{
;;;4200   					mtCOVERAGE_TEST_MARKER();
;;;4201   				}
;;;4202   			}
;;;4203   			else
;;;4204   			{
;;;4205   				mtCOVERAGE_TEST_MARKER();
;;;4206   			}
;;;4207   		}
;;;4208   		else
;;;4209   		{
;;;4210   			mtCOVERAGE_TEST_MARKER();
;;;4211   		}
;;;4212   	}
000068  bd70              POP      {r4-r6,pc}
;;;4213   
                          ENDP

00006a  0000              DCW      0x0000
                  |L30.108|
                          DCD      ||.data||
                  |L30.112|
                          DCD      ||.bss||

                          AREA ||i.vTaskPrioritySet||, CODE, READONLY, ALIGN=2

                  vTaskPrioritySet PROC
;;;1531   
;;;1532   	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
000000  b5f8              PUSH     {r3-r7,lr}
;;;1533   	{
;;;1534   	TCB_t *pxTCB;
;;;1535   	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
;;;1536   	BaseType_t xYieldRequired = pdFALSE;
000002  2600              MOVS     r6,#0
000004  460d              MOV      r5,r1                 ;1533
000006  4604              MOV      r4,r0                 ;1533
;;;1537   
;;;1538   		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
000008  2905              CMP      r1,#5
00000a  d301              BCC      |L31.16|
00000c  b672              CPSID    i
                  |L31.14|
00000e  e7fe              B        |L31.14|
                  |L31.16|
;;;1539   
;;;1540   		/* Ensure the new priority is valid. */
;;;1541   		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
;;;1542   		{
;;;1543   			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
;;;1544   		}
;;;1545   		else
;;;1546   		{
;;;1547   			mtCOVERAGE_TEST_MARKER();
;;;1548   		}
;;;1549   
;;;1550   		taskENTER_CRITICAL();
000010  f7fffffe          BL       vPortEnterCritical
;;;1551   		{
;;;1552   			/* If null is passed in here then it is the priority of the calling
;;;1553   			task that is being changed. */
;;;1554   			pxTCB = prvGetTCBFromHandle( xTask );
000014  4f1d              LDR      r7,|L31.140|
000016  2c00              CMP      r4,#0
000018  d100              BNE      |L31.28|
00001a  683c              LDR      r4,[r7,#0]  ; pxCurrentTCB
                  |L31.28|
;;;1555   
;;;1556   			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
;;;1557   
;;;1558   			#if ( configUSE_MUTEXES == 1 )
;;;1559   			{
;;;1560   				uxCurrentBasePriority = pxTCB->uxBasePriority;
;;;1561   			}
;;;1562   			#else
;;;1563   			{
;;;1564   				uxCurrentBasePriority = pxTCB->uxPriority;
;;;1565   			}
;;;1566   			#endif
;;;1567   
;;;1568   			if( uxCurrentBasePriority != uxNewPriority )
00001c  6ce0              LDR      r0,[r4,#0x4c]
00001e  42a8              CMP      r0,r5
000020  d030              BEQ      |L31.132|
;;;1569   			{
;;;1570   				/* The priority change may have readied a task of higher
;;;1571   				priority than the calling task. */
;;;1572   				if( uxNewPriority > uxCurrentBasePriority )
;;;1573   				{
;;;1574   					if( pxTCB != pxCurrentTCB )
;;;1575   					{
;;;1576   						/* The priority of a task other than the currently
;;;1577   						running task is being raised.  Is the priority being
;;;1578   						raised above that of the running task? */
;;;1579   						if( uxNewPriority >= pxCurrentTCB->uxPriority )
;;;1580   						{
;;;1581   							xYieldRequired = pdTRUE;
;;;1582   						}
;;;1583   						else
;;;1584   						{
;;;1585   							mtCOVERAGE_TEST_MARKER();
;;;1586   						}
;;;1587   					}
;;;1588   					else
;;;1589   					{
;;;1590   						/* The priority of the running task is being raised,
;;;1591   						but the running task must already be the highest
;;;1592   						priority task able to run so no yield is required. */
;;;1593   					}
;;;1594   				}
;;;1595   				else if( pxTCB == pxCurrentTCB )
000022  6839              LDR      r1,[r7,#0]  ; pxCurrentTCB
000024  4285              CMP      r5,r0                 ;1572
000026  d906              BLS      |L31.54|
000028  428c              CMP      r4,r1                 ;1574
00002a  d007              BEQ      |L31.60|
00002c  6839              LDR      r1,[r7,#0]            ;1579  ; pxCurrentTCB
00002e  6ac9              LDR      r1,[r1,#0x2c]         ;1579
000030  42a9              CMP      r1,r5                 ;1579
000032  d902              BLS      |L31.58|
000034  e002              B        |L31.60|
                  |L31.54|
000036  428c              CMP      r4,r1
000038  d100              BNE      |L31.60|
                  |L31.58|
;;;1596   				{
;;;1597   					/* Setting the priority of the running task down means
;;;1598   					there may now be another task of higher priority that
;;;1599   					is ready to execute. */
;;;1600   					xYieldRequired = pdTRUE;
00003a  2601              MOVS     r6,#1
                  |L31.60|
;;;1601   				}
;;;1602   				else
;;;1603   				{
;;;1604   					/* Setting the priority of any other task down does not
;;;1605   					require a yield as the running task must be above the
;;;1606   					new priority of the task being modified. */
;;;1607   				}
;;;1608   
;;;1609   				/* Remember the ready list the task might be referenced from
;;;1610   				before its uxPriority member is changed so the
;;;1611   				taskRESET_READY_PRIORITY() macro can function correctly. */
;;;1612   				uxPriorityUsedOnEntry = pxTCB->uxPriority;
;;;1613   
;;;1614   				#if ( configUSE_MUTEXES == 1 )
;;;1615   				{
;;;1616   					/* Only change the priority being used if the task is not
;;;1617   					currently using an inherited priority. */
;;;1618   					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
00003c  6ae1              LDR      r1,[r4,#0x2c]
00003e  4288              CMP      r0,r1
000040  d100              BNE      |L31.68|
;;;1619   					{
;;;1620   						pxTCB->uxPriority = uxNewPriority;
000042  62e5              STR      r5,[r4,#0x2c]
                  |L31.68|
;;;1621   					}
;;;1622   					else
;;;1623   					{
;;;1624   						mtCOVERAGE_TEST_MARKER();
;;;1625   					}
;;;1626   
;;;1627   					/* The base priority gets set whatever. */
;;;1628   					pxTCB->uxBasePriority = uxNewPriority;
;;;1629   				}
;;;1630   				#else
;;;1631   				{
;;;1632   					pxTCB->uxPriority = uxNewPriority;
;;;1633   				}
;;;1634   				#endif
;;;1635   
;;;1636   				/* Only reset the event list item value if the value is not
;;;1637   				being used for anything else. */
;;;1638   				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000044  64e5              STR      r5,[r4,#0x4c]
000046  69a0              LDR      r0,[r4,#0x18]
000048  2800              CMP      r0,#0
00004a  db02              BLT      |L31.82|
;;;1639   				{
;;;1640   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00004c  2005              MOVS     r0,#5
00004e  1b40              SUBS     r0,r0,r5
000050  61a0              STR      r0,[r4,#0x18]
                  |L31.82|
;;;1641   				}
;;;1642   				else
;;;1643   				{
;;;1644   					mtCOVERAGE_TEST_MARKER();
;;;1645   				}
;;;1646   
;;;1647   				/* If the task is in the blocked or suspended list we need do
;;;1648   				nothing more than change its priority variable. However, if
;;;1649   				the task is in a ready list it needs to be removed and placed
;;;1650   				in the list appropriate to its new priority. */
;;;1651   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
000052  2214              MOVS     r2,#0x14
000054  4d0e              LDR      r5,|L31.144|
000056  4351              MULS     r1,r2,r1
000058  6960              LDR      r0,[r4,#0x14]
00005a  1949              ADDS     r1,r1,r5
00005c  4288              CMP      r0,r1
00005e  d10d              BNE      |L31.124|
;;;1652   				{
;;;1653   					/* The task is currently in its ready list - remove before
;;;1654   					adding it to it's new ready list.  As we are in a critical
;;;1655   					section we can do this even if the scheduler is suspended. */
;;;1656   					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000060  1d20              ADDS     r0,r4,#4
000062  f7fffffe          BL       uxListRemove
;;;1657   					{
;;;1658   						/* It is known that the task is in its ready list so
;;;1659   						there is no need to check again and the port level
;;;1660   						reset macro can be called directly. */
;;;1661   						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
;;;1662   					}
;;;1663   					else
;;;1664   					{
;;;1665   						mtCOVERAGE_TEST_MARKER();
;;;1666   					}
;;;1667   					prvAddTaskToReadyList( pxTCB );
000066  6ae0              LDR      r0,[r4,#0x2c]
000068  6939              LDR      r1,[r7,#0x10]  ; uxTopReadyPriority
00006a  4288              CMP      r0,r1
00006c  d900              BLS      |L31.112|
00006e  6138              STR      r0,[r7,#0x10]  ; uxTopReadyPriority
                  |L31.112|
000070  2114              MOVS     r1,#0x14
000072  4348              MULS     r0,r1,r0
000074  1940              ADDS     r0,r0,r5
000076  1d21              ADDS     r1,r4,#4
000078  f7fffffe          BL       vListInsertEnd
                  |L31.124|
;;;1668   				}
;;;1669   				else
;;;1670   				{
;;;1671   					mtCOVERAGE_TEST_MARKER();
;;;1672   				}
;;;1673   
;;;1674   				if( xYieldRequired != pdFALSE )
00007c  2e00              CMP      r6,#0
00007e  d001              BEQ      |L31.132|
;;;1675   				{
;;;1676   					taskYIELD_IF_USING_PREEMPTION();
000080  f7fffffe          BL       vPortYield
                  |L31.132|
;;;1677   				}
;;;1678   				else
;;;1679   				{
;;;1680   					mtCOVERAGE_TEST_MARKER();
;;;1681   				}
;;;1682   
;;;1683   				/* Remove compiler warning about unused variables when the port
;;;1684   				optimised task selection is not being used. */
;;;1685   				( void ) uxPriorityUsedOnEntry;
;;;1686   			}
;;;1687   		}
;;;1688   		taskEXIT_CRITICAL();
000084  f7fffffe          BL       vPortExitCritical
;;;1689   	}
000088  bdf8              POP      {r3-r7,pc}
;;;1690   
                          ENDP

00008a  0000              DCW      0x0000
                  |L31.140|
                          DCD      ||.data||
                  |L31.144|
                          DCD      ||.bss||

                          AREA ||i.vTaskRemoveFromUnorderedEventList||, CODE, READONLY, ALIGN=2

                  vTaskRemoveFromUnorderedEventList PROC
;;;3160   
;;;3161   void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
000000  b570              PUSH     {r4-r6,lr}
;;;3162   {
;;;3163   TCB_t *pxUnblockedTCB;
;;;3164   
;;;3165   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;3166   	the event flags implementation. */
;;;3167   	configASSERT( uxSchedulerSuspended != pdFALSE );
000002  4d14              LDR      r5,|L32.84|
000004  6b2a              LDR      r2,[r5,#0x30]  ; uxSchedulerSuspended
000006  2a00              CMP      r2,#0
000008  d01f              BEQ      |L32.74|
;;;3168   
;;;3169   	/* Store the new item value in the event list. */
;;;3170   	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
00000a  2201              MOVS     r2,#1
00000c  07d2              LSLS     r2,r2,#31
00000e  4311              ORRS     r1,r1,r2
;;;3171   
;;;3172   	/* Remove the event list form the event flag.  Interrupts do not access
;;;3173   	event flags. */
;;;3174   	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000010  6001              STR      r1,[r0,#0]
;;;3175   	configASSERT( pxUnblockedTCB );
000012  68c4              LDR      r4,[r0,#0xc]
000014  2c00              CMP      r4,#0
000016  d01a              BEQ      |L32.78|
;;;3176   	( void ) uxListRemove( pxEventListItem );
000018  f7fffffe          BL       uxListRemove
;;;3177   
;;;3178   	/* Remove the task from the delayed list and add it to the ready list.  The
;;;3179   	scheduler is suspended so interrupts will not be accessing the ready
;;;3180   	lists. */
;;;3181   	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
00001c  1d20              ADDS     r0,r4,#4
00001e  f7fffffe          BL       uxListRemove
;;;3182   	prvAddTaskToReadyList( pxUnblockedTCB );
000022  6ae0              LDR      r0,[r4,#0x2c]
000024  6929              LDR      r1,[r5,#0x10]  ; uxTopReadyPriority
000026  4288              CMP      r0,r1
000028  d900              BLS      |L32.44|
00002a  6128              STR      r0,[r5,#0x10]  ; uxTopReadyPriority
                  |L32.44|
00002c  2114              MOVS     r1,#0x14
00002e  4348              MULS     r0,r1,r0
000030  4909              LDR      r1,|L32.88|
000032  1840              ADDS     r0,r0,r1
000034  1d21              ADDS     r1,r4,#4
000036  f7fffffe          BL       vListInsertEnd
;;;3183   
;;;3184   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
00003a  6ae0              LDR      r0,[r4,#0x2c]
00003c  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
00003e  6ac9              LDR      r1,[r1,#0x2c]
000040  4288              CMP      r0,r1
000042  d901              BLS      |L32.72|
;;;3185   	{
;;;3186   		/* The unblocked task has a priority above that of the calling task, so
;;;3187   		a context switch is required.  This function is called with the
;;;3188   		scheduler suspended so xYieldPending is set so the context switch
;;;3189   		occurs immediately that the scheduler is resumed (unsuspended). */
;;;3190   		xYieldPending = pdTRUE;
000044  2001              MOVS     r0,#1
000046  61e8              STR      r0,[r5,#0x1c]  ; xYieldPending
                  |L32.72|
;;;3191   	}
;;;3192   }
000048  bd70              POP      {r4-r6,pc}
                  |L32.74|
00004a  b672              CPSID    i                     ;3167
                  |L32.76|
00004c  e7fe              B        |L32.76|
                  |L32.78|
00004e  b672              CPSID    i                     ;3175
                  |L32.80|
000050  e7fe              B        |L32.80|
;;;3193   /*-----------------------------------------------------------*/
                          ENDP

000052  0000              DCW      0x0000
                  |L32.84|
                          DCD      ||.data||
                  |L32.88|
                          DCD      ||.bss||

                          AREA ||i.vTaskResume||, CODE, READONLY, ALIGN=2

                  vTaskResume PROC
;;;1842   
;;;1843   	void vTaskResume( TaskHandle_t xTaskToResume )
000000  b570              PUSH     {r4-r6,lr}
;;;1844   	{
;;;1845   	TCB_t * const pxTCB = xTaskToResume;
000002  0004              MOVS     r4,r0
000004  d023              BEQ      |L33.78|
;;;1846   
;;;1847   		/* It does not make sense to resume the calling task. */
;;;1848   		configASSERT( xTaskToResume );
;;;1849   
;;;1850   		/* The parameter cannot be NULL as it is impossible to resume the
;;;1851   		currently executing task. */
;;;1852   		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
000006  4d13              LDR      r5,|L33.84|
000008  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00000a  4284              CMP      r4,r0
00000c  d01e              BEQ      |L33.76|
;;;1853   		{
;;;1854   			taskENTER_CRITICAL();
00000e  f7fffffe          BL       vPortEnterCritical
;;;1855   			{
;;;1856   				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       prvTaskIsTaskSuspended
000018  2800              CMP      r0,#0
00001a  d015              BEQ      |L33.72|
;;;1857   				{
;;;1858   					traceTASK_RESUME( pxTCB );
;;;1859   
;;;1860   					/* The ready list can be accessed even if the scheduler is
;;;1861   					suspended because this is inside a critical section. */
;;;1862   					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
00001c  1d20              ADDS     r0,r4,#4
00001e  f7fffffe          BL       uxListRemove
;;;1863   					prvAddTaskToReadyList( pxTCB );
000022  6ae0              LDR      r0,[r4,#0x2c]
000024  6929              LDR      r1,[r5,#0x10]  ; uxTopReadyPriority
000026  4288              CMP      r0,r1
000028  d900              BLS      |L33.44|
00002a  6128              STR      r0,[r5,#0x10]  ; uxTopReadyPriority
                  |L33.44|
00002c  2114              MOVS     r1,#0x14
00002e  4348              MULS     r0,r1,r0
000030  4909              LDR      r1,|L33.88|
000032  1840              ADDS     r0,r0,r1
000034  1d21              ADDS     r1,r4,#4
000036  f7fffffe          BL       vListInsertEnd
;;;1864   
;;;1865   					/* A higher priority task may have just been resumed. */
;;;1866   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
00003a  6ae0              LDR      r0,[r4,#0x2c]
00003c  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
00003e  6ac9              LDR      r1,[r1,#0x2c]
000040  4288              CMP      r0,r1
000042  d301              BCC      |L33.72|
;;;1867   					{
;;;1868   						/* This yield may not cause the task just resumed to run,
;;;1869   						but will leave the lists in the correct state for the
;;;1870   						next yield. */
;;;1871   						taskYIELD_IF_USING_PREEMPTION();
000044  f7fffffe          BL       vPortYield
                  |L33.72|
;;;1872   					}
;;;1873   					else
;;;1874   					{
;;;1875   						mtCOVERAGE_TEST_MARKER();
;;;1876   					}
;;;1877   				}
;;;1878   				else
;;;1879   				{
;;;1880   					mtCOVERAGE_TEST_MARKER();
;;;1881   				}
;;;1882   			}
;;;1883   			taskEXIT_CRITICAL();
000048  f7fffffe          BL       vPortExitCritical
                  |L33.76|
;;;1884   		}
;;;1885   		else
;;;1886   		{
;;;1887   			mtCOVERAGE_TEST_MARKER();
;;;1888   		}
;;;1889   	}
00004c  bd70              POP      {r4-r6,pc}
                  |L33.78|
00004e  b672              CPSID    i                     ;1848
                  |L33.80|
000050  e7fe              B        |L33.80|
;;;1890   
                          ENDP

000052  0000              DCW      0x0000
                  |L33.84|
                          DCD      ||.data||
                  |L33.88|
                          DCD      ||.bss||

                          AREA ||i.vTaskSetTaskNumber||, CODE, READONLY, ALIGN=1

                  vTaskSetTaskNumber PROC
;;;3308   
;;;3309   	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
000000  2800              CMP      r0,#0
;;;3310   	{
000002  d000              BEQ      |L34.6|
;;;3311   	TCB_t * pxTCB;
;;;3312   
;;;3313   		if( xTask != NULL )
;;;3314   		{
;;;3315   			pxTCB = xTask;
;;;3316   			pxTCB->uxTaskNumber = uxHandle;
000004  6481              STR      r1,[r0,#0x48]
                  |L34.6|
;;;3317   		}
;;;3318   	}
000006  4770              BX       lr
;;;3319   
                          ENDP


                          AREA ||i.vTaskSetTimeOutState||, CODE, READONLY, ALIGN=2

                  vTaskSetTimeOutState PROC
;;;3194   
;;;3195   void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
000000  b510              PUSH     {r4,lr}
;;;3196   {
000002  0004              MOVS     r4,r0
000004  d009              BEQ      |L35.26|
;;;3197   	configASSERT( pxTimeOut );
;;;3198   	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;3199   	{
;;;3200   		pxTimeOut->xOverflowCount = xNumOfOverflows;
00000a  4805              LDR      r0,|L35.32|
00000c  6a01              LDR      r1,[r0,#0x20]  ; xNumOfOverflows
;;;3201   		pxTimeOut->xTimeOnEntering = xTickCount;
00000e  6021              STR      r1,[r4,#0]
000010  68c0              LDR      r0,[r0,#0xc]  ; xTickCount
;;;3202   	}
;;;3203   	taskEXIT_CRITICAL();
000012  6060              STR      r0,[r4,#4]
000014  f7fffffe          BL       vPortExitCritical
;;;3204   }
000018  bd10              POP      {r4,pc}
                  |L35.26|
00001a  b672              CPSID    i                     ;3197
                  |L35.28|
00001c  e7fe              B        |L35.28|
;;;3205   /*-----------------------------------------------------------*/
                          ENDP

00001e  0000              DCW      0x0000
                  |L35.32|
                          DCD      ||.data||

                          AREA ||i.vTaskStartScheduler||, CODE, READONLY, ALIGN=2

                  vTaskStartScheduler PROC
;;;1966   
;;;1967   void vTaskStartScheduler( void )
000000  b51c              PUSH     {r2-r4,lr}
;;;1968   {
;;;1969   BaseType_t xReturn;
;;;1970   
;;;1971   	/* Add the idle task at the lowest priority. */
;;;1972   	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;1973   	{
;;;1974   		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
;;;1975   		StackType_t *pxIdleTaskStackBuffer = NULL;
;;;1976   		uint32_t ulIdleTaskStackSize;
;;;1977   
;;;1978   		/* The Idle task is created using user provided RAM - obtain the
;;;1979   		address of the RAM then create the idle task. */
;;;1980   		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
;;;1981   		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
;;;1982   												configIDLE_TASK_NAME,
;;;1983   												ulIdleTaskStackSize,
;;;1984   												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
;;;1985   												portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */
;;;1986   												pxIdleTaskStackBuffer,
;;;1987   												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;1988   
;;;1989   		if( xIdleTaskHandle != NULL )
;;;1990   		{
;;;1991   			xReturn = pdPASS;
;;;1992   		}
;;;1993   		else
;;;1994   		{
;;;1995   			xReturn = pdFAIL;
;;;1996   		}
;;;1997   	}
;;;1998   	#else
;;;1999   	{
;;;2000   		/* The Idle task is being created using dynamically allocated RAM. */
;;;2001   		xReturn = xTaskCreate(	prvIdleTask,
000002  4810              LDR      r0,|L36.68|
000004  2400              MOVS     r4,#0
000006  9001              STR      r0,[sp,#4]
000008  4623              MOV      r3,r4
00000a  2280              MOVS     r2,#0x80
00000c  a10e              ADR      r1,|L36.72|
00000e  9400              STR      r4,[sp,#0]
000010  480f              LDR      r0,|L36.80|
000012  f7fffffe          BL       xTaskCreate
;;;2002   								configIDLE_TASK_NAME,
;;;2003   								configMINIMAL_STACK_SIZE,
;;;2004   								( void * ) NULL,
;;;2005   								portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */
;;;2006   								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;2007   	}
;;;2008   	#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;2009   
;;;2010   	#if ( configUSE_TIMERS == 1 )
;;;2011   	{
;;;2012   		if( xReturn == pdPASS )
000016  2801              CMP      r0,#1
000018  d103              BNE      |L36.34|
;;;2013   		{
;;;2014   			xReturn = xTimerCreateTimerTask();
00001a  f7fffffe          BL       xTimerCreateTimerTask
;;;2015   		}
;;;2016   		else
;;;2017   		{
;;;2018   			mtCOVERAGE_TEST_MARKER();
;;;2019   		}
;;;2020   	}
;;;2021   	#endif /* configUSE_TIMERS */
;;;2022   
;;;2023   	if( xReturn == pdPASS )
00001e  2801              CMP      r0,#1
000020  d003              BEQ      |L36.42|
                  |L36.34|
000022  1c40              ADDS     r0,r0,#1              ;2014
;;;2024   	{
;;;2025   		/* freertos_tasks_c_additions_init() should only be called if the user
;;;2026   		definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
;;;2027   		the only macro called by the function. */
;;;2028   		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
;;;2029   		{
;;;2030   			freertos_tasks_c_additions_init();
;;;2031   		}
;;;2032   		#endif
;;;2033   
;;;2034   		/* Interrupts are turned off here, to ensure a tick does not occur
;;;2035   		before or during the call to xPortStartScheduler().  The stacks of
;;;2036   		the created tasks contain a status word with interrupts switched on
;;;2037   		so interrupts will automatically get re-enabled when the first task
;;;2038   		starts to run. */
;;;2039   		portDISABLE_INTERRUPTS();
;;;2040   
;;;2041   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;2042   		{
;;;2043   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;2044   			structure specific to the task that will run first. */
;;;2045   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;2046   		}
;;;2047   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;2048   
;;;2049   		xNextTaskUnblockTime = portMAX_DELAY;
;;;2050   		xSchedulerRunning = pdTRUE;
;;;2051   		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
;;;2052   
;;;2053   		/* If configGENERATE_RUN_TIME_STATS is defined then the following
;;;2054   		macro must be defined to configure the timer/counter used to generate
;;;2055   		the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
;;;2056   		is set to 0 and the following line fails to build then ensure you do not
;;;2057   		have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
;;;2058   		FreeRTOSConfig.h file. */
;;;2059   		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
;;;2060   
;;;2061   		traceTASK_SWITCHED_IN();
;;;2062   
;;;2063   		/* Setting up the timer tick is hardware specific and thus in the
;;;2064   		portable interface. */
;;;2065   		if( xPortStartScheduler() != pdFALSE )
;;;2066   		{
;;;2067   			/* Should not reach here as if the scheduler is running the
;;;2068   			function will not return. */
;;;2069   		}
;;;2070   		else
;;;2071   		{
;;;2072   			/* Should only reach here if a task calls xTaskEndScheduler(). */
;;;2073   		}
;;;2074   	}
;;;2075   	else
;;;2076   	{
;;;2077   		/* This line will only be reached if the kernel could not be started,
;;;2078   		because there was not enough FreeRTOS heap to create the idle task
;;;2079   		or the timer task. */
;;;2080   		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
000024  d10c              BNE      |L36.64|
000026  b672              CPSID    i
                  |L36.40|
000028  e7fe              B        |L36.40|
                  |L36.42|
00002a  b672              CPSID    i                     ;2039
00002c  2100              MOVS     r1,#0                 ;2049
00002e  4805              LDR      r0,|L36.68|
000030  43c9              MVNS     r1,r1                 ;2049
000032  382c              SUBS     r0,r0,#0x2c           ;2049
000034  6281              STR      r1,[r0,#0x28]         ;2049  ; xNextTaskUnblockTime
000036  2101              MOVS     r1,#1                 ;2050
000038  6141              STR      r1,[r0,#0x14]         ;2050  ; xSchedulerRunning
00003a  60c4              STR      r4,[r0,#0xc]          ;2051  ; xTickCount
00003c  f7fffffe          BL       xPortStartScheduler
                  |L36.64|
;;;2081   	}
;;;2082   
;;;2083   	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
;;;2084   	meaning xIdleTaskHandle is not used anywhere else. */
;;;2085   	( void ) xIdleTaskHandle;
;;;2086   }
000040  bd1c              POP      {r2-r4,pc}
;;;2087   /*-----------------------------------------------------------*/
                          ENDP

000042  0000              DCW      0x0000
                  |L36.68|
                          DCD      ||.data||+0x2c
                  |L36.72|
000048  49444c45          DCB      "IDLE",0
00004c  00      
00004d  00                DCB      0
00004e  00                DCB      0
00004f  00                DCB      0
                  |L36.80|
                          DCD      prvIdleTask

                          AREA ||i.vTaskSuspend||, CODE, READONLY, ALIGN=2

                  vTaskSuspend PROC
;;;1695   
;;;1696   	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
000000  b570              PUSH     {r4-r6,lr}
;;;1697   	{
000002  4604              MOV      r4,r0
;;;1698   	TCB_t *pxTCB;
;;;1699   
;;;1700   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1701   		{
;;;1702   			/* If null is passed in here then it is the running task that is
;;;1703   			being suspended. */
;;;1704   			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
000008  4d1d              LDR      r5,|L37.128|
00000a  2c00              CMP      r4,#0
00000c  d100              BNE      |L37.16|
00000e  682c              LDR      r4,[r5,#0]  ; pxCurrentTCB
                  |L37.16|
;;;1705   
;;;1706   			traceTASK_SUSPEND( pxTCB );
;;;1707   
;;;1708   			/* Remove task from the ready/delayed list and place in the
;;;1709   			suspended list. */
;;;1710   			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000010  1d20              ADDS     r0,r4,#4
000012  f7fffffe          BL       uxListRemove
;;;1711   			{
;;;1712   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;1713   			}
;;;1714   			else
;;;1715   			{
;;;1716   				mtCOVERAGE_TEST_MARKER();
;;;1717   			}
;;;1718   
;;;1719   			/* Is the task waiting on an event also? */
;;;1720   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
000016  6aa0              LDR      r0,[r4,#0x28]
000018  2800              CMP      r0,#0
00001a  d003              BEQ      |L37.36|
;;;1721   			{
;;;1722   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
00001c  4620              MOV      r0,r4
00001e  3018              ADDS     r0,r0,#0x18
000020  f7fffffe          BL       uxListRemove
                  |L37.36|
;;;1723   			}
;;;1724   			else
;;;1725   			{
;;;1726   				mtCOVERAGE_TEST_MARKER();
;;;1727   			}
;;;1728   
;;;1729   			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
000024  1d21              ADDS     r1,r4,#4
000026  4817              LDR      r0,|L37.132|
000028  f7fffffe          BL       vListInsertEnd
;;;1730   
;;;1731   			#if( configUSE_TASK_NOTIFICATIONS == 1 )
;;;1732   			{
;;;1733   				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
00002c  4620              MOV      r0,r4
00002e  3040              ADDS     r0,r0,#0x40
000030  7e01              LDRB     r1,[r0,#0x18]
000032  2600              MOVS     r6,#0
000034  2901              CMP      r1,#1
000036  d100              BNE      |L37.58|
;;;1734   				{
;;;1735   					/* The task was blocked to wait for a notification, but is
;;;1736   					now suspended, so no notification was received. */
;;;1737   					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
000038  7606              STRB     r6,[r0,#0x18]
                  |L37.58|
;;;1738   				}
;;;1739   			}
;;;1740   			#endif
;;;1741   		}
;;;1742   		taskEXIT_CRITICAL();
00003a  f7fffffe          BL       vPortExitCritical
;;;1743   
;;;1744   		if( xSchedulerRunning != pdFALSE )
00003e  6968              LDR      r0,[r5,#0x14]  ; xSchedulerRunning
000040  2800              CMP      r0,#0
000042  d005              BEQ      |L37.80|
;;;1745   		{
;;;1746   			/* Reset the next expected unblock time in case it referred to the
;;;1747   			task that is now in the Suspended state. */
;;;1748   			taskENTER_CRITICAL();
000044  f7fffffe          BL       vPortEnterCritical
;;;1749   			{
;;;1750   				prvResetNextTaskUnblockTime();
000048  f7fffffe          BL       prvResetNextTaskUnblockTime
;;;1751   			}
;;;1752   			taskEXIT_CRITICAL();
00004c  f7fffffe          BL       vPortExitCritical
                  |L37.80|
;;;1753   		}
;;;1754   		else
;;;1755   		{
;;;1756   			mtCOVERAGE_TEST_MARKER();
;;;1757   		}
;;;1758   
;;;1759   		if( pxTCB == pxCurrentTCB )
000050  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000052  4284              CMP      r4,r0
000054  d109              BNE      |L37.106|
;;;1760   		{
;;;1761   			if( xSchedulerRunning != pdFALSE )
000056  6968              LDR      r0,[r5,#0x14]  ; xSchedulerRunning
000058  2800              CMP      r0,#0
00005a  d007              BEQ      |L37.108|
;;;1762   			{
;;;1763   				/* The current task has just been suspended. */
;;;1764   				configASSERT( uxSchedulerSuspended == 0 );
00005c  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
00005e  2800              CMP      r0,#0
000060  d001              BEQ      |L37.102|
000062  b672              CPSID    i
                  |L37.100|
000064  e7fe              B        |L37.100|
                  |L37.102|
;;;1765   				portYIELD_WITHIN_API();
000066  f7fffffe          BL       vPortYield
                  |L37.106|
;;;1766   			}
;;;1767   			else
;;;1768   			{
;;;1769   				/* The scheduler is not running, but the task that was pointed
;;;1770   				to by pxCurrentTCB has just been suspended and pxCurrentTCB
;;;1771   				must be adjusted to point to a different task. */
;;;1772   				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
;;;1773   				{
;;;1774   					/* No other tasks are ready, so set pxCurrentTCB back to
;;;1775   					NULL so when the next task is created pxCurrentTCB will
;;;1776   					be set to point to it no matter what its relative priority
;;;1777   					is. */
;;;1778   					pxCurrentTCB = NULL;
;;;1779   				}
;;;1780   				else
;;;1781   				{
;;;1782   					vTaskSwitchContext();
;;;1783   				}
;;;1784   			}
;;;1785   		}
;;;1786   		else
;;;1787   		{
;;;1788   			mtCOVERAGE_TEST_MARKER();
;;;1789   		}
;;;1790   	}
00006a  bd70              POP      {r4-r6,pc}
                  |L37.108|
00006c  4805              LDR      r0,|L37.132|
00006e  6800              LDR      r0,[r0,#0]            ;1772  ; xSuspendedTaskList
000070  68a9              LDR      r1,[r5,#8]            ;1772  ; uxCurrentNumberOfTasks
000072  4288              CMP      r0,r1                 ;1772
000074  d101              BNE      |L37.122|
000076  602e              STR      r6,[r5,#0]            ;1778  ; pxCurrentTCB
000078  bd70              POP      {r4-r6,pc}
                  |L37.122|
00007a  f7fffffe          BL       vTaskSwitchContext
00007e  bd70              POP      {r4-r6,pc}
;;;1791   
                          ENDP

                  |L37.128|
                          DCD      ||.data||
                  |L37.132|
                          DCD      ||.bss||+0xb4

                          AREA ||i.vTaskSuspendAll||, CODE, READONLY, ALIGN=2

                  vTaskSuspendAll PROC
;;;2099   
;;;2100   void vTaskSuspendAll( void )
000000  4802              LDR      r0,|L38.12|
;;;2101   {
;;;2102   	/* A critical section is not required as the variable is of type
;;;2103   	BaseType_t.  Please read Richard Barry's reply in the following link to a
;;;2104   	post in the FreeRTOS support forum before reporting this as a bug! -
;;;2105   	http://goo.gl/wu4acr */
;;;2106   	++uxSchedulerSuspended;
000002  6b01              LDR      r1,[r0,#0x30]  ; uxSchedulerSuspended
000004  1c49              ADDS     r1,r1,#1
000006  6301              STR      r1,[r0,#0x30]  ; uxSchedulerSuspended
;;;2107   }
000008  4770              BX       lr
;;;2108   /*----------------------------------------------------------*/
                          ENDP

00000a  0000              DCW      0x0000
                  |L38.12|
                          DCD      ||.data||

                          AREA ||i.vTaskSwitchContext||, CODE, READONLY, ALIGN=2

                  vTaskSwitchContext PROC
;;;2945   
;;;2946   void vTaskSwitchContext( void )
000000  b510              PUSH     {r4,lr}
;;;2947   {
;;;2948   	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
000002  4c1d              LDR      r4,|L39.120|
000004  6b20              LDR      r0,[r4,#0x30]  ; uxSchedulerSuspended
000006  2800              CMP      r0,#0
000008  d002              BEQ      |L39.16|
;;;2949   	{
;;;2950   		/* The scheduler is currently suspended - do not allow a context
;;;2951   		switch. */
;;;2952   		xYieldPending = pdTRUE;
00000a  2001              MOVS     r0,#1
00000c  61e0              STR      r0,[r4,#0x1c]  ; xYieldPending
;;;2953   	}
;;;2954   	else
;;;2955   	{
;;;2956   		xYieldPending = pdFALSE;
;;;2957   		traceTASK_SWITCHED_OUT();
;;;2958   
;;;2959   		#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;2960   		{
;;;2961   			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
;;;2962   				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
;;;2963   			#else
;;;2964   				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
;;;2965   			#endif
;;;2966   
;;;2967   			/* Add the amount of time the task has been running to the
;;;2968   			accumulated time so far.  The time the task started running was
;;;2969   			stored in ulTaskSwitchedInTime.  Note that there is no overflow
;;;2970   			protection here so count values are only valid until the timer
;;;2971   			overflows.  The guard against negative values is to protect
;;;2972   			against suspect run time stat counter implementations - which
;;;2973   			are provided by the application, not the kernel. */
;;;2974   			if( ulTotalRunTime > ulTaskSwitchedInTime )
;;;2975   			{
;;;2976   				pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
;;;2977   			}
;;;2978   			else
;;;2979   			{
;;;2980   				mtCOVERAGE_TEST_MARKER();
;;;2981   			}
;;;2982   			ulTaskSwitchedInTime = ulTotalRunTime;
;;;2983   		}
;;;2984   		#endif /* configGENERATE_RUN_TIME_STATS */
;;;2985   
;;;2986   		/* Check for stack overflow, if configured. */
;;;2987   		taskCHECK_FOR_STACK_OVERFLOW();
;;;2988   
;;;2989   		/* Before the currently running task is switched out, save its errno. */
;;;2990   		#if( configUSE_POSIX_ERRNO == 1 )
;;;2991   		{
;;;2992   			pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
;;;2993   		}
;;;2994   		#endif
;;;2995   
;;;2996   		/* Select a new task to run using either the generic C or port
;;;2997   		optimised asm code. */
;;;2998   		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
;;;2999   		traceTASK_SWITCHED_IN();
;;;3000   
;;;3001   		/* After the new task is switched in, update the global errno. */
;;;3002   		#if( configUSE_POSIX_ERRNO == 1 )
;;;3003   		{
;;;3004   			FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
;;;3005   		}
;;;3006   		#endif
;;;3007   
;;;3008   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;3009   		{
;;;3010   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;3011   			structure specific to this task. */
;;;3012   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;3013   		}
;;;3014   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;3015   	}
;;;3016   }
00000e  bd10              POP      {r4,pc}
                  |L39.16|
000010  2000              MOVS     r0,#0                 ;2956
000012  61e0              STR      r0,[r4,#0x1c]         ;2956  ; xYieldPending
000014  6820              LDR      r0,[r4,#0]            ;2987  ; pxCurrentTCB
000016  4919              LDR      r1,|L39.124|
000018  6b00              LDR      r0,[r0,#0x30]         ;2987
00001a  6802              LDR      r2,[r0,#0]            ;2987
00001c  428a              CMP      r2,r1                 ;2987
00001e  d108              BNE      |L39.50|
000020  6842              LDR      r2,[r0,#4]            ;2987
000022  428a              CMP      r2,r1                 ;2987
000024  d105              BNE      |L39.50|
000026  6882              LDR      r2,[r0,#8]            ;2987
000028  428a              CMP      r2,r1                 ;2987
00002a  d102              BNE      |L39.50|
00002c  68c0              LDR      r0,[r0,#0xc]          ;2987
00002e  4288              CMP      r0,r1                 ;2987
000030  d004              BEQ      |L39.60|
                  |L39.50|
000032  6821              LDR      r1,[r4,#0]            ;2987  ; pxCurrentTCB
000034  6820              LDR      r0,[r4,#0]            ;2987  ; pxCurrentTCB
000036  3134              ADDS     r1,r1,#0x34           ;2987
000038  f7fffffe          BL       vApplicationStackOverflowHook
                  |L39.60|
00003c  6920              LDR      r0,[r4,#0x10]         ;2998  ; uxTopReadyPriority
00003e  4910              LDR      r1,|L39.128|
000040  e002              B        |L39.72|
                  |L39.66|
000042  2800              CMP      r0,#0                 ;2998
000044  d015              BEQ      |L39.114|
000046  1e40              SUBS     r0,r0,#1              ;2998
                  |L39.72|
000048  2214              MOVS     r2,#0x14              ;2998
00004a  4342              MULS     r2,r0,r2              ;2998
00004c  588a              LDR      r2,[r1,r2]            ;2998
00004e  2a00              CMP      r2,#0                 ;2998
000050  d0f7              BEQ      |L39.66|
000052  2214              MOVS     r2,#0x14              ;2998
000054  4342              MULS     r2,r0,r2              ;2998
000056  1851              ADDS     r1,r2,r1              ;2998
000058  684a              LDR      r2,[r1,#4]            ;2998
00005a  460b              MOV      r3,r1                 ;2998
00005c  6852              LDR      r2,[r2,#4]            ;2998
00005e  3308              ADDS     r3,r3,#8              ;2998
000060  604a              STR      r2,[r1,#4]            ;2998
000062  429a              CMP      r2,r3                 ;2998
000064  d101              BNE      |L39.106|
000066  6852              LDR      r2,[r2,#4]            ;2998
000068  604a              STR      r2,[r1,#4]            ;2998
                  |L39.106|
00006a  68d1              LDR      r1,[r2,#0xc]          ;2998
00006c  6021              STR      r1,[r4,#0]            ;2998  ; pxCurrentTCB
00006e  6120              STR      r0,[r4,#0x10]         ;2998  ; uxTopReadyPriority
000070  bd10              POP      {r4,pc}
                  |L39.114|
000072  b672              CPSID    i                     ;2998
                  |L39.116|
000074  e7fe              B        |L39.116|
;;;3017   /*-----------------------------------------------------------*/
                          ENDP

000076  0000              DCW      0x0000
                  |L39.120|
                          DCD      ||.data||
                  |L39.124|
                          DCD      0xa5a5a5a5
                  |L39.128|
                          DCD      ||.bss||

                          AREA ||i.xTaskCheckForTimeOut||, CODE, READONLY, ALIGN=2

                  xTaskCheckForTimeOut PROC
;;;3214   
;;;3215   BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
000000  b5f8              PUSH     {r3-r7,lr}
;;;3216   {
000002  460c              MOV      r4,r1
000004  0005              MOVS     r5,r0
000006  d012              BEQ      |L40.46|
;;;3217   BaseType_t xReturn;
;;;3218   
;;;3219   	configASSERT( pxTimeOut );
;;;3220   	configASSERT( pxTicksToWait );
000008  2c00              CMP      r4,#0
00000a  d012              BEQ      |L40.50|
;;;3221   
;;;3222   	taskENTER_CRITICAL();
00000c  f7fffffe          BL       vPortEnterCritical
;;;3223   	{
;;;3224   		/* Minor optimisation.  The tick count cannot change in this block. */
;;;3225   		const TickType_t xConstTickCount = xTickCount;
000010  4e11              LDR      r6,|L40.88|
000012  68f1              LDR      r1,[r6,#0xc]  ; xTickCount
;;;3226   		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
000014  686b              LDR      r3,[r5,#4]
;;;3227   
;;;3228   		#if( INCLUDE_xTaskAbortDelay == 1 )
;;;3229   			if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
;;;3230   			{
;;;3231   				/* The delay was aborted, which is not the same as a time out,
;;;3232   				but has the same result. */
;;;3233   				pxCurrentTCB->ucDelayAborted = pdFALSE;
;;;3234   				xReturn = pdTRUE;
;;;3235   			}
;;;3236   			else
;;;3237   		#endif
;;;3238   
;;;3239   		#if ( INCLUDE_vTaskSuspend == 1 )
;;;3240   			if( *pxTicksToWait == portMAX_DELAY )
000016  6820              LDR      r0,[r4,#0]
000018  1aca              SUBS     r2,r1,r3              ;3226
00001a  1c47              ADDS     r7,r0,#1
00001c  d00b              BEQ      |L40.54|
;;;3241   			{
;;;3242   				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
;;;3243   				specified is the maximum block time then the task should block
;;;3244   				indefinitely, and therefore never time out. */
;;;3245   				xReturn = pdFALSE;
;;;3246   			}
;;;3247   			else
;;;3248   		#endif
;;;3249   
;;;3250   		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
00001e  682f              LDR      r7,[r5,#0]
000020  6a36              LDR      r6,[r6,#0x20]  ; xNumOfOverflows
000022  42b7              CMP      r7,r6
000024  d00c              BEQ      |L40.64|
000026  428b              CMP      r3,r1
000028  d80a              BHI      |L40.64|
                  |L40.42|
;;;3251   		{
;;;3252   			/* The tick count is greater than the time at which
;;;3253   			vTaskSetTimeout() was called, but has also overflowed since
;;;3254   			vTaskSetTimeOut() was called.  It must have wrapped all the way
;;;3255   			around and gone past again. This passed since vTaskSetTimeout()
;;;3256   			was called. */
;;;3257   			xReturn = pdTRUE;
00002a  2401              MOVS     r4,#1
00002c  e004              B        |L40.56|
                  |L40.46|
00002e  b672              CPSID    i                     ;3219
                  |L40.48|
000030  e7fe              B        |L40.48|
                  |L40.50|
000032  b672              CPSID    i                     ;3220
                  |L40.52|
000034  e7fe              B        |L40.52|
                  |L40.54|
000036  2400              MOVS     r4,#0                 ;3245
                  |L40.56|
;;;3258   		}
;;;3259   		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
;;;3260   		{
;;;3261   			/* Not a genuine timeout. Adjust parameters for time remaining. */
;;;3262   			*pxTicksToWait -= xElapsedTime;
;;;3263   			vTaskInternalSetTimeOutState( pxTimeOut );
;;;3264   			xReturn = pdFALSE;
;;;3265   		}
;;;3266   		else
;;;3267   		{
;;;3268   			*pxTicksToWait = 0;
;;;3269   			xReturn = pdTRUE;
;;;3270   		}
;;;3271   	}
;;;3272   	taskEXIT_CRITICAL();
000038  f7fffffe          BL       vPortExitCritical
;;;3273   
;;;3274   	return xReturn;
00003c  4620              MOV      r0,r4
;;;3275   }
00003e  bdf8              POP      {r3-r7,pc}
                  |L40.64|
000040  4290              CMP      r0,r2                 ;3259
000042  d905              BLS      |L40.80|
000044  1a80              SUBS     r0,r0,r2              ;3262
000046  6020              STR      r0,[r4,#0]            ;3263
000048  4628              MOV      r0,r5                 ;3263
00004a  f7fffffe          BL       vTaskInternalSetTimeOutState
00004e  e7f2              B        |L40.54|
                  |L40.80|
000050  2000              MOVS     r0,#0                 ;3268
000052  6020              STR      r0,[r4,#0]            ;3269
000054  e7e9              B        |L40.42|
;;;3276   /*-----------------------------------------------------------*/
                          ENDP

000056  0000              DCW      0x0000
                  |L40.88|
                          DCD      ||.data||

                          AREA ||i.xTaskCreate||, CODE, READONLY, ALIGN=1

                  xTaskCreate PROC
;;;729    
;;;730    	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
000000  b5ff              PUSH     {r0-r7,lr}
;;;731    							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;;;732    							const configSTACK_DEPTH_TYPE usStackDepth,
;;;733    							void * const pvParameters,
;;;734    							UBaseType_t uxPriority,
;;;735    							TaskHandle_t * const pxCreatedTask )
;;;736    	{
000002  b085              SUB      sp,sp,#0x14
000004  4616              MOV      r6,r2
;;;737    	TCB_t *pxNewTCB;
;;;738    	BaseType_t xReturn;
;;;739    
;;;740    		/* If the stack grows down then allocate the stack then the TCB so the stack
;;;741    		does not grow into the TCB.  Likewise if the stack grows up then allocate
;;;742    		the TCB then the stack. */
;;;743    		#if( portSTACK_GROWTH > 0 )
;;;744    		{
;;;745    			/* Allocate space for the TCB.  Where the memory comes from depends on
;;;746    			the implementation of the port malloc function and whether or not static
;;;747    			allocation is being used. */
;;;748    			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
;;;749    
;;;750    			if( pxNewTCB != NULL )
;;;751    			{
;;;752    				/* Allocate space for the stack used by the task being created.
;;;753    				The base of the stack memory stored in the TCB so the task can
;;;754    				be deleted later if required. */
;;;755    				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
;;;756    
;;;757    				if( pxNewTCB->pxStack == NULL )
;;;758    				{
;;;759    					/* Could not allocate the stack.  Delete the allocated TCB. */
;;;760    					vPortFree( pxNewTCB );
;;;761    					pxNewTCB = NULL;
;;;762    				}
;;;763    			}
;;;764    		}
;;;765    		#else /* portSTACK_GROWTH */
;;;766    		{
;;;767    		StackType_t *pxStack;
;;;768    
;;;769    			/* Allocate space for the stack used by the task being created. */
;;;770    			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
000006  0090              LSLS     r0,r2,#2
000008  9f0f              LDR      r7,[sp,#0x3c]
00000a  f7fffffe          BL       pvPortMalloc
00000e  0005              MOVS     r5,r0
;;;771    
;;;772    			if( pxStack != NULL )
000010  d01a              BEQ      |L41.72|
;;;773    			{
;;;774    				/* Allocate space for the TCB. */
;;;775    				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
000012  205c              MOVS     r0,#0x5c
000014  f7fffffe          BL       pvPortMalloc
000018  0004              MOVS     r4,r0
;;;776    
;;;777    				if( pxNewTCB != NULL )
00001a  d012              BEQ      |L41.66|
;;;778    				{
;;;779    					/* Store the stack location in the TCB. */
;;;780    					pxNewTCB->pxStack = pxStack;
;;;781    				}
;;;782    				else
;;;783    				{
;;;784    					/* The stack cannot be used as the TCB was not created.  Free
;;;785    					it again. */
;;;786    					vPortFree( pxStack );
;;;787    				}
;;;788    			}
;;;789    			else
;;;790    			{
;;;791    				pxNewTCB = NULL;
;;;792    			}
;;;793    		}
;;;794    		#endif /* portSTACK_GROWTH */
;;;795    
;;;796    		if( pxNewTCB != NULL )
;;;797    		{
;;;798    			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been consolidated for readability reasons. */
;;;799    			{
;;;800    				/* Tasks can be created statically or dynamically, so note this
;;;801    				task was created dynamically in case it is later deleted. */
;;;802    				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
;;;803    			}
;;;804    			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
;;;805    
;;;806    			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
00001c  6325              STR      r5,[r4,#0x30]
00001e  2100              MOVS     r1,#0
000020  980e              LDR      r0,[sp,#0x38]
000022  9103              STR      r1,[sp,#0xc]
000024  9701              STR      r7,[sp,#4]
000026  9000              STR      r0,[sp,#0]
000028  9402              STR      r4,[sp,#8]
00002a  4632              MOV      r2,r6
00002c  9b08              LDR      r3,[sp,#0x20]
00002e  9906              LDR      r1,[sp,#0x18]
000030  9805              LDR      r0,[sp,#0x14]
000032  f7fffffe          BL       prvInitialiseNewTask
;;;807    			prvAddNewTaskToReadyList( pxNewTCB );
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       prvAddNewTaskToReadyList
;;;808    			xReturn = pdPASS;
00003c  2001              MOVS     r0,#1
                  |L41.62|
;;;809    		}
;;;810    		else
;;;811    		{
;;;812    			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
;;;813    		}
;;;814    
;;;815    		return xReturn;
;;;816    	}
00003e  b009              ADD      sp,sp,#0x24
000040  bdf0              POP      {r4-r7,pc}
                  |L41.66|
000042  4628              MOV      r0,r5                 ;786
000044  f7fffffe          BL       vPortFree
                  |L41.72|
000048  2000              MOVS     r0,#0                 ;812
00004a  43c0              MVNS     r0,r0                 ;812
00004c  e7f7              B        |L41.62|
;;;817    
                          ENDP


                          AREA ||i.xTaskGenericNotify||, CODE, READONLY, ALIGN=2

                  xTaskGenericNotify PROC
;;;4712   
;;;4713   	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
000000  b5ff              PUSH     {r0-r7,lr}
;;;4714   	{
;;;4715   	TCB_t * pxTCB;
;;;4716   	BaseType_t xReturn = pdPASS;
000002  2601              MOVS     r6,#1
000004  b081              SUB      sp,sp,#4              ;4714
000006  461f              MOV      r7,r3                 ;4714
000008  460d              MOV      r5,r1                 ;4714
;;;4717   	uint8_t ucOriginalNotifyState;
;;;4718   
;;;4719   		configASSERT( xTaskToNotify );
00000a  2800              CMP      r0,#0
00000c  d014              BEQ      |L42.56|
;;;4720   		pxTCB = xTaskToNotify;
00000e  4604              MOV      r4,r0
;;;4721   
;;;4722   		taskENTER_CRITICAL();
000010  f7fffffe          BL       vPortEnterCritical
;;;4723   		{
;;;4724   			if( pulPreviousNotificationValue != NULL )
000014  2f00              CMP      r7,#0
000016  d001              BEQ      |L42.28|
;;;4725   			{
;;;4726   				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
000018  6d60              LDR      r0,[r4,#0x54]
00001a  6038              STR      r0,[r7,#0]
                  |L42.28|
;;;4727   			}
;;;4728   
;;;4729   			ucOriginalNotifyState = pxTCB->ucNotifyState;
00001c  4620              MOV      r0,r4
00001e  3040              ADDS     r0,r0,#0x40
000020  4601              MOV      r1,r0
000022  7e00              LDRB     r0,[r0,#0x18]
;;;4730   
;;;4731   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
000024  2202              MOVS     r2,#2
000026  760a              STRB     r2,[r1,#0x18]
;;;4732   
;;;4733   			switch( eAction )
000028  9903              LDR      r1,[sp,#0xc]
00002a  000b              MOVS     r3,r1
00002c  f7fffffe          BL       __ARM_common_switch8
000030  05180609          DCB      0x05,0x18,0x06,0x09
000034  0f0d1300          DCB      0x0f,0x0d,0x13,0x00
                  |L42.56|
000038  b672              CPSID    i                     ;4719
                  |L42.58|
00003a  e7fe              B        |L42.58|
;;;4734   			{
;;;4735   				case eSetBits	:
;;;4736   					pxTCB->ulNotifiedValue |= ulValue;
00003c  6d61              LDR      r1,[r4,#0x54]
00003e  4329              ORRS     r1,r1,r5
;;;4737   					break;
000040  e001              B        |L42.70|
;;;4738   
;;;4739   				case eIncrement	:
;;;4740   					( pxTCB->ulNotifiedValue )++;
000042  6d61              LDR      r1,[r4,#0x54]
000044  1c49              ADDS     r1,r1,#1
                  |L42.70|
000046  6561              STR      r1,[r4,#0x54]         ;4736
000048  e00a              B        |L42.96|
;;;4741   					break;
;;;4742   
;;;4743   				case eSetValueWithOverwrite	:
;;;4744   					pxTCB->ulNotifiedValue = ulValue;
;;;4745   					break;
;;;4746   
;;;4747   				case eSetValueWithoutOverwrite :
;;;4748   					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
00004a  2802              CMP      r0,#2
00004c  d001              BEQ      |L42.82|
;;;4749   					{
;;;4750   						pxTCB->ulNotifiedValue = ulValue;
00004e  6565              STR      r5,[r4,#0x54]
000050  e006              B        |L42.96|
                  |L42.82|
;;;4751   					}
;;;4752   					else
;;;4753   					{
;;;4754   						/* The value could not be written to the task. */
;;;4755   						xReturn = pdFAIL;
000052  2600              MOVS     r6,#0
000054  e022              B        |L42.156|
;;;4756   					}
;;;4757   					break;
;;;4758   
;;;4759   				case eNoAction:
;;;4760   					/* The task is being notified without its notify value being
;;;4761   					updated. */
;;;4762   					break;
;;;4763   
;;;4764   				default:
;;;4765   					/* Should not get here if all enums are handled.
;;;4766   					Artificially force an assert by testing a value the
;;;4767   					compiler can't assume is const. */
;;;4768   					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
000056  6d61              LDR      r1,[r4,#0x54]
000058  1c49              ADDS     r1,r1,#1
00005a  d001              BEQ      |L42.96|
00005c  b672              CPSID    i
                  |L42.94|
00005e  e7fe              B        |L42.94|
                  |L42.96|
;;;4769   
;;;4770   					break;
;;;4771   			}
;;;4772   
;;;4773   			traceTASK_NOTIFY();
;;;4774   
;;;4775   			/* If the task is in the blocked state specifically to wait for a
;;;4776   			notification then unblock it now. */
;;;4777   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
000060  2801              CMP      r0,#1
000062  d11b              BNE      |L42.156|
;;;4778   			{
;;;4779   				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000064  1d20              ADDS     r0,r4,#4
000066  f7fffffe          BL       uxListRemove
;;;4780   				prvAddTaskToReadyList( pxTCB );
00006a  4d0f              LDR      r5,|L42.168|
00006c  6ae0              LDR      r0,[r4,#0x2c]
00006e  6929              LDR      r1,[r5,#0x10]  ; uxTopReadyPriority
000070  4288              CMP      r0,r1
000072  d900              BLS      |L42.118|
000074  6128              STR      r0,[r5,#0x10]  ; uxTopReadyPriority
                  |L42.118|
000076  2114              MOVS     r1,#0x14
000078  4348              MULS     r0,r1,r0
00007a  490c              LDR      r1,|L42.172|
00007c  1840              ADDS     r0,r0,r1
00007e  1d21              ADDS     r1,r4,#4
000080  f7fffffe          BL       vListInsertEnd
;;;4781   
;;;4782   				/* The task should not have been on an event list. */
;;;4783   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
000084  6aa0              LDR      r0,[r4,#0x28]
000086  2800              CMP      r0,#0
000088  d001              BEQ      |L42.142|
00008a  b672              CPSID    i
                  |L42.140|
00008c  e7fe              B        |L42.140|
                  |L42.142|
;;;4784   
;;;4785   				#if( configUSE_TICKLESS_IDLE != 0 )
;;;4786   				{
;;;4787   					/* If a task is blocked waiting for a notification then
;;;4788   					xNextTaskUnblockTime might be set to the blocked task's time
;;;4789   					out time.  If the task is unblocked for a reason other than
;;;4790   					a timeout xNextTaskUnblockTime is normally left unchanged,
;;;4791   					because it will automatically get reset to a new value when
;;;4792   					the tick count equals xNextTaskUnblockTime.  However if
;;;4793   					tickless idling is used it might be more important to enter
;;;4794   					sleep mode at the earliest possible time - so reset
;;;4795   					xNextTaskUnblockTime here to ensure it is updated at the
;;;4796   					earliest possible time. */
;;;4797   					prvResetNextTaskUnblockTime();
;;;4798   				}
;;;4799   				#endif
;;;4800   
;;;4801   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
00008e  6ae0              LDR      r0,[r4,#0x2c]
000090  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000092  6ac9              LDR      r1,[r1,#0x2c]
000094  4288              CMP      r0,r1
000096  d901              BLS      |L42.156|
;;;4802   				{
;;;4803   					/* The notified task has a priority above the currently
;;;4804   					executing task so a yield is required. */
;;;4805   					taskYIELD_IF_USING_PREEMPTION();
000098  f7fffffe          BL       vPortYield
                  |L42.156|
;;;4806   				}
;;;4807   				else
;;;4808   				{
;;;4809   					mtCOVERAGE_TEST_MARKER();
;;;4810   				}
;;;4811   			}
;;;4812   			else
;;;4813   			{
;;;4814   				mtCOVERAGE_TEST_MARKER();
;;;4815   			}
;;;4816   		}
;;;4817   		taskEXIT_CRITICAL();
00009c  f7fffffe          BL       vPortExitCritical
;;;4818   
;;;4819   		return xReturn;
0000a0  4630              MOV      r0,r6
;;;4820   	}
0000a2  b005              ADD      sp,sp,#0x14
0000a4  bdf0              POP      {r4-r7,pc}
;;;4821   
                          ENDP

0000a6  0000              DCW      0x0000
                  |L42.168|
                          DCD      ||.data||
                  |L42.172|
                          DCD      ||.bss||

                          AREA ||i.xTaskGenericNotifyFromISR||, CODE, READONLY, ALIGN=2

                  xTaskGenericNotifyFromISR PROC
;;;4826   
;;;4827   	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
000000  b5ff              PUSH     {r0-r7,lr}
;;;4828   	{
;;;4829   	TCB_t * pxTCB;
;;;4830   	uint8_t ucOriginalNotifyState;
;;;4831   	BaseType_t xReturn = pdPASS;
000002  2601              MOVS     r6,#1
000004  b081              SUB      sp,sp,#4              ;4828
000006  461f              MOV      r7,r3                 ;4828
000008  460d              MOV      r5,r1                 ;4828
;;;4832   	UBaseType_t uxSavedInterruptStatus;
;;;4833   
;;;4834   		configASSERT( xTaskToNotify );
00000a  2800              CMP      r0,#0
00000c  d015              BEQ      |L43.58|
;;;4835   
;;;4836   		/* RTOS ports that support interrupt nesting have the concept of a
;;;4837   		maximum	system call (or maximum API call) interrupt priority.
;;;4838   		Interrupts that are	above the maximum system call priority are keep
;;;4839   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;4840   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;4841   		is defined in FreeRTOSConfig.h then
;;;4842   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;4843   		failure if a FreeRTOS API function is called from an interrupt that has
;;;4844   		been assigned a priority above the configured maximum system call
;;;4845   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;4846   		from interrupts	that have been assigned a priority at or (logically)
;;;4847   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;4848   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;4849   		simple as possible.  More information (albeit Cortex-M specific) is
;;;4850   		provided on the following link:
;;;4851   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;4852   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;4853   
;;;4854   		pxTCB = xTaskToNotify;
00000e  4604              MOV      r4,r0
;;;4855   
;;;4856   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000010  f7fffffe          BL       ulSetInterruptMaskFromISR
;;;4857   		{
;;;4858   			if( pulPreviousNotificationValue != NULL )
000014  9000              STR      r0,[sp,#0]
000016  2f00              CMP      r7,#0
000018  d001              BEQ      |L43.30|
;;;4859   			{
;;;4860   				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
00001a  6d60              LDR      r0,[r4,#0x54]
00001c  6038              STR      r0,[r7,#0]
                  |L43.30|
;;;4861   			}
;;;4862   
;;;4863   			ucOriginalNotifyState = pxTCB->ucNotifyState;
00001e  4620              MOV      r0,r4
000020  3040              ADDS     r0,r0,#0x40
000022  4601              MOV      r1,r0
000024  7e00              LDRB     r0,[r0,#0x18]
;;;4864   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
000026  2202              MOVS     r2,#2
000028  760a              STRB     r2,[r1,#0x18]
;;;4865   
;;;4866   			switch( eAction )
00002a  9903              LDR      r1,[sp,#0xc]
00002c  000b              MOVS     r3,r1
00002e  f7fffffe          BL       __ARM_common_switch8
000032  0518              DCB      0x05,0x18
000034  06090f0d          DCB      0x06,0x09,0x0f,0x0d
000038  1300              DCB      0x13,0x00
                  |L43.58|
00003a  b672              CPSID    i                     ;4834
                  |L43.60|
00003c  e7fe              B        |L43.60|
;;;4867   			{
;;;4868   				case eSetBits	:
;;;4869   					pxTCB->ulNotifiedValue |= ulValue;
00003e  6d61              LDR      r1,[r4,#0x54]
000040  4329              ORRS     r1,r1,r5
;;;4870   					break;
000042  e001              B        |L43.72|
;;;4871   
;;;4872   				case eIncrement	:
;;;4873   					( pxTCB->ulNotifiedValue )++;
000044  6d61              LDR      r1,[r4,#0x54]
000046  1c49              ADDS     r1,r1,#1
                  |L43.72|
000048  6561              STR      r1,[r4,#0x54]         ;4869
00004a  e00a              B        |L43.98|
;;;4874   					break;
;;;4875   
;;;4876   				case eSetValueWithOverwrite	:
;;;4877   					pxTCB->ulNotifiedValue = ulValue;
;;;4878   					break;
;;;4879   
;;;4880   				case eSetValueWithoutOverwrite :
;;;4881   					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
00004c  2802              CMP      r0,#2
00004e  d001              BEQ      |L43.84|
;;;4882   					{
;;;4883   						pxTCB->ulNotifiedValue = ulValue;
000050  6565              STR      r5,[r4,#0x54]
000052  e006              B        |L43.98|
                  |L43.84|
;;;4884   					}
;;;4885   					else
;;;4886   					{
;;;4887   						/* The value could not be written to the task. */
;;;4888   						xReturn = pdFAIL;
000054  2600              MOVS     r6,#0
000056  e02e              B        |L43.182|
;;;4889   					}
;;;4890   					break;
;;;4891   
;;;4892   				case eNoAction :
;;;4893   					/* The task is being notified without its notify value being
;;;4894   					updated. */
;;;4895   					break;
;;;4896   
;;;4897   				default:
;;;4898   					/* Should not get here if all enums are handled.
;;;4899   					Artificially force an assert by testing a value the
;;;4900   					compiler can't assume is const. */
;;;4901   					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
000058  6d61              LDR      r1,[r4,#0x54]
00005a  1c49              ADDS     r1,r1,#1
00005c  d001              BEQ      |L43.98|
00005e  b672              CPSID    i
                  |L43.96|
000060  e7fe              B        |L43.96|
                  |L43.98|
;;;4902   					break;
;;;4903   			}
;;;4904   
;;;4905   			traceTASK_NOTIFY_FROM_ISR();
;;;4906   
;;;4907   			/* If the task is in the blocked state specifically to wait for a
;;;4908   			notification then unblock it now. */
;;;4909   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
000062  2801              CMP      r0,#1
000064  d127              BNE      |L43.182|
;;;4910   			{
;;;4911   				/* The task should not have been on an event list. */
;;;4912   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
000066  6aa0              LDR      r0,[r4,#0x28]
000068  2800              CMP      r0,#0
00006a  d001              BEQ      |L43.112|
00006c  b672              CPSID    i
                  |L43.110|
00006e  e7fe              B        |L43.110|
                  |L43.112|
;;;4913   
;;;4914   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000070  4d14              LDR      r5,|L43.196|
000072  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
000074  2800              CMP      r0,#0
000076  d003              BEQ      |L43.128|
;;;4915   				{
;;;4916   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
;;;4917   					prvAddTaskToReadyList( pxTCB );
;;;4918   				}
;;;4919   				else
;;;4920   				{
;;;4921   					/* The delayed and ready lists cannot be accessed, so hold
;;;4922   					this task pending until the scheduler is resumed. */
;;;4923   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000078  4621              MOV      r1,r4
00007a  3118              ADDS     r1,r1,#0x18
00007c  4812              LDR      r0,|L43.200|
00007e  e00d              B        |L43.156|
                  |L43.128|
000080  1d20              ADDS     r0,r4,#4              ;4916
000082  f7fffffe          BL       uxListRemove
000086  6ae0              LDR      r0,[r4,#0x2c]         ;4917
000088  6929              LDR      r1,[r5,#0x10]         ;4917  ; uxTopReadyPriority
00008a  4288              CMP      r0,r1                 ;4917
00008c  d900              BLS      |L43.144|
00008e  6128              STR      r0,[r5,#0x10]         ;4917  ; uxTopReadyPriority
                  |L43.144|
000090  2114              MOVS     r1,#0x14              ;4917
000092  4348              MULS     r0,r1,r0              ;4917
000094  490c              LDR      r1,|L43.200|
000096  398c              SUBS     r1,r1,#0x8c           ;4917
000098  1840              ADDS     r0,r0,r1              ;4917
00009a  1d21              ADDS     r1,r4,#4              ;4917
                  |L43.156|
00009c  f7fffffe          BL       vListInsertEnd
;;;4924   				}
;;;4925   
;;;4926   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
0000a0  6ae0              LDR      r0,[r4,#0x2c]
0000a2  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
0000a4  6ac9              LDR      r1,[r1,#0x2c]
0000a6  4288              CMP      r0,r1
0000a8  d905              BLS      |L43.182|
;;;4927   				{
;;;4928   					/* The notified task has a priority above the currently
;;;4929   					executing task so a yield is required. */
;;;4930   					if( pxHigherPriorityTaskWoken != NULL )
0000aa  990a              LDR      r1,[sp,#0x28]
0000ac  2001              MOVS     r0,#1                 ;4831
0000ae  2900              CMP      r1,#0
0000b0  d000              BEQ      |L43.180|
;;;4931   					{
;;;4932   						*pxHigherPriorityTaskWoken = pdTRUE;
0000b2  6008              STR      r0,[r1,#0]
                  |L43.180|
;;;4933   					}
;;;4934   
;;;4935   					/* Mark that a yield is pending in case the user is not
;;;4936   					using the "xHigherPriorityTaskWoken" parameter to an ISR
;;;4937   					safe FreeRTOS function. */
;;;4938   					xYieldPending = pdTRUE;
0000b4  61e8              STR      r0,[r5,#0x1c]  ; xYieldPending
                  |L43.182|
;;;4939   				}
;;;4940   				else
;;;4941   				{
;;;4942   					mtCOVERAGE_TEST_MARKER();
;;;4943   				}
;;;4944   			}
;;;4945   		}
;;;4946   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0000b6  9800              LDR      r0,[sp,#0]
0000b8  f7fffffe          BL       vClearInterruptMaskFromISR
;;;4947   
;;;4948   		return xReturn;
0000bc  4630              MOV      r0,r6
;;;4949   	}
0000be  b005              ADD      sp,sp,#0x14
0000c0  bdf0              POP      {r4-r7,pc}
;;;4950   
                          ENDP

0000c2  0000              DCW      0x0000
                  |L43.196|
                          DCD      ||.data||
                  |L43.200|
                          DCD      ||.bss||+0x8c

                          AREA ||i.xTaskGetCurrentTaskHandle||, CODE, READONLY, ALIGN=2

                  xTaskGetCurrentTaskHandle PROC
;;;3904   
;;;3905   	TaskHandle_t xTaskGetCurrentTaskHandle( void )
000000  4801              LDR      r0,|L44.8|
;;;3906   	{
;;;3907   	TaskHandle_t xReturn;
;;;3908   
;;;3909   		/* A critical section is not required as this is not called from
;;;3910   		an interrupt and the current TCB will always be the same for any
;;;3911   		individual execution thread. */
;;;3912   		xReturn = pxCurrentTCB;
000002  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
;;;3913   
;;;3914   		return xReturn;
;;;3915   	}
000004  4770              BX       lr
;;;3916   
                          ENDP

000006  0000              DCW      0x0000
                  |L44.8|
                          DCD      ||.data||

                          AREA ||i.xTaskGetSchedulerState||, CODE, READONLY, ALIGN=2

                  xTaskGetSchedulerState PROC
;;;3921   
;;;3922   	BaseType_t xTaskGetSchedulerState( void )
000000  4806              LDR      r0,|L45.28|
;;;3923   	{
;;;3924   	BaseType_t xReturn;
;;;3925   
;;;3926   		if( xSchedulerRunning == pdFALSE )
000002  6941              LDR      r1,[r0,#0x14]  ; xSchedulerRunning
000004  2900              CMP      r1,#0
000006  d004              BEQ      |L45.18|
;;;3927   		{
;;;3928   			xReturn = taskSCHEDULER_NOT_STARTED;
;;;3929   		}
;;;3930   		else
;;;3931   		{
;;;3932   			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000008  6b00              LDR      r0,[r0,#0x30]  ; uxSchedulerSuspended
00000a  2800              CMP      r0,#0
00000c  d003              BEQ      |L45.22|
;;;3933   			{
;;;3934   				xReturn = taskSCHEDULER_RUNNING;
;;;3935   			}
;;;3936   			else
;;;3937   			{
;;;3938   				xReturn = taskSCHEDULER_SUSPENDED;
00000e  2000              MOVS     r0,#0
;;;3939   			}
;;;3940   		}
;;;3941   
;;;3942   		return xReturn;
;;;3943   	}
000010  4770              BX       lr
                  |L45.18|
000012  2001              MOVS     r0,#1                 ;3928
000014  4770              BX       lr
                  |L45.22|
000016  2002              MOVS     r0,#2                 ;3934
000018  4770              BX       lr
;;;3944   
                          ENDP

00001a  0000              DCW      0x0000
                  |L45.28|
                          DCD      ||.data||

                          AREA ||i.xTaskGetTickCount||, CODE, READONLY, ALIGN=2

                  xTaskGetTickCount PROC
;;;2282   
;;;2283   TickType_t xTaskGetTickCount( void )
000000  4801              LDR      r0,|L46.8|
;;;2284   {
;;;2285   TickType_t xTicks;
;;;2286   
;;;2287   	/* Critical section required if running on a 16 bit processor. */
;;;2288   	portTICK_TYPE_ENTER_CRITICAL();
;;;2289   	{
;;;2290   		xTicks = xTickCount;
000002  68c0              LDR      r0,[r0,#0xc]  ; xTickCount
;;;2291   	}
;;;2292   	portTICK_TYPE_EXIT_CRITICAL();
;;;2293   
;;;2294   	return xTicks;
;;;2295   }
000004  4770              BX       lr
;;;2296   /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L46.8|
                          DCD      ||.data||

                          AREA ||i.xTaskGetTickCountFromISR||, CODE, READONLY, ALIGN=2

                  xTaskGetTickCountFromISR PROC
;;;2297   
;;;2298   TickType_t xTaskGetTickCountFromISR( void )
000000  4801              LDR      r0,|L47.8|
;;;2299   {
;;;2300   TickType_t xReturn;
;;;2301   UBaseType_t uxSavedInterruptStatus;
;;;2302   
;;;2303   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;2304   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;2305   	above the maximum system call priority are kept permanently enabled, even
;;;2306   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;2307   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;2308   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;2309   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;2310   	assigned a priority above the configured maximum system call priority.
;;;2311   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;2312   	that have been assigned a priority at or (logically) below the maximum
;;;2313   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;2314   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;2315   	More information (albeit Cortex-M specific) is provided on the following
;;;2316   	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;2317   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;2318   
;;;2319   	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
;;;2320   	{
;;;2321   		xReturn = xTickCount;
000002  68c0              LDR      r0,[r0,#0xc]  ; xTickCount
;;;2322   	}
;;;2323   	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;2324   
;;;2325   	return xReturn;
;;;2326   }
000004  4770              BX       lr
;;;2327   /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L47.8|
                          DCD      ||.data||

                          AREA ||i.xTaskIncrementTick||, CODE, READONLY, ALIGN=2

                  xTaskIncrementTick PROC
;;;2663   
;;;2664   BaseType_t xTaskIncrementTick( void )
000000  b5f8              PUSH     {r3-r7,lr}
;;;2665   {
;;;2666   TCB_t * pxTCB;
;;;2667   TickType_t xItemValue;
;;;2668   BaseType_t xSwitchRequired = pdFALSE;
;;;2669   
;;;2670   	/* Called by the portable layer each time a tick interrupt occurs.
;;;2671   	Increments the tick then checks to see if the new tick value will cause any
;;;2672   	tasks to be unblocked. */
;;;2673   	traceTASK_INCREMENT_TICK( xTickCount );
;;;2674   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000002  4f2f              LDR      r7,|L48.192|
000004  2600              MOVS     r6,#0                 ;2668
000006  6b38              LDR      r0,[r7,#0x30]  ; uxSchedulerSuspended
000008  2800              CMP      r0,#0
00000a  d003              BEQ      |L48.20|
;;;2675   	{
;;;2676   		/* Minor optimisation.  The tick count cannot change in this
;;;2677   		block. */
;;;2678   		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
;;;2679   
;;;2680   		/* Increment the RTOS tick, switching the delayed and overflowed
;;;2681   		delayed lists if it wraps to 0. */
;;;2682   		xTickCount = xConstTickCount;
;;;2683   
;;;2684   		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
;;;2685   		{
;;;2686   			taskSWITCH_DELAYED_LISTS();
;;;2687   		}
;;;2688   		else
;;;2689   		{
;;;2690   			mtCOVERAGE_TEST_MARKER();
;;;2691   		}
;;;2692   
;;;2693   		/* See if this tick has made a timeout expire.  Tasks are stored in
;;;2694   		the	queue in the order of their wake time - meaning once one task
;;;2695   		has been found whose block time has not expired there is no need to
;;;2696   		look any further down the list. */
;;;2697   		if( xConstTickCount >= xNextTaskUnblockTime )
;;;2698   		{
;;;2699   			for( ;; )
;;;2700   			{
;;;2701   				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
;;;2702   				{
;;;2703   					/* The delayed list is empty.  Set xNextTaskUnblockTime
;;;2704   					to the maximum possible value so it is extremely
;;;2705   					unlikely that the
;;;2706   					if( xTickCount >= xNextTaskUnblockTime ) test will pass
;;;2707   					next time through. */
;;;2708   					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
;;;2709   					break;
;;;2710   				}
;;;2711   				else
;;;2712   				{
;;;2713   					/* The delayed list is not empty, get the value of the
;;;2714   					item at the head of the delayed list.  This is the time
;;;2715   					at which the task at the head of the delayed list must
;;;2716   					be removed from the Blocked state. */
;;;2717   					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
;;;2718   					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
;;;2719   
;;;2720   					if( xConstTickCount < xItemValue )
;;;2721   					{
;;;2722   						/* It is not time to unblock this item yet, but the
;;;2723   						item value is the time at which the task at the head
;;;2724   						of the blocked list must be removed from the Blocked
;;;2725   						state -	so record the item value in
;;;2726   						xNextTaskUnblockTime. */
;;;2727   						xNextTaskUnblockTime = xItemValue;
;;;2728   						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
;;;2729   					}
;;;2730   					else
;;;2731   					{
;;;2732   						mtCOVERAGE_TEST_MARKER();
;;;2733   					}
;;;2734   
;;;2735   					/* It is time to remove the item from the Blocked state. */
;;;2736   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
;;;2737   
;;;2738   					/* Is the task waiting on an event also?  If so remove
;;;2739   					it from the event list. */
;;;2740   					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
;;;2741   					{
;;;2742   						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
;;;2743   					}
;;;2744   					else
;;;2745   					{
;;;2746   						mtCOVERAGE_TEST_MARKER();
;;;2747   					}
;;;2748   
;;;2749   					/* Place the unblocked task into the appropriate ready
;;;2750   					list. */
;;;2751   					prvAddTaskToReadyList( pxTCB );
;;;2752   
;;;2753   					/* A task being unblocked cannot cause an immediate
;;;2754   					context switch if preemption is turned off. */
;;;2755   					#if (  configUSE_PREEMPTION == 1 )
;;;2756   					{
;;;2757   						/* Preemption is on, but a context switch should
;;;2758   						only be performed if the unblocked task has a
;;;2759   						priority that is equal to or higher than the
;;;2760   						currently executing task. */
;;;2761   						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
;;;2762   						{
;;;2763   							xSwitchRequired = pdTRUE;
;;;2764   						}
;;;2765   						else
;;;2766   						{
;;;2767   							mtCOVERAGE_TEST_MARKER();
;;;2768   						}
;;;2769   					}
;;;2770   					#endif /* configUSE_PREEMPTION */
;;;2771   				}
;;;2772   			}
;;;2773   		}
;;;2774   
;;;2775   		/* Tasks of equal priority to the currently running task will share
;;;2776   		processing time (time slice) if preemption is on, and the application
;;;2777   		writer has not explicitly turned time slicing off. */
;;;2778   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
;;;2779   		{
;;;2780   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
;;;2781   			{
;;;2782   				xSwitchRequired = pdTRUE;
;;;2783   			}
;;;2784   			else
;;;2785   			{
;;;2786   				mtCOVERAGE_TEST_MARKER();
;;;2787   			}
;;;2788   		}
;;;2789   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
;;;2790   
;;;2791   		#if ( configUSE_TICK_HOOK == 1 )
;;;2792   		{
;;;2793   			/* Guard against the tick hook being called when the pended tick
;;;2794   			count is being unwound (when the scheduler is being unlocked). */
;;;2795   			if( uxPendedTicks == ( UBaseType_t ) 0U )
;;;2796   			{
;;;2797   				vApplicationTickHook();
;;;2798   			}
;;;2799   			else
;;;2800   			{
;;;2801   				mtCOVERAGE_TEST_MARKER();
;;;2802   			}
;;;2803   		}
;;;2804   		#endif /* configUSE_TICK_HOOK */
;;;2805   	}
;;;2806   	else
;;;2807   	{
;;;2808   		++uxPendedTicks;
00000c  69b8              LDR      r0,[r7,#0x18]  ; uxPendedTicks
00000e  1c40              ADDS     r0,r0,#1
000010  61b8              STR      r0,[r7,#0x18]  ; uxPendedTicks
;;;2809   
;;;2810   		/* The tick hook gets called at regular intervals, even if the
;;;2811   		scheduler is locked. */
;;;2812   		#if ( configUSE_TICK_HOOK == 1 )
;;;2813   		{
;;;2814   			vApplicationTickHook();
000012  e04d              B        |L48.176|
                  |L48.20|
000014  68fd              LDR      r5,[r7,#0xc]          ;2678  ; xTickCount
000016  1c6d              ADDS     r5,r5,#1              ;2678
000018  60fd              STR      r5,[r7,#0xc]          ;2682  ; xTickCount
00001a  d10e              BNE      |L48.58|
00001c  6b78              LDR      r0,[r7,#0x34]         ;2686  ; pxDelayedTaskList
00001e  6800              LDR      r0,[r0,#0]            ;2686
000020  2800              CMP      r0,#0                 ;2686
000022  d001              BEQ      |L48.40|
000024  b672              CPSID    i                     ;2686
                  |L48.38|
000026  e7fe              B        |L48.38|
                  |L48.40|
000028  6b78              LDR      r0,[r7,#0x34]         ;2686  ; pxDelayedTaskList
00002a  6bb9              LDR      r1,[r7,#0x38]         ;2686  ; pxOverflowDelayedTaskList
00002c  6379              STR      r1,[r7,#0x34]         ;2686  ; pxDelayedTaskList
00002e  63b8              STR      r0,[r7,#0x38]         ;2686  ; pxOverflowDelayedTaskList
000030  6a38              LDR      r0,[r7,#0x20]         ;2686  ; xNumOfOverflows
000032  1c40              ADDS     r0,r0,#1              ;2686
000034  6238              STR      r0,[r7,#0x20]         ;2686  ; xNumOfOverflows
000036  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L48.58|
00003a  6ab8              LDR      r0,[r7,#0x28]         ;2697  ; xNextTaskUnblockTime
00003c  4285              CMP      r5,r0                 ;2697
00003e  d30a              BCC      |L48.86|
                  |L48.64|
000040  6b78              LDR      r0,[r7,#0x34]         ;2701  ; pxDelayedTaskList
000042  6800              LDR      r0,[r0,#0]            ;2701
000044  2800              CMP      r0,#0                 ;2701
000046  d013              BEQ      |L48.112|
000048  6b78              LDR      r0,[r7,#0x34]         ;2717  ; pxDelayedTaskList
00004a  68c0              LDR      r0,[r0,#0xc]          ;2717
00004c  68c4              LDR      r4,[r0,#0xc]          ;2718
00004e  6860              LDR      r0,[r4,#4]            ;2720
000050  4285              CMP      r5,r0                 ;2720
000052  d210              BCS      |L48.118|
                  |L48.84|
000054  62b8              STR      r0,[r7,#0x28]         ;2727  ; xNextTaskUnblockTime
                  |L48.86|
000056  6838              LDR      r0,[r7,#0]            ;2780  ; pxCurrentTCB
000058  2114              MOVS     r1,#0x14              ;2780
00005a  6ac0              LDR      r0,[r0,#0x2c]         ;2780
00005c  4348              MULS     r0,r1,r0              ;2780
00005e  4919              LDR      r1,|L48.196|
000060  5808              LDR      r0,[r1,r0]            ;2780
000062  2801              CMP      r0,#1                 ;2780
000064  d900              BLS      |L48.104|
000066  2601              MOVS     r6,#1                 ;2782
                  |L48.104|
000068  69b8              LDR      r0,[r7,#0x18]         ;2795  ; uxPendedTicks
00006a  2800              CMP      r0,#0                 ;2795
00006c  d020              BEQ      |L48.176|
00006e  e021              B        |L48.180|
                  |L48.112|
000070  2000              MOVS     r0,#0                 ;2708
000072  43c0              MVNS     r0,r0                 ;2708
000074  e7ee              B        |L48.84|
                  |L48.118|
000076  1d20              ADDS     r0,r4,#4              ;2736
000078  f7fffffe          BL       uxListRemove
00007c  6aa0              LDR      r0,[r4,#0x28]         ;2740
00007e  2800              CMP      r0,#0                 ;2740
000080  d003              BEQ      |L48.138|
000082  4620              MOV      r0,r4                 ;2742
000084  3018              ADDS     r0,r0,#0x18           ;2742
000086  f7fffffe          BL       uxListRemove
                  |L48.138|
00008a  6ae0              LDR      r0,[r4,#0x2c]         ;2751
00008c  6939              LDR      r1,[r7,#0x10]         ;2751  ; uxTopReadyPriority
00008e  4288              CMP      r0,r1                 ;2751
000090  d900              BLS      |L48.148|
000092  6138              STR      r0,[r7,#0x10]         ;2751  ; uxTopReadyPriority
                  |L48.148|
000094  2114              MOVS     r1,#0x14              ;2751
000096  4348              MULS     r0,r1,r0              ;2751
000098  490a              LDR      r1,|L48.196|
00009a  1840              ADDS     r0,r0,r1              ;2751
00009c  1d21              ADDS     r1,r4,#4              ;2751
00009e  f7fffffe          BL       vListInsertEnd
0000a2  6ae0              LDR      r0,[r4,#0x2c]         ;2761
0000a4  6839              LDR      r1,[r7,#0]            ;2761  ; pxCurrentTCB
0000a6  6ac9              LDR      r1,[r1,#0x2c]         ;2761
0000a8  4288              CMP      r0,r1                 ;2761
0000aa  d3c9              BCC      |L48.64|
0000ac  2601              MOVS     r6,#1                 ;2763
0000ae  e7c7              B        |L48.64|
                  |L48.176|
0000b0  f7fffffe          BL       vApplicationTickHook
                  |L48.180|
;;;2815   		}
;;;2816   		#endif
;;;2817   	}
;;;2818   
;;;2819   	#if ( configUSE_PREEMPTION == 1 )
;;;2820   	{
;;;2821   		if( xYieldPending != pdFALSE )
0000b4  69f8              LDR      r0,[r7,#0x1c]  ; xYieldPending
0000b6  2800              CMP      r0,#0
0000b8  d000              BEQ      |L48.188|
;;;2822   		{
;;;2823   			xSwitchRequired = pdTRUE;
0000ba  2601              MOVS     r6,#1
                  |L48.188|
;;;2824   		}
;;;2825   		else
;;;2826   		{
;;;2827   			mtCOVERAGE_TEST_MARKER();
;;;2828   		}
;;;2829   	}
;;;2830   	#endif /* configUSE_PREEMPTION */
;;;2831   
;;;2832   	return xSwitchRequired;
0000bc  4630              MOV      r0,r6
;;;2833   }
0000be  bdf8              POP      {r3-r7,pc}
;;;2834   /*-----------------------------------------------------------*/
                          ENDP

                  |L48.192|
                          DCD      ||.data||
                  |L48.196|
                          DCD      ||.bss||

                          AREA ||i.xTaskNotifyStateClear||, CODE, READONLY, ALIGN=2

                  xTaskNotifyStateClear PROC
;;;5042   
;;;5043   	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
000000  b510              PUSH     {r4,lr}
;;;5044   	{
;;;5045   	TCB_t *pxTCB;
;;;5046   	BaseType_t xReturn;
;;;5047   
;;;5048   		/* If null is passed in here then it is the calling task that is having
;;;5049   		its notification state cleared. */
;;;5050   		pxTCB = prvGetTCBFromHandle( xTask );
000002  2800              CMP      r0,#0
000004  d101              BNE      |L49.10|
000006  4809              LDR      r0,|L49.44|
000008  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
                  |L49.10|
00000a  4604              MOV      r4,r0
;;;5051   
;;;5052   		taskENTER_CRITICAL();
00000c  f7fffffe          BL       vPortEnterCritical
000010  3440              ADDS     r4,r4,#0x40
;;;5053   		{
;;;5054   			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
000012  7e20              LDRB     r0,[r4,#0x18]
000014  2802              CMP      r0,#2
000016  d004              BEQ      |L49.34|
;;;5055   			{
;;;5056   				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
;;;5057   				xReturn = pdPASS;
;;;5058   			}
;;;5059   			else
;;;5060   			{
;;;5061   				xReturn = pdFAIL;
000018  2400              MOVS     r4,#0
                  |L49.26|
;;;5062   			}
;;;5063   		}
;;;5064   		taskEXIT_CRITICAL();
00001a  f7fffffe          BL       vPortExitCritical
;;;5065   
;;;5066   		return xReturn;
00001e  4620              MOV      r0,r4
;;;5067   	}
000020  bd10              POP      {r4,pc}
                  |L49.34|
000022  2000              MOVS     r0,#0                 ;5056
000024  7620              STRB     r0,[r4,#0x18]         ;5056
000026  2401              MOVS     r4,#1                 ;5057
000028  e7f7              B        |L49.26|
;;;5068   
                          ENDP

00002a  0000              DCW      0x0000
                  |L49.44|
                          DCD      ||.data||

                          AREA ||i.xTaskNotifyWait||, CODE, READONLY, ALIGN=2

                  xTaskNotifyWait PROC
;;;4632   
;;;4633   	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
000000  b5ff              PUSH     {r0-r7,lr}
;;;4634   	{
000002  b081              SUB      sp,sp,#4
000004  461e              MOV      r6,r3
000006  4615              MOV      r5,r2
000008  4607              MOV      r7,r0
;;;4635   	BaseType_t xReturn;
;;;4636   
;;;4637   		taskENTER_CRITICAL();
00000a  f7fffffe          BL       vPortEnterCritical
;;;4638   		{
;;;4639   			/* Only block if a notification is not already pending. */
;;;4640   			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
00000e  4c1a              LDR      r4,|L50.120|
000010  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000012  3040              ADDS     r0,r0,#0x40
000014  7e00              LDRB     r0,[r0,#0x18]
000016  2802              CMP      r0,#2
000018  d00e              BEQ      |L50.56|
;;;4641   			{
;;;4642   				/* Clear bits in the task's notification value as bits may get
;;;4643   				set	by the notifying task or interrupt.  This can be used to
;;;4644   				clear the value to zero. */
;;;4645   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
00001a  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
00001c  6d41              LDR      r1,[r0,#0x54]
00001e  43b9              BICS     r1,r1,r7
000020  6541              STR      r1,[r0,#0x54]
;;;4646   
;;;4647   				/* Mark this task as waiting for a notification. */
;;;4648   				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
000022  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000024  2101              MOVS     r1,#1
000026  3040              ADDS     r0,r0,#0x40
000028  7601              STRB     r1,[r0,#0x18]
;;;4649   
;;;4650   				if( xTicksToWait > ( TickType_t ) 0 )
00002a  2e00              CMP      r6,#0
00002c  d004              BEQ      |L50.56|
;;;4651   				{
;;;4652   					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;4653   					traceTASK_NOTIFY_WAIT_BLOCK();
;;;4654   
;;;4655   					/* All ports are written to allow a yield in a critical
;;;4656   					section (some will yield immediately, others wait until the
;;;4657   					critical section exits) - but it is not something that
;;;4658   					application code should ever do. */
;;;4659   					portYIELD_WITHIN_API();
000034  f7fffffe          BL       vPortYield
                  |L50.56|
;;;4660   				}
;;;4661   				else
;;;4662   				{
;;;4663   					mtCOVERAGE_TEST_MARKER();
;;;4664   				}
;;;4665   			}
;;;4666   			else
;;;4667   			{
;;;4668   				mtCOVERAGE_TEST_MARKER();
;;;4669   			}
;;;4670   		}
;;;4671   		taskEXIT_CRITICAL();
000038  f7fffffe          BL       vPortExitCritical
;;;4672   
;;;4673   		taskENTER_CRITICAL();
00003c  f7fffffe          BL       vPortEnterCritical
;;;4674   		{
;;;4675   			traceTASK_NOTIFY_WAIT();
;;;4676   
;;;4677   			if( pulNotificationValue != NULL )
000040  2d00              CMP      r5,#0
000042  d002              BEQ      |L50.74|
;;;4678   			{
;;;4679   				/* Output the current notification value, which may or may not
;;;4680   				have changed. */
;;;4681   				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
000044  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000046  6d40              LDR      r0,[r0,#0x54]
000048  6028              STR      r0,[r5,#0]
                  |L50.74|
;;;4682   			}
;;;4683   
;;;4684   			/* If ucNotifyValue is set then either the task never entered the
;;;4685   			blocked state (because a notification was already pending) or the
;;;4686   			task unblocked because of a notification.  Otherwise the task
;;;4687   			unblocked because of a timeout. */
;;;4688   			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
00004a  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
00004c  3040              ADDS     r0,r0,#0x40
00004e  7e00              LDRB     r0,[r0,#0x18]
000050  2802              CMP      r0,#2
000052  d001              BEQ      |L50.88|
;;;4689   			{
;;;4690   				/* A notification was not received. */
;;;4691   				xReturn = pdFALSE;
000054  2500              MOVS     r5,#0
000056  e005              B        |L50.100|
                  |L50.88|
;;;4692   			}
;;;4693   			else
;;;4694   			{
;;;4695   				/* A notification was already pending or a notification was
;;;4696   				received while the task was waiting. */
;;;4697   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
000058  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
00005a  6d41              LDR      r1,[r0,#0x54]
00005c  9a02              LDR      r2,[sp,#8]
00005e  4391              BICS     r1,r1,r2
000060  6541              STR      r1,[r0,#0x54]
;;;4698   				xReturn = pdTRUE;
000062  2501              MOVS     r5,#1
                  |L50.100|
;;;4699   			}
;;;4700   
;;;4701   			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
000064  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000066  2100              MOVS     r1,#0
000068  3040              ADDS     r0,r0,#0x40
00006a  7601              STRB     r1,[r0,#0x18]
;;;4702   		}
;;;4703   		taskEXIT_CRITICAL();
00006c  f7fffffe          BL       vPortExitCritical
;;;4704   
;;;4705   		return xReturn;
000070  4628              MOV      r0,r5
;;;4706   	}
000072  b005              ADD      sp,sp,#0x14
000074  bdf0              POP      {r4-r7,pc}
;;;4707   
                          ENDP

000076  0000              DCW      0x0000
                  |L50.120|
                          DCD      ||.data||

                          AREA ||i.xTaskPriorityDisinherit||, CODE, READONLY, ALIGN=2

                  xTaskPriorityDisinherit PROC
;;;4036   
;;;4037   	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
000000  b570              PUSH     {r4-r6,lr}
;;;4038   	{
000002  4604              MOV      r4,r0
;;;4039   	TCB_t * const pxTCB = pxMutexHolder;
;;;4040   	BaseType_t xReturn = pdFALSE;
000004  2000              MOVS     r0,#0
;;;4041   
;;;4042   		if( pxMutexHolder != NULL )
000006  2c00              CMP      r4,#0
000008  d025              BEQ      |L51.86|
;;;4043   		{
;;;4044   			/* A task can only have an inherited priority if it holds the mutex.
;;;4045   			If the mutex is held by a task then it cannot be given from an
;;;4046   			interrupt, and if a mutex is given by the holding task then it must
;;;4047   			be the running state task. */
;;;4048   			configASSERT( pxTCB == pxCurrentTCB );
00000a  4d14              LDR      r5,|L51.92|
00000c  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
00000e  428c              CMP      r4,r1
000010  d001              BEQ      |L51.22|
000012  b672              CPSID    i
                  |L51.20|
000014  e7fe              B        |L51.20|
                  |L51.22|
;;;4049   			configASSERT( pxTCB->uxMutexesHeld );
000016  6d21              LDR      r1,[r4,#0x50]
000018  2900              CMP      r1,#0
00001a  d01d              BEQ      |L51.88|
00001c  1e49              SUBS     r1,r1,#1
;;;4050   			( pxTCB->uxMutexesHeld )--;
;;;4051   
;;;4052   			/* Has the holder of the mutex inherited the priority of another
;;;4053   			task? */
;;;4054   			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
00001e  6521              STR      r1,[r4,#0x50]
000020  6ce3              LDR      r3,[r4,#0x4c]
000022  6ae2              LDR      r2,[r4,#0x2c]
000024  429a              CMP      r2,r3
000026  d016              BEQ      |L51.86|
;;;4055   			{
;;;4056   				/* Only disinherit if no other mutexes are held. */
;;;4057   				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
000028  2900              CMP      r1,#0
00002a  d114              BNE      |L51.86|
;;;4058   				{
;;;4059   					/* A task can only have an inherited priority if it holds
;;;4060   					the mutex.  If the mutex is held by a task then it cannot be
;;;4061   					given from an interrupt, and if a mutex is given by the
;;;4062   					holding task then it must be the running state task.  Remove
;;;4063   					the holding task from the ready list. */
;;;4064   					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
00002c  1d20              ADDS     r0,r4,#4
00002e  f7fffffe          BL       uxListRemove
;;;4065   					{
;;;4066   						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;4067   					}
;;;4068   					else
;;;4069   					{
;;;4070   						mtCOVERAGE_TEST_MARKER();
;;;4071   					}
;;;4072   
;;;4073   					/* Disinherit the priority before adding the task into the
;;;4074   					new	ready list. */
;;;4075   					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
;;;4076   					pxTCB->uxPriority = pxTCB->uxBasePriority;
000032  6ce0              LDR      r0,[r4,#0x4c]
;;;4077   
;;;4078   					/* Reset the event list item value.  It cannot be in use for
;;;4079   					any other purpose if this task is running, and it must be
;;;4080   					running to give back the mutex. */
;;;4081   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000034  2105              MOVS     r1,#5
000036  62e0              STR      r0,[r4,#0x2c]
000038  1a08              SUBS     r0,r1,r0
;;;4082   					prvAddTaskToReadyList( pxTCB );
00003a  61a0              STR      r0,[r4,#0x18]
00003c  6ae0              LDR      r0,[r4,#0x2c]
00003e  6929              LDR      r1,[r5,#0x10]  ; uxTopReadyPriority
000040  4288              CMP      r0,r1
000042  d900              BLS      |L51.70|
000044  6128              STR      r0,[r5,#0x10]  ; uxTopReadyPriority
                  |L51.70|
000046  2114              MOVS     r1,#0x14
000048  4348              MULS     r0,r1,r0
00004a  4905              LDR      r1,|L51.96|
00004c  1840              ADDS     r0,r0,r1
00004e  1d21              ADDS     r1,r4,#4
000050  f7fffffe          BL       vListInsertEnd
;;;4083   
;;;4084   					/* Return true to indicate that a context switch is required.
;;;4085   					This is only actually required in the corner case whereby
;;;4086   					multiple mutexes were held and the mutexes were given back
;;;4087   					in an order different to that in which they were taken.
;;;4088   					If a context switch did not occur when the first mutex was
;;;4089   					returned, even if a task was waiting on it, then a context
;;;4090   					switch should occur when the last mutex is returned whether
;;;4091   					a task is waiting on it or not. */
;;;4092   					xReturn = pdTRUE;
000054  2001              MOVS     r0,#1
                  |L51.86|
;;;4093   				}
;;;4094   				else
;;;4095   				{
;;;4096   					mtCOVERAGE_TEST_MARKER();
;;;4097   				}
;;;4098   			}
;;;4099   			else
;;;4100   			{
;;;4101   				mtCOVERAGE_TEST_MARKER();
;;;4102   			}
;;;4103   		}
;;;4104   		else
;;;4105   		{
;;;4106   			mtCOVERAGE_TEST_MARKER();
;;;4107   		}
;;;4108   
;;;4109   		return xReturn;
;;;4110   	}
000056  bd70              POP      {r4-r6,pc}
                  |L51.88|
000058  b672              CPSID    i                     ;4049
                  |L51.90|
00005a  e7fe              B        |L51.90|
;;;4111   
                          ENDP

                  |L51.92|
                          DCD      ||.data||
                  |L51.96|
                          DCD      ||.bss||

                          AREA ||i.xTaskPriorityInherit||, CODE, READONLY, ALIGN=2

                  xTaskPriorityInherit PROC
;;;3949   
;;;3950   	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
000000  b570              PUSH     {r4-r6,lr}
;;;3951   	{
000002  4604              MOV      r4,r0
;;;3952   	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
;;;3953   	BaseType_t xReturn = pdFALSE;
000004  2000              MOVS     r0,#0
;;;3954   
;;;3955   		/* If the mutex was given back by an interrupt while the queue was
;;;3956   		locked then the mutex holder might now be NULL.  _RB_ Is this still
;;;3957   		needed as interrupts can no longer use mutexes? */
;;;3958   		if( pxMutexHolder != NULL )
000006  2c00              CMP      r4,#0
000008  d02a              BEQ      |L52.96|
;;;3959   		{
;;;3960   			/* If the holder of the mutex has a priority below the priority of
;;;3961   			the task attempting to obtain the mutex then it will temporarily
;;;3962   			inherit the priority of the task attempting to obtain the mutex. */
;;;3963   			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
00000a  4d19              LDR      r5,|L52.112|
00000c  6ae1              LDR      r1,[r4,#0x2c]
00000e  682a              LDR      r2,[r5,#0]  ; pxCurrentTCB
000010  6ad2              LDR      r2,[r2,#0x2c]
000012  4291              CMP      r1,r2
000014  d225              BCS      |L52.98|
;;;3964   			{
;;;3965   				/* Adjust the mutex holder state to account for its new
;;;3966   				priority.  Only reset the event list item value if the value is
;;;3967   				not being used for anything else. */
;;;3968   				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000016  69a0              LDR      r0,[r4,#0x18]
000018  2800              CMP      r0,#0
00001a  db04              BLT      |L52.38|
;;;3969   				{
;;;3970   					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00001c  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00001e  2105              MOVS     r1,#5
000020  6ac0              LDR      r0,[r0,#0x2c]
000022  1a08              SUBS     r0,r1,r0
000024  61a0              STR      r0,[r4,#0x18]
                  |L52.38|
;;;3971   				}
;;;3972   				else
;;;3973   				{
;;;3974   					mtCOVERAGE_TEST_MARKER();
;;;3975   				}
;;;3976   
;;;3977   				/* If the task being modified is in the ready state it will need
;;;3978   				to be moved into a new list. */
;;;3979   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
000026  6ae0              LDR      r0,[r4,#0x2c]
000028  2214              MOVS     r2,#0x14
00002a  4e12              LDR      r6,|L52.116|
00002c  4350              MULS     r0,r2,r0
00002e  6961              LDR      r1,[r4,#0x14]
000030  1980              ADDS     r0,r0,r6
000032  4281              CMP      r1,r0
000034  d110              BNE      |L52.88|
;;;3980   				{
;;;3981   					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000036  1d20              ADDS     r0,r4,#4
000038  f7fffffe          BL       uxListRemove
;;;3982   					{
;;;3983   						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
;;;3984   					}
;;;3985   					else
;;;3986   					{
;;;3987   						mtCOVERAGE_TEST_MARKER();
;;;3988   					}
;;;3989   
;;;3990   					/* Inherit the priority before being moved into the new list. */
;;;3991   					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
00003c  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00003e  6ac0              LDR      r0,[r0,#0x2c]
;;;3992   					prvAddTaskToReadyList( pxMutexHolderTCB );
000040  62e0              STR      r0,[r4,#0x2c]
000042  6929              LDR      r1,[r5,#0x10]  ; uxTopReadyPriority
000044  4288              CMP      r0,r1
000046  d900              BLS      |L52.74|
000048  6128              STR      r0,[r5,#0x10]  ; uxTopReadyPriority
                  |L52.74|
00004a  2114              MOVS     r1,#0x14
00004c  4348              MULS     r0,r1,r0
00004e  1980              ADDS     r0,r0,r6
000050  1d21              ADDS     r1,r4,#4
000052  f7fffffe          BL       vListInsertEnd
000056  e002              B        |L52.94|
                  |L52.88|
;;;3993   				}
;;;3994   				else
;;;3995   				{
;;;3996   					/* Just inherit the priority. */
;;;3997   					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
000058  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00005a  6ac0              LDR      r0,[r0,#0x2c]
00005c  62e0              STR      r0,[r4,#0x2c]
                  |L52.94|
;;;3998   				}
;;;3999   
;;;4000   				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
;;;4001   
;;;4002   				/* Inheritance occurred. */
;;;4003   				xReturn = pdTRUE;
00005e  2001              MOVS     r0,#1
                  |L52.96|
;;;4004   			}
;;;4005   			else
;;;4006   			{
;;;4007   				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
;;;4008   				{
;;;4009   					/* The base priority of the mutex holder is lower than the
;;;4010   					priority of the task attempting to take the mutex, but the
;;;4011   					current priority of the mutex holder is not lower than the
;;;4012   					priority of the task attempting to take the mutex.
;;;4013   					Therefore the mutex holder must have already inherited a
;;;4014   					priority, but inheritance would have occurred if that had
;;;4015   					not been the case. */
;;;4016   					xReturn = pdTRUE;
;;;4017   				}
;;;4018   				else
;;;4019   				{
;;;4020   					mtCOVERAGE_TEST_MARKER();
;;;4021   				}
;;;4022   			}
;;;4023   		}
;;;4024   		else
;;;4025   		{
;;;4026   			mtCOVERAGE_TEST_MARKER();
;;;4027   		}
;;;4028   
;;;4029   		return xReturn;
;;;4030   	}
000060  bd70              POP      {r4-r6,pc}
                  |L52.98|
000062  6ce1              LDR      r1,[r4,#0x4c]         ;4007
000064  682a              LDR      r2,[r5,#0]            ;4007  ; pxCurrentTCB
000066  6ad2              LDR      r2,[r2,#0x2c]         ;4007
000068  4291              CMP      r1,r2                 ;4007
00006a  d3f8              BCC      |L52.94|
00006c  bd70              POP      {r4-r6,pc}
;;;4031   
                          ENDP

00006e  0000              DCW      0x0000
                  |L52.112|
                          DCD      ||.data||
                  |L52.116|
                          DCD      ||.bss||

                          AREA ||i.xTaskRemoveFromEventList||, CODE, READONLY, ALIGN=2

                  xTaskRemoveFromEventList PROC
;;;3092   
;;;3093   BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
000000  b570              PUSH     {r4-r6,lr}
;;;3094   {
;;;3095   TCB_t *pxUnblockedTCB;
;;;3096   BaseType_t xReturn;
;;;3097   
;;;3098   	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
;;;3099   	called from a critical section within an ISR. */
;;;3100   
;;;3101   	/* The event list is sorted in priority order, so the first in the list can
;;;3102   	be removed as it is known to be the highest priority.  Remove the TCB from
;;;3103   	the delayed list, and add it to the ready list.
;;;3104   
;;;3105   	If an event is for a queue that is locked then this function will never
;;;3106   	get called - the lock count on the queue will get modified instead.  This
;;;3107   	means exclusive access to the event list is guaranteed here.
;;;3108   
;;;3109   	This function assumes that a check has already been made to ensure that
;;;3110   	pxEventList is not empty. */
;;;3111   	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000002  68c0              LDR      r0,[r0,#0xc]
;;;3112   	configASSERT( pxUnblockedTCB );
000004  68c4              LDR      r4,[r0,#0xc]
000006  2c00              CMP      r4,#0
000008  d00b              BEQ      |L53.34|
;;;3113   	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
00000a  4620              MOV      r0,r4
00000c  3018              ADDS     r0,r0,#0x18
00000e  4606              MOV      r6,r0
000010  f7fffffe          BL       uxListRemove
;;;3114   
;;;3115   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000014  4d11              LDR      r5,|L53.92|
000016  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
000018  2800              CMP      r0,#0
00001a  d004              BEQ      |L53.38|
00001c  4631              MOV      r1,r6
;;;3116   	{
;;;3117   		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
;;;3118   		prvAddTaskToReadyList( pxUnblockedTCB );
;;;3119   
;;;3120   		#if( configUSE_TICKLESS_IDLE != 0 )
;;;3121   		{
;;;3122   			/* If a task is blocked on a kernel object then xNextTaskUnblockTime
;;;3123   			might be set to the blocked task's time out time.  If the task is
;;;3124   			unblocked for a reason other than a timeout xNextTaskUnblockTime is
;;;3125   			normally left unchanged, because it is automatically reset to a new
;;;3126   			value when the tick count equals xNextTaskUnblockTime.  However if
;;;3127   			tickless idling is used it might be more important to enter sleep mode
;;;3128   			at the earliest possible time - so reset xNextTaskUnblockTime here to
;;;3129   			ensure it is updated at the earliest possible time. */
;;;3130   			prvResetNextTaskUnblockTime();
;;;3131   		}
;;;3132   		#endif
;;;3133   	}
;;;3134   	else
;;;3135   	{
;;;3136   		/* The delayed and ready lists cannot be accessed, so hold this task
;;;3137   		pending until the scheduler is resumed. */
;;;3138   		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
00001e  4810              LDR      r0,|L53.96|
000020  e00f              B        |L53.66|
                  |L53.34|
000022  b672              CPSID    i                     ;3112
                  |L53.36|
000024  e7fe              B        |L53.36|
                  |L53.38|
000026  1d20              ADDS     r0,r4,#4              ;3117
000028  f7fffffe          BL       uxListRemove
00002c  6ae0              LDR      r0,[r4,#0x2c]         ;3118
00002e  6929              LDR      r1,[r5,#0x10]         ;3118  ; uxTopReadyPriority
000030  4288              CMP      r0,r1                 ;3118
000032  d900              BLS      |L53.54|
000034  6128              STR      r0,[r5,#0x10]         ;3118  ; uxTopReadyPriority
                  |L53.54|
000036  2114              MOVS     r1,#0x14              ;3118
000038  4348              MULS     r0,r1,r0              ;3118
00003a  4909              LDR      r1,|L53.96|
00003c  398c              SUBS     r1,r1,#0x8c           ;3118
00003e  1840              ADDS     r0,r0,r1              ;3118
000040  1d21              ADDS     r1,r4,#4              ;3118
                  |L53.66|
000042  f7fffffe          BL       vListInsertEnd
;;;3139   	}
;;;3140   
;;;3141   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
000046  6ae0              LDR      r0,[r4,#0x2c]
000048  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
00004a  6ac9              LDR      r1,[r1,#0x2c]
00004c  4288              CMP      r0,r1
00004e  d902              BLS      |L53.86|
;;;3142   	{
;;;3143   		/* Return true if the task removed from the event list has a higher
;;;3144   		priority than the calling task.  This allows the calling task to know if
;;;3145   		it should force a context switch now. */
;;;3146   		xReturn = pdTRUE;
000050  2001              MOVS     r0,#1
;;;3147   
;;;3148   		/* Mark that a yield is pending in case the user is not using the
;;;3149   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;3150   		xYieldPending = pdTRUE;
000052  61e8              STR      r0,[r5,#0x1c]  ; xYieldPending
;;;3151   	}
;;;3152   	else
;;;3153   	{
;;;3154   		xReturn = pdFALSE;
;;;3155   	}
;;;3156   
;;;3157   	return xReturn;
;;;3158   }
000054  bd70              POP      {r4-r6,pc}
                  |L53.86|
000056  2000              MOVS     r0,#0                 ;3154
000058  bd70              POP      {r4-r6,pc}
;;;3159   /*-----------------------------------------------------------*/
                          ENDP

00005a  0000              DCW      0x0000
                  |L53.92|
                          DCD      ||.data||
                  |L53.96|
                          DCD      ||.bss||+0x8c

                          AREA ||i.xTaskResumeAll||, CODE, READONLY, ALIGN=2

                  xTaskResumeAll PROC
;;;2172   
;;;2173   BaseType_t xTaskResumeAll( void )
000000  b5f8              PUSH     {r3-r7,lr}
;;;2174   {
;;;2175   TCB_t *pxTCB = NULL;
;;;2176   BaseType_t xAlreadyYielded = pdFALSE;
;;;2177   
;;;2178   	/* If uxSchedulerSuspended is zero then this function does not match a
;;;2179   	previous call to vTaskSuspendAll(). */
;;;2180   	configASSERT( uxSchedulerSuspended );
000002  4d28              LDR      r5,|L54.164|
000004  2400              MOVS     r4,#0                 ;2175
000006  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
000008  4627              MOV      r7,r4                 ;2176
00000a  2800              CMP      r0,#0
00000c  d008              BEQ      |L54.32|
;;;2181   
;;;2182   	/* It is possible that an ISR caused a task to be removed from an event
;;;2183   	list while the scheduler was suspended.  If this was the case then the
;;;2184   	removed task will have been added to the xPendingReadyList.  Once the
;;;2185   	scheduler has been resumed it is safe to move all the pending ready
;;;2186   	tasks from this list into their appropriate ready list. */
;;;2187   	taskENTER_CRITICAL();
00000e  f7fffffe          BL       vPortEnterCritical
;;;2188   	{
;;;2189   		--uxSchedulerSuspended;
000012  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
000014  1e40              SUBS     r0,r0,#1
000016  6328              STR      r0,[r5,#0x30]  ; uxSchedulerSuspended
;;;2190   
;;;2191   		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000018  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
00001a  2800              CMP      r0,#0
00001c  d002              BEQ      |L54.36|
00001e  e03c              B        |L54.154|
                  |L54.32|
000020  b672              CPSID    i                     ;2180
                  |L54.34|
000022  e7fe              B        |L54.34|
                  |L54.36|
;;;2192   		{
;;;2193   			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
000024  68a8              LDR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
;;;2194   			{
;;;2195   				/* Move any readied tasks from the pending list into the
;;;2196   				appropriate ready list. */
;;;2197   				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
;;;2198   				{
;;;2199   					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
;;;2200   					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
;;;2201   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
;;;2202   					prvAddTaskToReadyList( pxTCB );
;;;2203   
;;;2204   					/* If the moved task has a priority higher than the current
;;;2205   					task then a yield must be performed. */
;;;2206   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
;;;2207   					{
;;;2208   						xYieldPending = pdTRUE;
000026  2601              MOVS     r6,#1
000028  2800              CMP      r0,#0                 ;2193
00002a  d11b              BNE      |L54.100|
00002c  e035              B        |L54.154|
                  |L54.46|
00002e  68c0              LDR      r0,[r0,#0xc]          ;2199  ; xPendingReadyList
000030  68c4              LDR      r4,[r0,#0xc]          ;2200
000032  4620              MOV      r0,r4                 ;2200
000034  3018              ADDS     r0,r0,#0x18           ;2200
000036  f7fffffe          BL       uxListRemove
00003a  1d20              ADDS     r0,r4,#4              ;2201
00003c  f7fffffe          BL       uxListRemove
000040  6ae0              LDR      r0,[r4,#0x2c]         ;2202
000042  6929              LDR      r1,[r5,#0x10]         ;2202  ; uxTopReadyPriority
000044  4288              CMP      r0,r1                 ;2202
000046  d900              BLS      |L54.74|
000048  6128              STR      r0,[r5,#0x10]         ;2202  ; uxTopReadyPriority
                  |L54.74|
00004a  2114              MOVS     r1,#0x14              ;2202
00004c  4348              MULS     r0,r1,r0              ;2202
00004e  4916              LDR      r1,|L54.168|
000050  1840              ADDS     r0,r0,r1              ;2202
000052  1d21              ADDS     r1,r4,#4              ;2202
000054  f7fffffe          BL       vListInsertEnd
000058  6ae0              LDR      r0,[r4,#0x2c]         ;2206
00005a  6829              LDR      r1,[r5,#0]            ;2206  ; pxCurrentTCB
00005c  6ac9              LDR      r1,[r1,#0x2c]         ;2206
00005e  4288              CMP      r0,r1                 ;2206
000060  d300              BCC      |L54.100|
000062  61ee              STR      r6,[r5,#0x1c]  ; xYieldPending
                  |L54.100|
000064  4810              LDR      r0,|L54.168|
000066  308c              ADDS     r0,r0,#0x8c           ;2197
000068  6801              LDR      r1,[r0,#0]            ;2197  ; xPendingReadyList
00006a  2900              CMP      r1,#0                 ;2197
00006c  d1df              BNE      |L54.46|
;;;2209   					}
;;;2210   					else
;;;2211   					{
;;;2212   						mtCOVERAGE_TEST_MARKER();
;;;2213   					}
;;;2214   				}
;;;2215   
;;;2216   				if( pxTCB != NULL )
00006e  2c00              CMP      r4,#0
000070  d001              BEQ      |L54.118|
;;;2217   				{
;;;2218   					/* A task was unblocked while the scheduler was suspended,
;;;2219   					which may have prevented the next unblock time from being
;;;2220   					re-calculated, in which case re-calculate it now.  Mainly
;;;2221   					important for low power tickless implementations, where
;;;2222   					this can prevent an unnecessary exit from low power
;;;2223   					state. */
;;;2224   					prvResetNextTaskUnblockTime();
000072  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L54.118|
;;;2225   				}
;;;2226   
;;;2227   				/* If any ticks occurred while the scheduler was suspended then
;;;2228   				they should be processed now.  This ensures the tick count does
;;;2229   				not	slip, and that any delayed tasks are resumed at the correct
;;;2230   				time. */
;;;2231   				{
;;;2232   					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
000076  69ac              LDR      r4,[r5,#0x18]  ; uxPendedTicks
;;;2233   
;;;2234   					if( uxPendedCounts > ( UBaseType_t ) 0U )
000078  2c00              CMP      r4,#0
00007a  d008              BEQ      |L54.142|
                  |L54.124|
;;;2235   					{
;;;2236   						do
;;;2237   						{
;;;2238   							if( xTaskIncrementTick() != pdFALSE )
00007c  f7fffffe          BL       xTaskIncrementTick
000080  2800              CMP      r0,#0
000082  d000              BEQ      |L54.134|
;;;2239   							{
;;;2240   								xYieldPending = pdTRUE;
000084  61ee              STR      r6,[r5,#0x1c]  ; xYieldPending
                  |L54.134|
000086  1e64              SUBS     r4,r4,#1
;;;2241   							}
;;;2242   							else
;;;2243   							{
;;;2244   								mtCOVERAGE_TEST_MARKER();
;;;2245   							}
;;;2246   							--uxPendedCounts;
;;;2247   						} while( uxPendedCounts > ( UBaseType_t ) 0U );
000088  d1f8              BNE      |L54.124|
;;;2248   
;;;2249   						uxPendedTicks = 0;
00008a  2000              MOVS     r0,#0
00008c  61a8              STR      r0,[r5,#0x18]  ; uxPendedTicks
                  |L54.142|
;;;2250   					}
;;;2251   					else
;;;2252   					{
;;;2253   						mtCOVERAGE_TEST_MARKER();
;;;2254   					}
;;;2255   				}
;;;2256   
;;;2257   				if( xYieldPending != pdFALSE )
00008e  69e8              LDR      r0,[r5,#0x1c]  ; xYieldPending
000090  2800              CMP      r0,#0
000092  d002              BEQ      |L54.154|
;;;2258   				{
;;;2259   					#if( configUSE_PREEMPTION != 0 )
;;;2260   					{
;;;2261   						xAlreadyYielded = pdTRUE;
000094  2701              MOVS     r7,#1
;;;2262   					}
;;;2263   					#endif
;;;2264   					taskYIELD_IF_USING_PREEMPTION();
000096  f7fffffe          BL       vPortYield
                  |L54.154|
;;;2265   				}
;;;2266   				else
;;;2267   				{
;;;2268   					mtCOVERAGE_TEST_MARKER();
;;;2269   				}
;;;2270   			}
;;;2271   		}
;;;2272   		else
;;;2273   		{
;;;2274   			mtCOVERAGE_TEST_MARKER();
;;;2275   		}
;;;2276   	}
;;;2277   	taskEXIT_CRITICAL();
00009a  f7fffffe          BL       vPortExitCritical
;;;2278   
;;;2279   	return xAlreadyYielded;
00009e  4638              MOV      r0,r7
;;;2280   }
0000a0  bdf8              POP      {r3-r7,pc}
;;;2281   /*-----------------------------------------------------------*/
                          ENDP

0000a2  0000              DCW      0x0000
                  |L54.164|
                          DCD      ||.data||
                  |L54.168|
                          DCD      ||.bss||

                          AREA ||i.xTaskResumeFromISR||, CODE, READONLY, ALIGN=2

                  xTaskResumeFromISR PROC
;;;1896   
;;;1897   	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
000000  b5f8              PUSH     {r3-r7,lr}
;;;1898   	{
;;;1899   	BaseType_t xYieldRequired = pdFALSE;
000002  2500              MOVS     r5,#0
;;;1900   	TCB_t * const pxTCB = xTaskToResume;
000004  0004              MOVS     r4,r0
000006  d00f              BEQ      |L55.40|
;;;1901   	UBaseType_t uxSavedInterruptStatus;
;;;1902   
;;;1903   		configASSERT( xTaskToResume );
;;;1904   
;;;1905   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1906   		maximum	system call (or maximum API call) interrupt priority.
;;;1907   		Interrupts that are	above the maximum system call priority are keep
;;;1908   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1909   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1910   		is defined in FreeRTOSConfig.h then
;;;1911   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1912   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1913   		been assigned a priority above the configured maximum system call
;;;1914   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1915   		from interrupts	that have been assigned a priority at or (logically)
;;;1916   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1917   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1918   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1919   		provided on the following link:
;;;1920   		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1921   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1922   
;;;1923   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000008  f7fffffe          BL       ulSetInterruptMaskFromISR
00000c  4607              MOV      r7,r0
;;;1924   		{
;;;1925   			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       prvTaskIsTaskSuspended
000014  2800              CMP      r0,#0
000016  d01f              BEQ      |L55.88|
;;;1926   			{
;;;1927   				traceTASK_RESUME_FROM_ISR( pxTCB );
;;;1928   
;;;1929   				/* Check the ready lists can be accessed. */
;;;1930   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000018  4e12              LDR      r6,|L55.100|
00001a  6b30              LDR      r0,[r6,#0x30]  ; uxSchedulerSuspended
00001c  2800              CMP      r0,#0
00001e  d005              BEQ      |L55.44|
;;;1931   				{
;;;1932   					/* Ready lists can be accessed so move the task from the
;;;1933   					suspended list to the ready list directly. */
;;;1934   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
;;;1935   					{
;;;1936   						xYieldRequired = pdTRUE;
;;;1937   					}
;;;1938   					else
;;;1939   					{
;;;1940   						mtCOVERAGE_TEST_MARKER();
;;;1941   					}
;;;1942   
;;;1943   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
;;;1944   					prvAddTaskToReadyList( pxTCB );
;;;1945   				}
;;;1946   				else
;;;1947   				{
;;;1948   					/* The delayed or ready lists cannot be accessed so the task
;;;1949   					is held in the pending ready list until the scheduler is
;;;1950   					unsuspended. */
;;;1951   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000020  4621              MOV      r1,r4
000022  3118              ADDS     r1,r1,#0x18
000024  4810              LDR      r0,|L55.104|
000026  e015              B        |L55.84|
                  |L55.40|
000028  b672              CPSID    i                     ;1903
                  |L55.42|
00002a  e7fe              B        |L55.42|
                  |L55.44|
00002c  6ae0              LDR      r0,[r4,#0x2c]         ;1934
00002e  6831              LDR      r1,[r6,#0]            ;1934  ; pxCurrentTCB
000030  6ac9              LDR      r1,[r1,#0x2c]         ;1934
000032  4288              CMP      r0,r1                 ;1934
000034  d300              BCC      |L55.56|
000036  2501              MOVS     r5,#1                 ;1936
                  |L55.56|
000038  1d20              ADDS     r0,r4,#4              ;1943
00003a  f7fffffe          BL       uxListRemove
00003e  6ae0              LDR      r0,[r4,#0x2c]         ;1944
000040  6931              LDR      r1,[r6,#0x10]         ;1944  ; uxTopReadyPriority
000042  4288              CMP      r0,r1                 ;1944
000044  d900              BLS      |L55.72|
000046  6130              STR      r0,[r6,#0x10]         ;1944  ; uxTopReadyPriority
                  |L55.72|
000048  2114              MOVS     r1,#0x14              ;1944
00004a  4348              MULS     r0,r1,r0              ;1944
00004c  4906              LDR      r1,|L55.104|
00004e  398c              SUBS     r1,r1,#0x8c           ;1944
000050  1840              ADDS     r0,r0,r1              ;1944
000052  1d21              ADDS     r1,r4,#4              ;1944
                  |L55.84|
000054  f7fffffe          BL       vListInsertEnd
                  |L55.88|
;;;1952   				}
;;;1953   			}
;;;1954   			else
;;;1955   			{
;;;1956   				mtCOVERAGE_TEST_MARKER();
;;;1957   			}
;;;1958   		}
;;;1959   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000058  4638              MOV      r0,r7
00005a  f7fffffe          BL       vClearInterruptMaskFromISR
;;;1960   
;;;1961   		return xYieldRequired;
00005e  4628              MOV      r0,r5
;;;1962   	}
000060  bdf8              POP      {r3-r7,pc}
;;;1963   
                          ENDP

000062  0000              DCW      0x0000
                  |L55.100|
                          DCD      ||.data||
                  |L55.104|
                          DCD      ||.bss||+0x8c

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  pxReadyTasksLists
                          %        100
                  xDelayedTaskList1
                          %        20
                  xDelayedTaskList2
                          %        20
                  xPendingReadyList
                          %        20
                  xTasksWaitingTermination
                          %        20
                  xSuspendedTaskList
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  pxCurrentTCB
                          DCD      0x00000000
                  uxDeletedTasksWaitingCleanUp
                          DCD      0x00000000
                  uxCurrentNumberOfTasks
                          DCD      0x00000000
                  xTickCount
                          DCD      0x00000000
                  uxTopReadyPriority
                          DCD      0x00000000
                  xSchedulerRunning
                          DCD      0x00000000
                  uxPendedTicks
                          DCD      0x00000000
                  xYieldPending
                          DCD      0x00000000
                  xNumOfOverflows
                          DCD      0x00000000
                  uxTaskNumber
                          DCD      0x00000000
                  xNextTaskUnblockTime
                          DCD      0x00000000
                  xIdleTaskHandle
                          DCD      0x00000000
                  uxSchedulerSuspended
                          DCD      0x00000000
                  pxDelayedTaskList
                          DCD      0x00000000
                  pxOverflowDelayedTaskList
                          DCD      0x00000000

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d200              BCS      |L331.16|
00000e  461d              MOV      r5,r3
                  |L331.16|
000010  5d63              LDRB     r3,[r4,r5]
000012  005b              LSLS     r3,r3,#1
000014  18e3              ADDS     r3,r4,r3
000016  bc30              POP      {r4,r5}
000018  4718              BX       r3
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\ThirdParty\\FreeRTOS\\Source\\tasks.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_tasks_c_f31043e3____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___7_tasks_c_f31043e3____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_tasks_c_f31043e3____REVSH|
#line 402
|__asm___7_tasks_c_f31043e3____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
